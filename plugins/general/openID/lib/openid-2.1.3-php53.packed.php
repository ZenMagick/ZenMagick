<?php  define('Auth_OpenID_SUCCESS', 'success'); define('Auth_OpenID_CANCEL', 'cancel'); define('Auth_OpenID_FAILURE', 'failure'); define('Auth_OpenID_SETUP_NEEDED', 'setup needed'); define('Auth_OpenID_PARSE_ERROR', 'parse error'); class Auth_OpenID_Consumer { var $discoverMethod = 'Auth_OpenID_discover'; var $session_key_prefix = "_openid_consumer_"; var $_token_suffix = "last_token"; function Auth_OpenID_Consumer(&$store, $session = null, $consumer_cls = null) { if ($session === null) { $session = new Auth_Yadis_PHPSession(); } $this->session =& $session; if ($consumer_cls !== null) { $this->consumer = new $consumer_cls($store); } else { $this->consumer = new Auth_OpenID_GenericConsumer($store); } $this->_token_key = $this->session_key_prefix . $this->_token_suffix; } function getDiscoveryObject(&$session, $openid_url, $session_key_prefix) { return new Auth_Yadis_Discovery($session, $openid_url, $session_key_prefix); } function begin($user_url, $anonymous=false) { $openid_url = $user_url; $disco = $this->getDiscoveryObject($this->session, $openid_url, $this->session_key_prefix); $m = $disco->getManager(); $loader = new Auth_Yadis_ManagerLoader(); if ($m) { if ($m->stale) { $disco->destroyManager(); } else { $m->stale = true; $disco->session->set($disco->session_key, serialize($loader->toSession($m))); } } $endpoint = $disco->getNextService($this->discoverMethod, $this->consumer->fetcher); $m =& $disco->getManager(); if ($m) { $m->stale = false; $disco->session->set($disco->session_key, serialize($loader->toSession($m))); } if ($endpoint === null) { return null; } else { return $this->beginWithoutDiscovery($endpoint, $anonymous); } } function &beginWithoutDiscovery($endpoint, $anonymous=false) { $loader = new Auth_OpenID_ServiceEndpointLoader(); $auth_req = $this->consumer->begin($endpoint); $this->session->set($this->_token_key, $loader->toSession($auth_req->endpoint)); if (!$auth_req->setAnonymous($anonymous)) { return new Auth_OpenID_FailureResponse(null, "OpenID 1 requests MUST include the identifier " . "in the request."); } return $auth_req; } function complete($current_url, $query=null) { if ($current_url && !is_string($current_url)) { trigger_error("current_url must be a string; see NEWS file " . "for upgrading notes.", E_USER_ERROR); } if ($query === null) { $query = Auth_OpenID::getQuery(); } $loader = new Auth_OpenID_ServiceEndpointLoader(); $endpoint_data = $this->session->get($this->_token_key); $endpoint = $loader->fromSession($endpoint_data); $message = Auth_OpenID_Message::fromPostArgs($query); $response = $this->consumer->complete($message, $endpoint, $current_url); $this->session->del($this->_token_key); if (in_array($response->status, array(Auth_OpenID_SUCCESS, Auth_OpenID_CANCEL))) { if ($response->identity_url !== null) { $disco = $this->getDiscoveryObject($this->session, $response->identity_url, $this->session_key_prefix); $disco->cleanup(true); } } return $response; } } class Auth_OpenID_DiffieHellmanSHA1ConsumerSession { var $session_type = 'DH-SHA1'; var $hash_func = 'Auth_OpenID_SHA1'; var $secret_size = 20; var $allowed_assoc_types = array('HMAC-SHA1'); function Auth_OpenID_DiffieHellmanSHA1ConsumerSession($dh = null) { if ($dh === null) { $dh = new Auth_OpenID_DiffieHellman(); } $this->dh = $dh; } function getRequest() { $math =& Auth_OpenID_getMathLib(); $cpub = $math->longToBase64($this->dh->public); $args = array('dh_consumer_public' => $cpub); if (!$this->dh->usingDefaultValues()) { $args = array_merge($args, array( 'dh_modulus' => $math->longToBase64($this->dh->mod), 'dh_gen' => $math->longToBase64($this->dh->gen))); } return $args; } function extractSecret($response) { if (!$response->hasKey(Auth_OpenID_OPENID_NS, 'dh_server_public')) { return null; } if (!$response->hasKey(Auth_OpenID_OPENID_NS, 'enc_mac_key')) { return null; } $math =& Auth_OpenID_getMathLib(); $spub = $math->base64ToLong($response->getArg(Auth_OpenID_OPENID_NS, 'dh_server_public')); $enc_mac_key = base64_decode($response->getArg(Auth_OpenID_OPENID_NS, 'enc_mac_key')); return $this->dh->xorSecret($spub, $enc_mac_key, $this->hash_func); } } class Auth_OpenID_DiffieHellmanSHA256ConsumerSession extends Auth_OpenID_DiffieHellmanSHA1ConsumerSession { var $session_type = 'DH-SHA256'; var $hash_func = 'Auth_OpenID_SHA256'; var $secret_size = 32; var $allowed_assoc_types = array('HMAC-SHA256'); } class Auth_OpenID_PlainTextConsumerSession { var $session_type = 'no-encryption'; var $allowed_assoc_types = array('HMAC-SHA1', 'HMAC-SHA256'); function getRequest() { return array(); } function extractSecret($response) { if (!$response->hasKey(Auth_OpenID_OPENID_NS, 'mac_key')) { return null; } return base64_decode($response->getArg(Auth_OpenID_OPENID_NS, 'mac_key')); } } function Auth_OpenID_getAvailableSessionTypes() { $types = array( 'no-encryption' => 'Auth_OpenID_PlainTextConsumerSession', 'DH-SHA1' => 'Auth_OpenID_DiffieHellmanSHA1ConsumerSession', 'DH-SHA256' => 'Auth_OpenID_DiffieHellmanSHA256ConsumerSession'); return $types; } class Auth_OpenID_GenericConsumer { var $discoverMethod = 'Auth_OpenID_discover'; var $store; var $_use_assocs; var $openid1_nonce_query_arg_name = 'janrain_nonce'; var $openid1_return_to_identifier_name = 'openid1_claimed_id'; function Auth_OpenID_GenericConsumer(&$store) { $this->store =& $store; $this->negotiator =& Auth_OpenID_getDefaultNegotiator(); $this->_use_assocs = ($this->store ? true : false); $this->fetcher = Auth_Yadis_Yadis::getHTTPFetcher(); $this->session_types = Auth_OpenID_getAvailableSessionTypes(); } function begin($service_endpoint) { $assoc = $this->_getAssociation($service_endpoint); $r = new Auth_OpenID_AuthRequest($service_endpoint, $assoc); $r->return_to_args[$this->openid1_nonce_query_arg_name] = Auth_OpenID_mkNonce(); if ($r->message->isOpenID1()) { $r->return_to_args[$this->openid1_return_to_identifier_name] = $r->endpoint->claimed_id; } return $r; } function complete($message, $endpoint, $return_to) { $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode', '<no mode set>'); $mode_methods = array( 'cancel' => '_complete_cancel', 'error' => '_complete_error', 'setup_needed' => '_complete_setup_needed', 'id_res' => '_complete_id_res', ); $method = Auth_OpenID::arrayGet($mode_methods, $mode, '_completeInvalid'); return call_user_func_array(array(&$this, $method), array($message, $endpoint, $return_to)); } function _completeInvalid($message, $endpoint, $unused) { $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode', '<No mode set>'); return new Auth_OpenID_FailureResponse($endpoint, sprintf("Invalid openid.mode '%s'", $mode)); } function _complete_cancel($message, $endpoint, $unused) { return new Auth_OpenID_CancelResponse($endpoint); } function _complete_error($message, $endpoint, $unused) { $error = $message->getArg(Auth_OpenID_OPENID_NS, 'error'); $contact = $message->getArg(Auth_OpenID_OPENID_NS, 'contact'); $reference = $message->getArg(Auth_OpenID_OPENID_NS, 'reference'); return new Auth_OpenID_FailureResponse($endpoint, $error, $contact, $reference); } function _complete_setup_needed($message, $endpoint, $unused) { if (!$message->isOpenID2()) { return $this->_completeInvalid($message, $endpoint); } $user_setup_url = $message->getArg(Auth_OpenID_OPENID2_NS, 'user_setup_url'); return new Auth_OpenID_SetupNeededResponse($endpoint, $user_setup_url); } function _complete_id_res($message, $endpoint, $return_to) { $user_setup_url = $message->getArg(Auth_OpenID_OPENID1_NS, 'user_setup_url'); if ($this->_checkSetupNeeded($message)) { return new Auth_OpenID_SetupNeededResponse( $endpoint, $user_setup_url); } else { return $this->_doIdRes($message, $endpoint, $return_to); } } function _checkSetupNeeded($message) { if ($message->isOpenID1()) { $user_setup_url = $message->getArg(Auth_OpenID_OPENID1_NS, 'user_setup_url'); if ($user_setup_url !== null) { return true; } } return false; } function _doIdRes($message, $endpoint, $return_to) { $result = $this->_idResCheckForFields($message); if (Auth_OpenID::isFailure($result)) { return $result; } if (!$this->_checkReturnTo($message, $return_to)) { return new Auth_OpenID_FailureResponse(null, sprintf("return_to does not match return URL. Expected %s, got %s", $return_to, $message->getArg(Auth_OpenID_OPENID_NS, 'return_to'))); } $result = $this->_verifyDiscoveryResults($message, $endpoint); if (Auth_OpenID::isFailure($result)) { return $result; } $endpoint = $result; $result = $this->_idResCheckSignature($message, $endpoint->server_url); if (Auth_OpenID::isFailure($result)) { return $result; } $result = $this->_idResCheckNonce($message, $endpoint); if (Auth_OpenID::isFailure($result)) { return $result; } $signed_list_str = $message->getArg(Auth_OpenID_OPENID_NS, 'signed', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($signed_list_str)) { return $signed_list_str; } $signed_list = explode(',', $signed_list_str); $signed_fields = Auth_OpenID::addPrefix($signed_list, "openid."); return new Auth_OpenID_SuccessResponse($endpoint, $message, $signed_fields); } function _checkReturnTo($message, $return_to) { $result = Auth_OpenID_GenericConsumer::_verifyReturnToArgs( $message->toPostArgs()); if (Auth_OpenID::isFailure($result)) { return false; } $msg_return_to = $message->getArg(Auth_OpenID_OPENID_NS, 'return_to'); if (Auth_OpenID::isFailure($return_to)) { return false; } $return_to_parts = parse_url(Auth_OpenID_urinorm($return_to)); $msg_return_to_parts = parse_url(Auth_OpenID_urinorm($msg_return_to)); if ((!array_key_exists('port', $return_to_parts)) && (!array_key_exists('port', $msg_return_to_parts))) { $return_to_parts['port'] = null; $msg_return_to_parts['port'] = null; } if ((!array_key_exists('path', $return_to_parts)) && (!array_key_exists('path', $msg_return_to_parts))) { $return_to_parts['path'] = null; $msg_return_to_parts['path'] = null; } foreach (array('scheme', 'host', 'port', 'path') as $component) { if (!array_key_exists($component, $return_to_parts)) { return false; } if (!array_key_exists($component, $msg_return_to_parts)) { return false; } if (Auth_OpenID::arrayGet($return_to_parts, $component) !== Auth_OpenID::arrayGet($msg_return_to_parts, $component)) { return false; } } return true; } function _verifyReturnToArgs($query) { $message = Auth_OpenID_Message::fromPostArgs($query); $return_to = $message->getArg(Auth_OpenID_OPENID_NS, 'return_to'); if (Auth_OpenID::isFailure($return_to)) { return $return_to; } if (!$return_to) { return new Auth_OpenID_FailureResponse(null, "Response has no return_to"); } $parsed_url = parse_url($return_to); $q = array(); if (array_key_exists('query', $parsed_url)) { $rt_query = $parsed_url['query']; $q = Auth_OpenID::parse_str($rt_query); } foreach ($q as $rt_key => $rt_value) { if (!array_key_exists($rt_key, $query)) { return new Auth_OpenID_FailureResponse(null, sprintf("return_to parameter %s absent from query", $rt_key)); } else { $value = $query[$rt_key]; if ($rt_value != $value) { return new Auth_OpenID_FailureResponse(null, sprintf("parameter %s value %s does not match " . "return_to value %s", $rt_key, $value, $rt_value)); } } } $bare_args = $message->getArgs(Auth_OpenID_BARE_NS); foreach ($bare_args as $key => $value) { if (Auth_OpenID::arrayGet($q, $key) != $value) { return new Auth_OpenID_FailureResponse(null, sprintf("Parameter %s = %s not in return_to URL", $key, $value)); } } return true; } function _idResCheckSignature($message, $server_url) { $assoc_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_handle'); if (Auth_OpenID::isFailure($assoc_handle)) { return $assoc_handle; } $assoc = $this->store->getAssociation($server_url, $assoc_handle); if ($assoc) { if ($assoc->getExpiresIn() <= 0) { return new Auth_OpenID_FailureResponse(null, 'Association with ' . $server_url . ' expired'); } if (!$assoc->checkMessageSignature($message)) { return new Auth_OpenID_FailureResponse(null, "Bad signature"); } } else { if (!$this->_checkAuth($message, $server_url)) { return new Auth_OpenID_FailureResponse(null, "Server denied check_authentication"); } } return null; } function _verifyDiscoveryResults($message, $endpoint=null) { if ($message->getOpenIDNamespace() == Auth_OpenID_OPENID2_NS) { return $this->_verifyDiscoveryResultsOpenID2($message, $endpoint); } else { return $this->_verifyDiscoveryResultsOpenID1($message, $endpoint); } } function _verifyDiscoveryResultsOpenID1($message, $endpoint) { $claimed_id = $message->getArg(Auth_OpenID_BARE_NS, $this->openid1_return_to_identifier_name); if (($endpoint === null) && ($claimed_id === null)) { return new Auth_OpenID_FailureResponse($endpoint, 'When using OpenID 1, the claimed ID must be supplied, ' . 'either by passing it through as a return_to parameter ' . 'or by using a session, and supplied to the GenericConsumer ' . 'as the argument to complete()'); } else if (($endpoint !== null) && ($claimed_id === null)) { $claimed_id = $endpoint->claimed_id; } $to_match = new Auth_OpenID_ServiceEndpoint(); $to_match->type_uris = array(Auth_OpenID_TYPE_1_1); $to_match->local_id = $message->getArg(Auth_OpenID_OPENID1_NS, 'identity'); $to_match->claimed_id = $claimed_id; if ($to_match->local_id === null) { return new Auth_OpenID_FailureResponse($endpoint, "Missing required field openid.identity"); } $to_match_1_0 = $to_match->copy(); $to_match_1_0->type_uris = array(Auth_OpenID_TYPE_1_0); if ($endpoint !== null) { $result = $this->_verifyDiscoverySingle($endpoint, $to_match); if (is_a($result, 'Auth_OpenID_TypeURIMismatch')) { $result = $this->_verifyDiscoverySingle($endpoint, $to_match_1_0); } if (Auth_OpenID::isFailure($result)) { } else { return $endpoint; } } return $this->_discoverAndVerify($to_match->claimed_id, array($to_match, $to_match_1_0)); } function _verifyDiscoverySingle($endpoint, $to_match) { foreach ($to_match->type_uris as $type_uri) { if (!$endpoint->usesExtension($type_uri)) { return new Auth_OpenID_TypeURIMismatch($endpoint, "Required type ".$type_uri." not present"); } } list($defragged_claimed_id, $_) = Auth_OpenID::urldefrag($to_match->claimed_id); if ($defragged_claimed_id != $endpoint->claimed_id) { return new Auth_OpenID_FailureResponse($endpoint, sprintf('Claimed ID does not match (different subjects!), ' . 'Expected %s, got %s', $defragged_claimed_id, $endpoint->claimed_id)); } if ($to_match->getLocalID() != $endpoint->getLocalID()) { return new Auth_OpenID_FailureResponse($endpoint, sprintf('local_id mismatch. Expected %s, got %s', $to_match->getLocalID(), $endpoint->getLocalID())); } if ($to_match->server_url === null) { if ($to_match->preferredNamespace() != Auth_OpenID_OPENID1_NS) { return new Auth_OpenID_FailureResponse($endpoint, "Preferred namespace mismatch (bug)"); } } else if ($to_match->server_url != $endpoint->server_url) { return new Auth_OpenID_FailureResponse($endpoint, sprintf('OP Endpoint mismatch. Expected %s, got %s', $to_match->server_url, $endpoint->server_url)); } return null; } function _verifyDiscoveryResultsOpenID2($message, $endpoint) { $to_match = new Auth_OpenID_ServiceEndpoint(); $to_match->type_uris = array(Auth_OpenID_TYPE_2_0); $to_match->claimed_id = $message->getArg(Auth_OpenID_OPENID2_NS, 'claimed_id'); $to_match->local_id = $message->getArg(Auth_OpenID_OPENID2_NS, 'identity'); $to_match->server_url = $message->getArg(Auth_OpenID_OPENID2_NS, 'op_endpoint'); if ($to_match->server_url === null) { return new Auth_OpenID_FailureResponse($endpoint, "OP Endpoint URL missing"); } if (($to_match->claimed_id === null) && ($to_match->local_id !== null)) { return new Auth_OpenID_FailureResponse($endpoint, 'openid.identity is present without openid.claimed_id'); } if (($to_match->claimed_id !== null) && ($to_match->local_id === null)) { return new Auth_OpenID_FailureResponse($endpoint, 'openid.claimed_id is present without openid.identity'); } if ($to_match->claimed_id === null) { return Auth_OpenID_ServiceEndpoint::fromOPEndpointURL( $to_match->server_url); } if (!$endpoint) { return $this->_discoverAndVerify($to_match->claimed_id, array($to_match)); } else { $result = $this->_verifyDiscoverySingle($endpoint, $to_match); if (Auth_OpenID::isFailure($result)) { $endpoint = $this->_discoverAndVerify($to_match->claimed_id, array($to_match)); if (Auth_OpenID::isFailure($endpoint)) { return $endpoint; } } } if ($endpoint->claimed_id != $to_match->claimed_id) { $endpoint->claimed_id = $to_match->claimed_id; } return $endpoint; } function _discoverAndVerify($claimed_id, $to_match_endpoints) { list($unused, $services) = call_user_func($this->discoverMethod, $claimed_id, $this->fetcher); if (!$services) { return new Auth_OpenID_FailureResponse(null, sprintf("No OpenID information found at %s", $claimed_id)); } return $this->_verifyDiscoveryServices($claimed_id, $services, $to_match_endpoints); } function _verifyDiscoveryServices($claimed_id, &$services, &$to_match_endpoints) { foreach ($services as $endpoint) { foreach ($to_match_endpoints as $to_match_endpoint) { $result = $this->_verifyDiscoverySingle($endpoint, $to_match_endpoint); if (!Auth_OpenID::isFailure($result)) { return $endpoint; } } } return new Auth_OpenID_FailureResponse(null, sprintf('No matching endpoint found after discovering %s', $claimed_id)); } function _idResGetNonceOpenID1($message, $endpoint) { return $message->getArg(Auth_OpenID_BARE_NS, $this->openid1_nonce_query_arg_name); } function _idResCheckNonce($message, $endpoint) { if ($message->isOpenID1()) { $nonce = $this->_idResGetNonceOpenID1($message, $endpoint); $server_url = ''; } else { $nonce = $message->getArg(Auth_OpenID_OPENID2_NS, 'response_nonce'); $server_url = $endpoint->server_url; } if ($nonce === null) { return new Auth_OpenID_FailureResponse($endpoint, "Nonce missing from response"); } $parts = Auth_OpenID_splitNonce($nonce); if ($parts === null) { return new Auth_OpenID_FailureResponse($endpoint, "Malformed nonce in response"); } list($timestamp, $salt) = $parts; if (!$this->store->useNonce($server_url, $timestamp, $salt)) { return new Auth_OpenID_FailureResponse($endpoint, "Nonce already used or out of range"); } return null; } function _idResCheckForFields($message) { $basic_fields = array('return_to', 'assoc_handle', 'sig', 'signed'); $basic_sig_fields = array('return_to', 'identity'); $require_fields = array( Auth_OpenID_OPENID2_NS => array_merge($basic_fields, array('op_endpoint')), Auth_OpenID_OPENID1_NS => array_merge($basic_fields, array('identity')) ); $require_sigs = array( Auth_OpenID_OPENID2_NS => array_merge($basic_sig_fields, array('response_nonce', 'claimed_id', 'assoc_handle', 'op_endpoint')), Auth_OpenID_OPENID1_NS => array_merge($basic_sig_fields, array('nonce')) ); foreach ($require_fields[$message->getOpenIDNamespace()] as $field) { if (!$message->hasKey(Auth_OpenID_OPENID_NS, $field)) { return new Auth_OpenID_FailureResponse(null, "Missing required field '".$field."'"); } } $signed_list_str = $message->getArg(Auth_OpenID_OPENID_NS, 'signed', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($signed_list_str)) { return $signed_list_str; } $signed_list = explode(',', $signed_list_str); foreach ($require_sigs[$message->getOpenIDNamespace()] as $field) { if ($message->hasKey(Auth_OpenID_OPENID_NS, $field) && (!in_array($field, $signed_list))) { return new Auth_OpenID_FailureResponse(null, "'".$field."' not signed"); } } return null; } function _checkAuth($message, $server_url) { $request = $this->_createCheckAuthRequest($message); if ($request === null) { return false; } $resp_message = $this->_makeKVPost($request, $server_url); if (($resp_message === null) || (is_a($resp_message, 'Auth_OpenID_ServerErrorContainer'))) { return false; } return $this->_processCheckAuthResponse($resp_message, $server_url); } function _createCheckAuthRequest($message) { $signed = $message->getArg(Auth_OpenID_OPENID_NS, 'signed'); if ($signed) { foreach (explode(',', $signed) as $k) { $value = $message->getAliasedArg($k); if ($value === null) { return null; } } } $ca_message = $message->copy(); $ca_message->setArg(Auth_OpenID_OPENID_NS, 'mode', 'check_authentication'); return $ca_message; } function _processCheckAuthResponse($response, $server_url) { $is_valid = $response->getArg(Auth_OpenID_OPENID_NS, 'is_valid', 'false'); $invalidate_handle = $response->getArg(Auth_OpenID_OPENID_NS, 'invalidate_handle'); if ($invalidate_handle !== null) { $this->store->removeAssociation($server_url, $invalidate_handle); } if ($is_valid == 'true') { return true; } return false; } function _httpResponseToMessage($response, $server_url) { $response_message = Auth_OpenID_Message::fromKVForm($response->body); if ($response->status == 400) { return Auth_OpenID_ServerErrorContainer::fromMessage( $response_message); } else if ($response->status != 200 and $response->status != 206) { return null; } return $response_message; } function _makeKVPost($message, $server_url) { $body = $message->toURLEncoded(); $resp = $this->fetcher->post($server_url, $body); if ($resp === null) { return null; } return $this->_httpResponseToMessage($resp, $server_url); } function _getAssociation($endpoint) { if (!$this->_use_assocs) { return null; } $assoc = $this->store->getAssociation($endpoint->server_url); if (($assoc === null) || ($assoc->getExpiresIn() <= 0)) { $assoc = $this->_negotiateAssociation($endpoint); if ($assoc !== null) { $this->store->storeAssociation($endpoint->server_url, $assoc); } } return $assoc; } function _extractSupportedAssociationType(&$server_error, &$endpoint, $assoc_type) { if (($server_error->error_code != 'unsupported-type') || ($server_error->message->isOpenID1())) { return null; } $assoc_type = $server_error->message->getArg(Auth_OpenID_OPENID_NS, 'assoc_type'); $session_type = $server_error->message->getArg(Auth_OpenID_OPENID_NS, 'session_type'); if (($assoc_type === null) || ($session_type === null)) { return null; } else if (!$this->negotiator->isAllowed($assoc_type, $session_type)) { return null; } else { return array($assoc_type, $session_type); } } function _negotiateAssociation($endpoint) { list($assoc_type, $session_type) = $this->negotiator->getAllowedType(); $assoc = $this->_requestAssociation( $endpoint, $assoc_type, $session_type); if (Auth_OpenID::isFailure($assoc)) { return null; } if (is_a($assoc, 'Auth_OpenID_ServerErrorContainer')) { $why = $assoc; $supportedTypes = $this->_extractSupportedAssociationType( $why, $endpoint, $assoc_type); if ($supportedTypes !== null) { list($assoc_type, $session_type) = $supportedTypes; $assoc = $this->_requestAssociation( $endpoint, $assoc_type, $session_type); if (is_a($assoc, 'Auth_OpenID_ServerErrorContainer')) { return null; } else { return $assoc; } } else { return null; } } else { return $assoc; } } function _requestAssociation($endpoint, $assoc_type, $session_type) { list($assoc_session, $args) = $this->_createAssociateRequest( $endpoint, $assoc_type, $session_type); $response_message = $this->_makeKVPost($args, $endpoint->server_url); if ($response_message === null) { return null; } else if (is_a($response_message, 'Auth_OpenID_ServerErrorContainer')) { return $response_message; } return $this->_extractAssociation($response_message, $assoc_session); } function _extractAssociation(&$assoc_response, &$assoc_session) { $assoc_type = $assoc_response->getArg( Auth_OpenID_OPENID_NS, 'assoc_type', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($assoc_type)) { return $assoc_type; } $assoc_handle = $assoc_response->getArg( Auth_OpenID_OPENID_NS, 'assoc_handle', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($assoc_handle)) { return $assoc_handle; } $expires_in_str = $assoc_response->getArg( Auth_OpenID_OPENID_NS, 'expires_in', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($expires_in_str)) { return $expires_in_str; } $expires_in = Auth_OpenID::intval($expires_in_str); if ($expires_in === false) { $err = sprintf("Could not parse expires_in from association ". "response %s", print_r($assoc_response, true)); return new Auth_OpenID_FailureResponse(null, $err); } if ($assoc_response->isOpenID1()) { $session_type = $this->_getOpenID1SessionType($assoc_response); } else { $session_type = $assoc_response->getArg( Auth_OpenID_OPENID2_NS, 'session_type', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($session_type)) { return $session_type; } } if ($assoc_session->session_type != $session_type) { if ($assoc_response->isOpenID1() && ($session_type == 'no-encryption')) { $assoc_session = new Auth_OpenID_PlainTextConsumerSession(); } else { return null; } } if (!in_array($assoc_type, $assoc_session->allowed_assoc_types)) { return null; } $secret = $assoc_session->extractSecret($assoc_response); if ($secret === null) { return null; } return Auth_OpenID_Association::fromExpiresIn( $expires_in, $assoc_handle, $secret, $assoc_type); } function _createAssociateRequest($endpoint, $assoc_type, $session_type) { if (array_key_exists($session_type, $this->session_types)) { $session_type_class = $this->session_types[$session_type]; if (is_callable($session_type_class)) { $assoc_session = $session_type_class(); } else { $assoc_session = new $session_type_class(); } } else { return null; } $args = array( 'mode' => 'associate', 'assoc_type' => $assoc_type); if (!$endpoint->compatibilityMode()) { $args['ns'] = Auth_OpenID_OPENID2_NS; } if ((!$endpoint->compatibilityMode()) || ($assoc_session->session_type != 'no-encryption')) { $args['session_type'] = $assoc_session->session_type; } $args = array_merge($args, $assoc_session->getRequest()); $message = Auth_OpenID_Message::fromOpenIDArgs($args); return array($assoc_session, $message); } function _getOpenID1SessionType($assoc_response) { $session_type = $assoc_response->getArg(Auth_OpenID_OPENID1_NS, 'session_type'); if ($session_type == 'no-encryption') { } else if (($session_type == '') || ($session_type === null)) { $session_type = 'no-encryption'; } return $session_type; } } class Auth_OpenID_AuthRequest { function Auth_OpenID_AuthRequest(&$endpoint, $assoc) { $this->assoc = $assoc; $this->endpoint =& $endpoint; $this->return_to_args = array(); $this->message = new Auth_OpenID_Message( $endpoint->preferredNamespace()); $this->_anonymous = false; } function addExtension(&$extension_request) { $extension_request->toMessage($this->message); } function addExtensionArg($namespace, $key, $value) { return $this->message->setArg($namespace, $key, $value); } function setAnonymous($is_anonymous) { if ($is_anonymous && $this->message->isOpenID1()) { return false; } else { $this->_anonymous = $is_anonymous; return true; } } function getMessage($realm, $return_to=null, $immediate=false) { if ($return_to) { $return_to = Auth_OpenID::appendArgs($return_to, $this->return_to_args); } else if ($immediate) { return new Auth_OpenID_FailureResponse(null, "'return_to' is mandatory when using checkid_immediate"); } else if ($this->message->isOpenID1()) { return new Auth_OpenID_FailureResponse(null, "'return_to' is mandatory for OpenID 1 requests"); } else if ($this->return_to_args) { return new Auth_OpenID_FailureResponse(null, "extra 'return_to' arguments where specified, " . "but no return_to was specified"); } if ($immediate) { $mode = 'checkid_immediate'; } else { $mode = 'checkid_setup'; } $message = $this->message->copy(); if ($message->isOpenID1()) { $realm_key = 'trust_root'; } else { $realm_key = 'realm'; } $message->updateArgs(Auth_OpenID_OPENID_NS, array( $realm_key => $realm, 'mode' => $mode, 'return_to' => $return_to)); if (!$this->_anonymous) { if ($this->endpoint->isOPIdentifier()) { $claimed_id = $request_identity = Auth_OpenID_IDENTIFIER_SELECT; } else { $request_identity = $this->endpoint->getLocalID(); $claimed_id = $this->endpoint->claimed_id; } $message->setArg(Auth_OpenID_OPENID_NS, 'identity', $request_identity); if ($message->isOpenID2()) { $message->setArg(Auth_OpenID_OPENID2_NS, 'claimed_id', $claimed_id); } } if ($this->assoc) { $message->setArg(Auth_OpenID_OPENID_NS, 'assoc_handle', $this->assoc->handle); } return $message; } function redirectURL($realm, $return_to = null, $immediate = false) { $message = $this->getMessage($realm, $return_to, $immediate); if (Auth_OpenID::isFailure($message)) { return $message; } return $message->toURL($this->endpoint->server_url); } function formMarkup($realm, $return_to=null, $immediate=false, $form_tag_attrs=null) { $message = $this->getMessage($realm, $return_to, $immediate); if (Auth_OpenID::isFailure($message)) { return $message; } return $message->toFormMarkup($this->endpoint->server_url, $form_tag_attrs); } function htmlMarkup($realm, $return_to=null, $immediate=false, $form_tag_attrs=null) { $form = $this->formMarkup($realm, $return_to, $immediate, $form_tag_attrs); if (Auth_OpenID::isFailure($form)) { return $form; } return Auth_OpenID::autoSubmitHTML($form); } function shouldSendRedirect() { return $this->endpoint->compatibilityMode(); } } class Auth_OpenID_ConsumerResponse { var $status = null; function setEndpoint($endpoint) { $this->endpoint = $endpoint; if ($endpoint === null) { $this->identity_url = null; } else { $this->identity_url = $endpoint->claimed_id; } } function getDisplayIdentifier() { if ($this->endpoint !== null) { return $this->endpoint->getDisplayIdentifier(); } return null; } } class Auth_OpenID_SuccessResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_SUCCESS; function Auth_OpenID_SuccessResponse($endpoint, $message, $signed_args=null) { $this->endpoint = $endpoint; $this->identity_url = $endpoint->claimed_id; $this->signed_args = $signed_args; $this->message = $message; if ($this->signed_args === null) { $this->signed_args = array(); } } function extensionResponse($namespace_uri, $require_signed) { if ($require_signed) { return $this->getSignedNS($namespace_uri); } else { return $this->message->getArgs($namespace_uri); } } function isOpenID1() { return $this->message->isOpenID1(); } function isSigned($ns_uri, $ns_key) { return in_array($this->message->getKey($ns_uri, $ns_key), $this->signed_args); } function getSigned($ns_uri, $ns_key, $default = null) { if ($this->isSigned($ns_uri, $ns_key)) { return $this->message->getArg($ns_uri, $ns_key, $default); } else { return $default; } } function getSignedNS($ns_uri) { $args = array(); $msg_args = $this->message->getArgs($ns_uri); if (Auth_OpenID::isFailure($msg_args)) { return null; } foreach ($msg_args as $key => $value) { if (!$this->isSigned($ns_uri, $key)) { return null; } } return $msg_args; } function getReturnTo() { return $this->getSigned(Auth_OpenID_OPENID_NS, 'return_to'); } } class Auth_OpenID_FailureResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_FAILURE; function Auth_OpenID_FailureResponse($endpoint, $message = null, $contact = null, $reference = null) { $this->setEndpoint($endpoint); $this->message = $message; $this->contact = $contact; $this->reference = $reference; } } class Auth_OpenID_TypeURIMismatch extends Auth_OpenID_FailureResponse { } class Auth_OpenID_ServerErrorContainer { function Auth_OpenID_ServerErrorContainer($error_text, $error_code, $message) { $this->error_text = $error_text; $this->error_code = $error_code; $this->message = $message; } function fromMessage($message) { $error_text = $message->getArg( Auth_OpenID_OPENID_NS, 'error', '<no error message supplied>'); $error_code = $message->getArg(Auth_OpenID_OPENID_NS, 'error_code'); return new Auth_OpenID_ServerErrorContainer($error_text, $error_code, $message); } } class Auth_OpenID_CancelResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_CANCEL; function Auth_OpenID_CancelResponse($endpoint) { $this->setEndpoint($endpoint); } } class Auth_OpenID_SetupNeededResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_SETUP_NEEDED; function Auth_OpenID_SetupNeededResponse($endpoint, $setup_url = null) { $this->setEndpoint($endpoint); $this->setup_url = $setup_url; } }   function Auth_OpenID_getDefaultMod() { return '155172898181473697471232257763715539915724801'. '966915404479707795314057629378541917580651227423'. '698188993727816152646631438561595825688188889951'. '272158842675419950341258706556549803580104870537'. '681476726513255747040765857479291291572334510643'. '245094715007229621094194349783925984760375594985'. '848253359305585439638443'; } function Auth_OpenID_getDefaultGen() { return '2'; } class Auth_OpenID_DiffieHellman { var $mod; var $gen; var $private; var $lib = null; function Auth_OpenID_DiffieHellman($mod = null, $gen = null, $private = null, $lib = null) { if ($lib === null) { $this->lib =& Auth_OpenID_getMathLib(); } else { $this->lib =& $lib; } if ($mod === null) { $this->mod = $this->lib->init(Auth_OpenID_getDefaultMod()); } else { $this->mod = $mod; } if ($gen === null) { $this->gen = $this->lib->init(Auth_OpenID_getDefaultGen()); } else { $this->gen = $gen; } if ($private === null) { $r = $this->lib->rand($this->mod); $this->private = $this->lib->add($r, 1); } else { $this->private = $private; } $this->public = $this->lib->powmod($this->gen, $this->private, $this->mod); } function getSharedSecret($composite) { return $this->lib->powmod($composite, $this->private, $this->mod); } function getPublicKey() { return $this->public; } function usingDefaultValues() { return ($this->mod == Auth_OpenID_getDefaultMod() && $this->gen == Auth_OpenID_getDefaultGen()); } function xorSecret($composite, $secret, $hash_func) { $dh_shared = $this->getSharedSecret($composite); $dh_shared_str = $this->lib->longToBinary($dh_shared); $hash_dh_shared = $hash_func($dh_shared_str); $xsecret = ""; for ($i = 0; $i < Auth_OpenID::bytes($secret); $i++) { $xsecret .= chr(ord($secret[$i]) ^ ord($hash_dh_shared[$i])); } return $xsecret; } }   define('Auth_OpenID_VERSION', '2.1.2'); define('Auth_OpenID_LOCAL_ERROR', 'local_error'); define('Auth_OpenID_REMOTE_ERROR', 'remote_error'); define('Auth_OpenID_REMOTE_OK', 'remote_ok'); define('Auth_OpenID_REDIRECT', 'redirect'); define('Auth_OpenID_DO_AUTH', 'do_auth'); define('Auth_OpenID_DO_ABOUT', 'do_about'); define('Auth_OpenID_letters', "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"); define('Auth_OpenID_digits', "0123456789"); define('Auth_OpenID_punct', "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"); if (Auth_OpenID_getMathLib() === null) { Auth_OpenID_setNoMathSupport(); } class Auth_OpenID { static function isFailure($thing) { return is_a($thing, 'Auth_OpenID_FailureResponse'); } static function getQuery($query_str=null) { $data = array(); if ($query_str !== null) { $data = Auth_OpenID::params_from_string($query_str); } else if (!array_key_exists('REQUEST_METHOD', $_SERVER)) { } else { $data = Auth_OpenID::params_from_string($_SERVER['QUERY_STRING']); if ($_SERVER['REQUEST_METHOD'] == 'POST') { $str = file_get_contents('php://input'); if ($str === false) { $post = array(); } else { $post = Auth_OpenID::params_from_string($str); } $data = array_merge($data, $post); } } return $data; } static function params_from_string($str) { $chunks = explode("&", $str); $data = array(); foreach ($chunks as $chunk) { $parts = explode("=", $chunk, 2); if (count($parts) != 2) { continue; } list($k, $v) = $parts; $data[$k] = urldecode($v); } return $data; } static function ensureDir($dir_name) { if (is_dir($dir_name) || @mkdir($dir_name)) { return true; } else { $parent_dir = dirname($dir_name); if ($parent_dir == $dir_name) { return true; } return (Auth_OpenID::ensureDir($parent_dir) && @mkdir($dir_name)); } } static function addPrefix($values, $prefix) { $new_values = array(); foreach ($values as $s) { $new_values[] = $prefix . $s; } return $new_values; } static function arrayGet($arr, $key, $fallback = null) { if (is_array($arr)) { if (array_key_exists($key, $arr)) { return $arr[$key]; } else { return $fallback; } } else { trigger_error("Auth_OpenID::arrayGet (key = ".$key.") expected " . "array as first parameter, got " . gettype($arr), E_USER_WARNING); return false; } } static function parse_str($query) { if ($query === null) { return null; } $parts = explode('&', $query); $new_parts = array(); for ($i = 0; $i < count($parts); $i++) { $pair = explode('=', $parts[$i]); if (count($pair) != 2) { continue; } list($key, $value) = $pair; $new_parts[$key] = urldecode($value); } return $new_parts; } function httpBuildQuery($data) { $pairs = array(); foreach ($data as $key => $value) { if (is_array($value)) { $pairs[] = urlencode($value[0])."=".urlencode($value[1]); } else { $pairs[] = urlencode($key)."=".urlencode($value); } } return implode("&", $pairs); } function appendArgs($url, $args) { if (count($args) == 0) { return $url; } if (array_key_exists(0, $args) && is_array($args[0])) { } else { $keys = array_keys($args); sort($keys); $new_args = array(); foreach ($keys as $key) { $new_args[] = array($key, $args[$key]); } $args = $new_args; } $sep = '?'; if (strpos($url, '?') !== false) { $sep = '&'; } return $url . $sep . Auth_OpenID::httpBuildQuery($args); } function urlunparse($scheme, $host, $port = null, $path = '/', $query = '', $fragment = '') { if (!$scheme) { $scheme = 'http'; } if (!$host) { return false; } if (!$path) { $path = ''; } $result = $scheme . "://" . $host; if ($port) { $result .= ":" . $port; } $result .= $path; if ($query) { $result .= "?" . $query; } if ($fragment) { $result .= "#" . $fragment; } return $result; } static function normalizeUrl($url) { @$parsed = parse_url($url); if (!$parsed) { return null; } if (isset($parsed['scheme']) && isset($parsed['host'])) { $scheme = strtolower($parsed['scheme']); if (!in_array($scheme, array('http', 'https'))) { return null; } } else { $url = 'http://' . $url; } $normalized = Auth_OpenID_urinorm($url); if ($normalized === null) { return null; } list($defragged, $frag) = Auth_OpenID::urldefrag($normalized); return $defragged; } function intval($value) { $re = "/^\\d+$/"; if (!preg_match($re, $value)) { return false; } return intval($value); } static function bytes($str) { return strlen(bin2hex($str)) / 2; } static function toBytes($str) { $hex = bin2hex($str); if (!$hex) { return array(); } $b = array(); for ($i = 0; $i < strlen($hex); $i += 2) { $b[] = chr(base_convert(substr($hex, $i, 2), 16, 10)); } return $b; } static function urldefrag($url) { $parts = explode("#", $url, 2); if (count($parts) == 1) { return array($parts[0], ""); } else { return $parts; } } function filter($callback, &$sequence) { $result = array(); foreach ($sequence as $item) { if (call_user_func_array($callback, array($item))) { $result[] = $item; } } return $result; } function update(&$dest, &$src) { foreach ($src as $k => $v) { $dest[$k] = $v; } } static function log($format_string) { $args = func_get_args(); $message = call_user_func_array('sprintf', $args); error_log($message); } function autoSubmitHTML($form, $title="OpenId transaction in progress") { return("<html>". "<head><title>". $title . "</title></head>". "<body onload='document.forms[0].submit();'>". $form . "<script>". "var elements = document.forms[0].elements;". "for (var i = 0; i < elements.length; i++) {". "  elements[i].style.display = \"none\";". "}". "</script>". "</body>". "</html>"); } }   define('Auth_OpenID_PAPE_NS_URI', "http://specs.openid.net/extensions/pape/1.0"); define('PAPE_AUTH_MULTI_FACTOR_PHYSICAL', 'http://schemas.openid.net/pape/policies/2007/06/multi-factor-physical'); define('PAPE_AUTH_MULTI_FACTOR', 'http://schemas.openid.net/pape/policies/2007/06/multi-factor'); define('PAPE_AUTH_PHISHING_RESISTANT', 'http://schemas.openid.net/pape/policies/2007/06/phishing-resistant'); define('PAPE_TIME_VALIDATOR', '^[0-9]{4,4}-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]Z$'); class Auth_OpenID_PAPE_Request extends Auth_OpenID_Extension { var $ns_alias = 'pape'; var $ns_uri = Auth_OpenID_PAPE_NS_URI; function Auth_OpenID_PAPE_Request($preferred_auth_policies=null, $max_auth_age=null) { if ($preferred_auth_policies === null) { $preferred_auth_policies = array(); } $this->preferred_auth_policies = $preferred_auth_policies; $this->max_auth_age = $max_auth_age; } function addPolicyURI($policy_uri) { if (!in_array($policy_uri, $this->preferred_auth_policies)) { $this->preferred_auth_policies[] = $policy_uri; } } function getExtensionArgs() { $ns_args = array( 'preferred_auth_policies' => implode(' ', $this->preferred_auth_policies) ); if ($this->max_auth_age !== null) { $ns_args['max_auth_age'] = strval($this->max_auth_age); } return $ns_args; } function fromOpenIDRequest($request) { $obj = new Auth_OpenID_PAPE_Request(); $args = $request->message->getArgs(Auth_OpenID_PAPE_NS_URI); if ($args === null || $args === array()) { return null; } $obj->parseExtensionArgs($args); return $obj; } function parseExtensionArgs($args) { $this->preferred_auth_policies = array(); $policies_str = Auth_OpenID::arrayGet($args, 'preferred_auth_policies'); if ($policies_str) { foreach (explode(' ', $policies_str) as $uri) { if (!in_array($uri, $this->preferred_auth_policies)) { $this->preferred_auth_policies[] = $uri; } } } $max_auth_age_str = Auth_OpenID::arrayGet($args, 'max_auth_age'); if ($max_auth_age_str) { $this->max_auth_age = Auth_OpenID::intval($max_auth_age_str); } else { $this->max_auth_age = null; } } function preferredTypes($supported_types) { $result = array(); foreach ($supported_types as $st) { if (in_array($st, $this->preferred_auth_policies)) { $result[] = $st; } } return $result; } } class Auth_OpenID_PAPE_Response extends Auth_OpenID_Extension { var $ns_alias = 'pape'; var $ns_uri = Auth_OpenID_PAPE_NS_URI; function Auth_OpenID_PAPE_Response($auth_policies=null, $auth_time=null, $nist_auth_level=null) { if ($auth_policies) { $this->auth_policies = $auth_policies; } else { $this->auth_policies = array(); } $this->auth_time = $auth_time; $this->nist_auth_level = $nist_auth_level; } function addPolicyURI($policy_uri) { if (!in_array($policy_uri, $this->auth_policies)) { $this->auth_policies[] = $policy_uri; } } static function fromSuccessResponse($success_response) { $obj = new Auth_OpenID_PAPE_Response(); $args = $success_response->getSignedNS(Auth_OpenID_PAPE_NS_URI); if ($args === null || $args === array()) { return null; } $result = $obj->parseExtensionArgs($args); if ($result === false) { return null; } else { return $obj; } } function parseExtensionArgs($args, $strict=false) { $policies_str = Auth_OpenID::arrayGet($args, 'auth_policies'); if ($policies_str && $policies_str != "none") { $this->auth_policies = explode(" ", $policies_str); } $nist_level_str = Auth_OpenID::arrayGet($args, 'nist_auth_level'); if ($nist_level_str !== null) { $nist_level = Auth_OpenID::intval($nist_level_str); if ($nist_level === false) { if ($strict) { return false; } else { $nist_level = null; } } if (0 <= $nist_level && $nist_level < 5) { $this->nist_auth_level = $nist_level; } else if ($strict) { return false; } } $auth_time = Auth_OpenID::arrayGet($args, 'auth_time'); if ($auth_time !== null) { if (ereg(PAPE_TIME_VALIDATOR, $auth_time)) { $this->auth_time = $auth_time; } else if ($strict) { return false; } } } function getExtensionArgs() { $ns_args = array(); if (count($this->auth_policies) > 0) { $ns_args['auth_policies'] = implode(' ', $this->auth_policies); } else { $ns_args['auth_policies'] = 'none'; } if ($this->nist_auth_level !== null) { if (!in_array($this->nist_auth_level, range(0, 4), true)) { return false; } $ns_args['nist_auth_level'] = strval($this->nist_auth_level); } if ($this->auth_time !== null) { if (!ereg(PAPE_TIME_VALIDATOR, $this->auth_time)) { return false; } $ns_args['auth_time'] = $this->auth_time; } return $ns_args; } }   class Auth_Yadis_ProxyResolver { function Auth_Yadis_ProxyResolver(&$fetcher, $proxy_url = null) { $this->fetcher =& $fetcher; $this->proxy_url = $proxy_url; if (!$this->proxy_url) { $this->proxy_url = Auth_Yadis_getDefaultProxy(); } } function queryURL($xri, $service_type = null) { $qxri = substr(Auth_Yadis_toURINormal($xri), 6); $hxri = $this->proxy_url . $qxri; $args = array( '_xrd_r' => 'application/xrds+xml' ); if ($service_type) { $args['_xrd_t'] = $service_type; } else { $args['_xrd_r'] .= ';sep=false'; } $query = Auth_Yadis_XRIAppendArgs($hxri, $args); return $query; } function query($xri, $service_types, $filters = array()) { $services = array(); $canonicalID = null; foreach ($service_types as $service_type) { $url = $this->queryURL($xri, $service_type); $response = $this->fetcher->get($url); if ($response->status != 200 and $response->status != 206) { continue; } $xrds = Auth_Yadis_XRDS::parseXRDS($response->body); if (!$xrds) { continue; } $canonicalID = Auth_Yadis_getCanonicalID($xri, $xrds); if ($canonicalID === false) { return null; } $some_services = $xrds->services($filters); $services = array_merge($services, $some_services); } return array($canonicalID, $services); } }   define('Auth_Yadis_CONTENT_TYPE', 'application/xrds+xml'); define('Auth_Yadis_HEADER_NAME', 'X-XRDS-Location'); class Auth_Yadis_DiscoveryResult { var $request_uri = null; var $normalized_uri = null; var $xrds_uri = null; var $xrds = null; var $content_type = null; var $response_text = null; var $failed = false; function Auth_Yadis_DiscoveryResult($request_uri) { $this->request_uri = $request_uri; } function fail() { $this->failed = true; } function isFailure() { return $this->failed; } function services() { if ($this->xrds) { return $this->xrds->services(); } return null; } function usedYadisLocation() { return $this->normalized_uri != $this->xrds_uri; } function isXRDS() { return ($this->usedYadisLocation() || $this->content_type == Auth_Yadis_CONTENT_TYPE); } } function Auth_Yadis_getServiceEndpoints($input_url, $xrds_parse_func, $discover_func=null, $fetcher=null) { if ($discover_func === null) { $discover_function = array('Auth_Yadis_Yadis', 'discover'); } $yadis_result = call_user_func_array($discover_func, array($input_url, $fetcher)); if ($yadis_result === null) { return array($input_url, array()); } $endpoints = call_user_func_array($xrds_parse_func, array($yadis_result->normalized_uri, $yadis_result->response_text)); if ($endpoints === null) { $endpoints = array(); } return array($yadis_result->normalized_uri, $endpoints); } class Auth_Yadis_Yadis { static function getHTTPFetcher($timeout = 20) { if (Auth_Yadis_Yadis::curlPresent() && (!defined('Auth_Yadis_CURL_OVERRIDE'))) { $fetcher = new Auth_Yadis_ParanoidHTTPFetcher($timeout); } else { $fetcher = new Auth_Yadis_PlainHTTPFetcher($timeout); } return $fetcher; } static function curlPresent() { return function_exists('curl_init'); } static function _getHeader($header_list, $names) { foreach ($header_list as $name => $value) { foreach ($names as $n) { if (strtolower($name) == strtolower($n)) { return $value; } } } return null; } static function _getContentType($content_type_header) { if ($content_type_header) { $parts = explode(";", $content_type_header); return strtolower($parts[0]); } } static function discover($uri, $fetcher, $extra_ns_map = null, $timeout = 20) { $result = new Auth_Yadis_DiscoveryResult($uri); $request_uri = $uri; $headers = array("Accept: " . Auth_Yadis_CONTENT_TYPE . ', text/html; q=0.3, application/xhtml+xml; q=0.5'); if ($fetcher === null) { $fetcher = Auth_Yadis_Yadis::getHTTPFetcher($timeout); } $response = $fetcher->get($uri, $headers); if (!$response || ($response->status != 200 and $response->status != 206)) { $result->fail(); return $result; } $result->normalized_uri = $response->final_url; $result->content_type = Auth_Yadis_Yadis::_getHeader( $response->headers, array('content-type')); if ($result->content_type && (Auth_Yadis_Yadis::_getContentType($result->content_type) == Auth_Yadis_CONTENT_TYPE)) { $result->xrds_uri = $result->normalized_uri; } else { $yadis_location = Auth_Yadis_Yadis::_getHeader( $response->headers, array(Auth_Yadis_HEADER_NAME)); if (!$yadis_location) { $parser = new Auth_Yadis_ParseHTML(); $yadis_location = $parser->getHTTPEquiv($response->body); } if ($yadis_location) { $result->xrds_uri = $yadis_location; $response = $fetcher->get($yadis_location); if ((!$response) || ($response->status != 200 and $response->status != 206)) { $result->fail(); return $result; } $result->content_type = Auth_Yadis_Yadis::_getHeader( $response->headers, array('content-type')); } } $result->response_text = $response->body; return $result; } }   class Auth_OpenID_Association { var $SIG_LENGTH = 20; var $assoc_keys = array( 'version', 'handle', 'secret', 'issued', 'lifetime', 'assoc_type' ); var $_macs = array( 'HMAC-SHA1' => 'Auth_OpenID_HMACSHA1', 'HMAC-SHA256' => 'Auth_OpenID_HMACSHA256' ); function fromExpiresIn($expires_in, $handle, $secret, $assoc_type) { $issued = time(); $lifetime = $expires_in; return new Auth_OpenID_Association($handle, $secret, $issued, $lifetime, $assoc_type); } function Auth_OpenID_Association( $handle, $secret, $issued, $lifetime, $assoc_type) { if (!in_array($assoc_type, Auth_OpenID_getSupportedAssociationTypes())) { $fmt = 'Unsupported association type (%s)'; trigger_error(sprintf($fmt, $assoc_type), E_USER_ERROR); } $this->handle = $handle; $this->secret = $secret; $this->issued = $issued; $this->lifetime = $lifetime; $this->assoc_type = $assoc_type; } function getExpiresIn($now = null) { if ($now == null) { $now = time(); } return max(0, $this->issued + $this->lifetime - $now); } function equal($other) { return ((gettype($this) == gettype($other)) && ($this->handle == $other->handle) && ($this->secret == $other->secret) && ($this->issued == $other->issued) && ($this->lifetime == $other->lifetime) && ($this->assoc_type == $other->assoc_type)); } function serialize() { $data = array( 'version' => '2', 'handle' => $this->handle, 'secret' => base64_encode($this->secret), 'issued' => strval(intval($this->issued)), 'lifetime' => strval(intval($this->lifetime)), 'assoc_type' => $this->assoc_type ); assert(array_keys($data) == $this->assoc_keys); return Auth_OpenID_KVForm::fromArray($data, $strict = true); } static function deserialize($class_name, $assoc_s) { $pairs = Auth_OpenID_KVForm::toArray($assoc_s, $strict = true); $keys = array(); $values = array(); foreach ($pairs as $key => $value) { if (is_array($value)) { list($key, $value) = $value; } $keys[] = $key; $values[] = $value; } $class_vars = get_class_vars($class_name); $class_assoc_keys = $class_vars['assoc_keys']; sort($keys); sort($class_assoc_keys); if ($keys != $class_assoc_keys) { trigger_error('Unexpected key values: ' . var_export($keys, true), E_USER_WARNING); return null; } $version = $pairs['version']; $handle = $pairs['handle']; $secret = $pairs['secret']; $issued = $pairs['issued']; $lifetime = $pairs['lifetime']; $assoc_type = $pairs['assoc_type']; if ($version != '2') { trigger_error('Unknown version: ' . $version, E_USER_WARNING); return null; } $issued = intval($issued); $lifetime = intval($lifetime); $secret = base64_decode($secret); return new $class_name( $handle, $secret, $issued, $lifetime, $assoc_type); } function sign($pairs) { $kv = Auth_OpenID_KVForm::fromArray($pairs); $callback = $this->_macs[$this->assoc_type]; return call_user_func_array($callback, array($this->secret, $kv)); } function signMessage($message) { if ($message->hasKey(Auth_OpenID_OPENID_NS, 'sig') || $message->hasKey(Auth_OpenID_OPENID_NS, 'signed')) { return null; } $extant_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_handle'); if ($extant_handle && ($extant_handle != $this->handle)) { return null; } $signed_message = $message; $signed_message->setArg(Auth_OpenID_OPENID_NS, 'assoc_handle', $this->handle); $message_keys = array_keys($signed_message->toPostArgs()); $signed_list = array(); $signed_prefix = 'openid.'; foreach ($message_keys as $k) { if (strpos($k, $signed_prefix) === 0) { $signed_list[] = substr($k, strlen($signed_prefix)); } } $signed_list[] = 'signed'; sort($signed_list); $signed_message->setArg(Auth_OpenID_OPENID_NS, 'signed', implode(',', $signed_list)); $sig = $this->getMessageSignature($signed_message); $signed_message->setArg(Auth_OpenID_OPENID_NS, 'sig', $sig); return $signed_message; } function _makePairs(&$message) { $signed = $message->getArg(Auth_OpenID_OPENID_NS, 'signed'); if (!$signed || Auth_OpenID::isFailure($signed)) { return null; } $signed_list = explode(',', $signed); $pairs = array(); $data = $message->toPostArgs(); foreach ($signed_list as $field) { $pairs[] = array($field, Auth_OpenID::arrayGet($data, 'openid.' . $field, '')); } return $pairs; } function getMessageSignature(&$message) { $pairs = $this->_makePairs($message); return base64_encode($this->sign($pairs)); } function checkMessageSignature(&$message) { $sig = $message->getArg(Auth_OpenID_OPENID_NS, 'sig'); if (!$sig || Auth_OpenID::isFailure($sig)) { return false; } $calculated_sig = $this->getMessageSignature($message); return $calculated_sig == $sig; } } function Auth_OpenID_getSecretSize($assoc_type) { if ($assoc_type == 'HMAC-SHA1') { return 20; } else if ($assoc_type == 'HMAC-SHA256') { return 32; } else { return null; } } function Auth_OpenID_getAllAssociationTypes() { return array('HMAC-SHA1', 'HMAC-SHA256'); } function Auth_OpenID_getSupportedAssociationTypes() { $a = array('HMAC-SHA1'); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $a[] = 'HMAC-SHA256'; } return $a; } function Auth_OpenID_getSessionTypes($assoc_type) { $assoc_to_session = array( 'HMAC-SHA1' => array('DH-SHA1', 'no-encryption')); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $assoc_to_session['HMAC-SHA256'] = array('DH-SHA256', 'no-encryption'); } return Auth_OpenID::arrayGet($assoc_to_session, $assoc_type, array()); } function Auth_OpenID_checkSessionType($assoc_type, $session_type) { if (!in_array($session_type, Auth_OpenID_getSessionTypes($assoc_type))) { return false; } return true; } function Auth_OpenID_getDefaultAssociationOrder() { $order = array(); if (!Auth_OpenID_noMathSupport()) { $order[] = array('HMAC-SHA1', 'DH-SHA1'); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $order[] = array('HMAC-SHA256', 'DH-SHA256'); } } $order[] = array('HMAC-SHA1', 'no-encryption'); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $order[] = array('HMAC-SHA256', 'no-encryption'); } return $order; } function Auth_OpenID_getOnlyEncryptedOrder() { $result = array(); foreach (Auth_OpenID_getDefaultAssociationOrder() as $pair) { list($assoc, $session) = $pair; if ($session != 'no-encryption') { if (Auth_OpenID_HMACSHA256_SUPPORTED && ($assoc == 'HMAC-SHA256')) { $result[] = $pair; } else if ($assoc != 'HMAC-SHA256') { $result[] = $pair; } } } return $result; } function &Auth_OpenID_getDefaultNegotiator() { $x = new Auth_OpenID_SessionNegotiator( Auth_OpenID_getDefaultAssociationOrder()); return $x; } function &Auth_OpenID_getEncryptedNegotiator() { $x = new Auth_OpenID_SessionNegotiator( Auth_OpenID_getOnlyEncryptedOrder()); return $x; } class Auth_OpenID_SessionNegotiator { function Auth_OpenID_SessionNegotiator($allowed_types) { $this->allowed_types = array(); $this->setAllowedTypes($allowed_types); } function setAllowedTypes($allowed_types) { foreach ($allowed_types as $pair) { list($assoc_type, $session_type) = $pair; if (!Auth_OpenID_checkSessionType($assoc_type, $session_type)) { return false; } } $this->allowed_types = $allowed_types; return true; } function addAllowedType($assoc_type, $session_type = null) { if ($this->allowed_types === null) { $this->allowed_types = array(); } if ($session_type === null) { $available = Auth_OpenID_getSessionTypes($assoc_type); if (!$available) { return false; } foreach ($available as $session_type) { $this->addAllowedType($assoc_type, $session_type); } } else { if (Auth_OpenID_checkSessionType($assoc_type, $session_type)) { $this->allowed_types[] = array($assoc_type, $session_type); } else { return false; } } return true; } function isAllowed($assoc_type, $session_type) { $assoc_good = in_array(array($assoc_type, $session_type), $this->allowed_types); $matches = in_array($session_type, Auth_OpenID_getSessionTypes($assoc_type)); return ($assoc_good && $matches); } function getAllowedType() { if (!$this->allowed_types) { return array(null, null); } return $this->allowed_types[0]; } }   class Auth_OpenID_MathLibrary { function longToBinary($long) { $cmp = $this->cmp($long, 0); if ($cmp < 0) { $msg = __FUNCTION__ . " takes only positive integers."; trigger_error($msg, E_USER_ERROR); return null; } if ($cmp == 0) { return "\x00"; } $bytes = array(); while ($this->cmp($long, 0) > 0) { array_unshift($bytes, $this->mod($long, 256)); $long = $this->div($long, pow(2, 8)); } if ($bytes && ($bytes[0] > 127)) { array_unshift($bytes, 0); } $string = ''; foreach ($bytes as $byte) { $string .= pack('C', $byte); } return $string; } function binaryToLong($str) { if ($str === null) { return null; } $bytes = array_merge(unpack('C*', $str)); $n = $this->init(0); if ($bytes && ($bytes[0] > 127)) { trigger_error("bytesToNum works only for positive integers.", E_USER_WARNING); return null; } foreach ($bytes as $byte) { $n = $this->mul($n, pow(2, 8)); $n = $this->add($n, $byte); } return $n; } function base64ToLong($str) { $b64 = base64_decode($str); if ($b64 === false) { return false; } return $this->binaryToLong($b64); } function longToBase64($str) { return base64_encode($this->longToBinary($str)); } function rand($stop) { static $duplicate_cache = array(); $rbytes = $this->longToBinary($stop); if (array_key_exists($rbytes, $duplicate_cache)) { list($duplicate, $nbytes) = $duplicate_cache[$rbytes]; } else { if ($rbytes[0] == "\x00") { $nbytes = Auth_OpenID::bytes($rbytes) - 1; } else { $nbytes = Auth_OpenID::bytes($rbytes); } $mxrand = $this->pow(256, $nbytes); $duplicate = $this->mod($mxrand, $stop); if (count($duplicate_cache) > 10) { $duplicate_cache = array(); } $duplicate_cache[$rbytes] = array($duplicate, $nbytes); } do { $bytes = "\x00" . Auth_OpenID_CryptUtil::getBytes($nbytes); $n = $this->binaryToLong($bytes); } while ($this->cmp($n, $duplicate) < 0); return $this->mod($n, $stop); } } class Auth_OpenID_BcMathWrapper extends Auth_OpenID_MathLibrary { var $type = 'bcmath'; function add($x, $y) { return bcadd($x, $y); } function sub($x, $y) { return bcsub($x, $y); } function pow($base, $exponent) { return bcpow($base, $exponent); } function cmp($x, $y) { return bccomp($x, $y); } function init($number, $base = 10) { return $number; } function mod($base, $modulus) { return bcmod($base, $modulus); } function mul($x, $y) { return bcmul($x, $y); } function div($x, $y) { return bcdiv($x, $y); } function _powmod($base, $exponent, $modulus) { $square = $this->mod($base, $modulus); $result = 1; while($this->cmp($exponent, 0) > 0) { if ($this->mod($exponent, 2)) { $result = $this->mod($this->mul($result, $square), $modulus); } $square = $this->mod($this->mul($square, $square), $modulus); $exponent = $this->div($exponent, 2); } return $result; } function powmod($base, $exponent, $modulus) { if (function_exists('bcpowmod')) { return bcpowmod($base, $exponent, $modulus); } else { return $this->_powmod($base, $exponent, $modulus); } } function toString($num) { return $num; } } class Auth_OpenID_GmpMathWrapper extends Auth_OpenID_MathLibrary { var $type = 'gmp'; function add($x, $y) { return gmp_add($x, $y); } function sub($x, $y) { return gmp_sub($x, $y); } function pow($base, $exponent) { return gmp_pow($base, $exponent); } function cmp($x, $y) { return gmp_cmp($x, $y); } function init($number, $base = 10) { return gmp_init($number, $base); } function mod($base, $modulus) { return gmp_mod($base, $modulus); } function mul($x, $y) { return gmp_mul($x, $y); } function div($x, $y) { return gmp_div_q($x, $y); } function powmod($base, $exponent, $modulus) { return gmp_powm($base, $exponent, $modulus); } function toString($num) { return gmp_strval($num); } } function Auth_OpenID_math_extensions() { $result = array(); if (!defined('Auth_OpenID_BUGGY_GMP')) { $result[] = array('modules' => array('gmp', 'php_gmp'), 'extension' => 'gmp', 'class' => 'Auth_OpenID_GmpMathWrapper'); } $result[] = array( 'modules' => array('bcmath', 'php_bcmath'), 'extension' => 'bcmath', 'class' => 'Auth_OpenID_BcMathWrapper'); return $result; } function Auth_OpenID_detectMathLibrary($exts) { $loaded = false; if ( ! function_exists( 'dl' ) ) { return false; } foreach ($exts as $extension) { if ($extension['extension'] && extension_loaded($extension['extension'])) { $loaded = true; } if (!$loaded) { foreach ($extension['modules'] as $module) { if (@dl($module . "." . PHP_SHLIB_SUFFIX)) { $loaded = true; break; } } } if ($loaded) { return $extension; } } return false; } function &Auth_OpenID_getMathLib() { static $lib = null; if (isset($lib)) { return $lib; } if (Auth_OpenID_noMathSupport()) { $null = null; return $null; } $ext = Auth_OpenID_detectMathLibrary(Auth_OpenID_math_extensions()); if ($ext === false) { $tried = array(); foreach (Auth_OpenID_math_extensions() as $extinfo) { $tried[] = $extinfo['extension']; } $triedstr = implode(", ", $tried); Auth_OpenID_setNoMathSupport(); $result = null; return $result; } $class = $ext['class']; $lib = new $class(); return $lib; } function Auth_OpenID_setNoMathSupport() { if (!defined('Auth_OpenID_NO_MATH_SUPPORT')) { define('Auth_OpenID_NO_MATH_SUPPORT', true); } } function Auth_OpenID_noMathSupport() { return defined('Auth_OpenID_NO_MATH_SUPPORT'); }   class Auth_OpenID_Extension { var $ns_uri = null; var $ns_alias = null; function getExtensionArgs() { return null; } function toMessage(&$message) { $implicit = $message->isOpenID1(); $added = $message->namespaces->addAlias($this->ns_uri, $this->ns_alias, $implicit); if ($added === null) { if ($message->namespaces->getAlias($this->ns_uri) != $this->ns_alias) { return null; } } $message->updateArgs($this->ns_uri, $this->getExtensionArgs()); return $message; } }   class Auth_OpenID_MemcachedStore extends Auth_OpenID_OpenIDStore { function Auth_OpenID_MemcachedStore($connection, $compress = false) { $this->connection = $connection; $this->compress = $compress ? MEMCACHE_COMPRESSED : 0; } function storeAssociation($server_url, $association) { $associationKey = $this->associationKey($server_url, $association->handle); $serverKey = $this->associationServerKey($server_url); $serverAssociations = $this->connection->get($serverKey); if (!$serverAssociations) { $serverAssociations = array(); } $serverAssociations[$association->issued] = $associationKey; $this->connection->set( $serverKey, $serverAssociations, $this->compress ); $this->connection->set( $associationKey, $association, $this->compress, $association->issued + $association->lifetime); } function getAssociation($server_url, $handle = null) { if ($handle !== null) { $association = $this->connection->get( $this->associationKey($server_url, $handle)); return $association ? $association : null; } $serverKey = $this->associationServerKey($server_url); $serverAssociations = $this->connection->get($serverKey); if (!$serverAssociations) { return null; } $keys = array_keys($serverAssociations); sort($keys); $lastKey = $serverAssociations[array_pop($keys)]; $association = $this->connection->get($lastKey); return $association ? $association : null; } function removeAssociation($server_url, $handle) { $serverKey = $this->associationServerKey($server_url); $associationKey = $this->associationKey($server_url, $handle); $serverAssociations = $this->connection->get($serverKey); if (!$serverAssociations) { return false; } $serverAssociations = array_flip($serverAssociations); if (!array_key_exists($associationKey, $serverAssociations)) { return false; } unset($serverAssociations[$associationKey]); $serverAssociations = array_flip($serverAssociations); $this->connection->set( $serverKey, $serverAssociations, $this->compress ); return $this->connection->delete($associationKey); } function useNonce($server_url, $timestamp, $salt) { global $Auth_OpenID_SKEW; if (abs($timestamp - time()) > $Auth_OpenID_SKEW) { return false; } return $this->connection->add( 'openid_nonce_' . sha1($server_url) . '_' . sha1($salt), 1, $this->compress, $Auth_OpenID_SKEW); } function associationKey($server_url, $handle = null) { return 'openid_association_' . sha1($server_url) . '_' . sha1($handle); } function associationServerKey($server_url) { return 'openid_association_server_' . sha1($server_url); } function supportsCleanup() { return false; } }   class Auth_Yadis_ParanoidHTTPFetcher extends Auth_Yadis_HTTPFetcher { function Auth_Yadis_ParanoidHTTPFetcher() { $this->reset(); } function reset() { $this->headers = array(); $this->data = ""; } function _writeHeader($ch, $header) { array_push($this->headers, rtrim($header)); return strlen($header); } function _writeData($ch, $data) { if (strlen($this->data) > 1024*Auth_OpenID_FETCHER_MAX_RESPONSE_KB) { return 0; } else { $this->data .= $data; return strlen($data); } } function supportsSSL() { $v = curl_version(); if(is_array($v)) { return in_array('https', $v['protocols']); } elseif (is_string($v)) { return preg_match('/OpenSSL/i', $v); } else { return 0; } } function get($url, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $stop = time() + $this->timeout; $off = $this->timeout; $redir = true; while ($redir && ($off > 0)) { $this->reset(); $c = curl_init(); if ($c === false) { Auth_OpenID::log( "curl_init returned false; could not " . "initialize for URL '%s'", $url); return null; } if (defined('CURLOPT_NOSIGNAL')) { curl_setopt($c, CURLOPT_NOSIGNAL, true); } if (!$this->allowedURL($url)) { Auth_OpenID::log("Fetching URL not allowed: %s", $url); return null; } curl_setopt($c, CURLOPT_WRITEFUNCTION, array(&$this, "_writeData")); curl_setopt($c, CURLOPT_HEADERFUNCTION, array(&$this, "_writeHeader")); if ($extra_headers) { curl_setopt($c, CURLOPT_HTTPHEADER, $extra_headers); } $cv = curl_version(); if(is_array($cv)) { $curl_user_agent = 'curl/'.$cv['version']; } else { $curl_user_agent = $cv; } curl_setopt($c, CURLOPT_USERAGENT, Auth_OpenID_USER_AGENT.' '.$curl_user_agent); curl_setopt($c, CURLOPT_TIMEOUT, $off); curl_setopt($c, CURLOPT_URL, $url); curl_exec($c); $code = curl_getinfo($c, CURLINFO_HTTP_CODE); $body = $this->data; $headers = $this->headers; if (!$code) { Auth_OpenID::log("Got no response code when fetching %s", $url); Auth_OpenID::log("CURL error (%s): %s", curl_errno($c), curl_error($c)); return null; } if (in_array($code, array(301, 302, 303, 307))) { $url = $this->_findRedirect($headers); $redir = true; } else { $redir = false; curl_close($c); $new_headers = array(); foreach ($headers as $header) { if (strpos($header, ': ')) { list($name, $value) = explode(': ', $header, 2); $new_headers[$name] = $value; } } Auth_OpenID::log( "Successfully fetched '%s': GET response code %s", $url, $code); return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $body); } $off = $stop - time(); } return null; } function post($url, $body, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $this->reset(); $c = curl_init(); if (defined('CURLOPT_NOSIGNAL')) { curl_setopt($c, CURLOPT_NOSIGNAL, true); } curl_setopt($c, CURLOPT_POST, true); curl_setopt($c, CURLOPT_POSTFIELDS, $body); curl_setopt($c, CURLOPT_TIMEOUT, $this->timeout); curl_setopt($c, CURLOPT_URL, $url); curl_setopt($c, CURLOPT_WRITEFUNCTION, array(&$this, "_writeData")); curl_exec($c); $code = curl_getinfo($c, CURLINFO_HTTP_CODE); if (!$code) { Auth_OpenID::log("Got no response code when fetching %s", $url); return null; } $body = $this->data; curl_close($c); $new_headers = $extra_headers; foreach ($this->headers as $header) { if (strpos($header, ': ')) { list($name, $value) = explode(': ', $header, 2); $new_headers[$name] = $value; } } Auth_OpenID::log("Successfully fetched '%s': POST response code %s", $url, $code); return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $body); } }   class Auth_Yadis_PlainHTTPFetcher extends Auth_Yadis_HTTPFetcher { function supportsSSL() { return function_exists('openssl_open'); } function get($url, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $redir = true; $stop = time() + $this->timeout; $off = $this->timeout; while ($redir && ($off > 0)) { $parts = parse_url($url); $specify_port = true; if (!array_key_exists('port', $parts)) { $specify_port = false; if ($parts['scheme'] == 'http') { $parts['port'] = 80; } elseif ($parts['scheme'] == 'https') { $parts['port'] = 443; } else { return null; } } if (!array_key_exists('path', $parts)) { $parts['path'] = '/'; } $host = $parts['host']; if ($parts['scheme'] == 'https') { $host = 'ssl://' . $host; } $user_agent = Auth_OpenID_USER_AGENT; $headers = array( "GET ".$parts['path']. (array_key_exists('query', $parts) ? "?".$parts['query'] : ""). " HTTP/1.0", "User-Agent: $user_agent", "Host: ".$parts['host']. ($specify_port ? ":".$parts['port'] : ""), "Port: ".$parts['port']); $errno = 0; $errstr = ''; if ($extra_headers) { foreach ($extra_headers as $h) { $headers[] = $h; } } @$sock = fsockopen($host, $parts['port'], $errno, $errstr, $this->timeout); if ($sock === false) { return false; } stream_set_timeout($sock, $this->timeout); fputs($sock, implode("\r\n", $headers) . "\r\n\r\n"); $data = ""; $kilobytes = 0; while (!feof($sock) && $kilobytes < Auth_OpenID_FETCHER_MAX_RESPONSE_KB ) { $data .= fgets($sock, 1024); $kilobytes += 1; } fclose($sock); list($headers, $body) = explode("\r\n\r\n", $data, 2); $headers = explode("\r\n", $headers); $http_code = explode(" ", $headers[0]); $code = $http_code[1]; if (in_array($code, array('301', '302'))) { $url = $this->_findRedirect($headers); $redir = true; } else { $redir = false; } $off = $stop - time(); } $new_headers = array(); foreach ($headers as $header) { if (preg_match("/:/", $header)) { $parts = explode(": ", $header, 2); if (count($parts) == 2) { list($name, $value) = $parts; $new_headers[$name] = $value; } } } return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $body); } function post($url, $body, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $parts = parse_url($url); $headers = array(); $post_path = $parts['path']; if (isset($parts['query'])) { $post_path .= '?' . $parts['query']; } $headers[] = "POST ".$post_path." HTTP/1.0"; $headers[] = "Host: " . $parts['host']; $headers[] = "Content-type: application/x-www-form-urlencoded"; $headers[] = "Content-length: " . strval(strlen($body)); if ($extra_headers && is_array($extra_headers)) { $headers = array_merge($headers, $extra_headers); } $all_headers = implode("\r\n", $headers); $request = $all_headers . "\r\n\r\n" . $body; if (!array_key_exists('port', $parts)) { if ($parts['scheme'] == 'http') { $parts['port'] = 80; } elseif ($parts['scheme'] == 'https') { $parts['port'] = 443; } else { return null; } } if ($parts['scheme'] == 'https') { $parts['host'] = sprintf("ssl://%s", $parts['host']); } $errno = 0; $errstr = ''; $sock = fsockopen($parts['host'], $parts['port'], $errno, $errstr, $this->timeout); if ($sock === false) { return null; } stream_set_timeout($sock, $this->timeout); fputs($sock, $request); $response = ""; while (!feof($sock)) { if ($data = fgets($sock, 128)) { $response .= $data; } else { break; } } list($headers, $response_body) = explode("\r\n\r\n", $response, 2); $headers = explode("\r\n", $headers); $http_code = explode(" ", $headers[0]); $code = $http_code[1]; $new_headers = array(); foreach ($headers as $header) { if (preg_match("/:/", $header)) { list($name, $value) = explode(": ", $header, 2); $new_headers[$name] = $value; } } return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $response_body); } }   define('Auth_OpenID___TLDs', '/\.(ac|ad|ae|aero|af|ag|ai|al|am|an|ao|aq|ar|arpa|as|asia' . '|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|biz|bj|bm|bn|bo|br' . '|bs|bt|bv|bw|by|bz|ca|cat|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co' . '|com|coop|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|edu|ee|eg' . '|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl' . '|gm|gn|gov|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie' . '|il|im|in|info|int|io|iq|ir|is|it|je|jm|jo|jobs|jp|ke|kg|kh' . '|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly' . '|ma|mc|md|me|mg|mh|mil|mk|ml|mm|mn|mo|mobi|mp|mq|mr|ms|mt' . '|mu|museum|mv|mw|mx|my|mz|na|name|nc|ne|net|nf|ng|ni|nl|no' . '|np|nr|nu|nz|om|org|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pro|ps|pt' . '|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl' . '|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tel|tf|tg|th|tj|tk|tl|tm' . '|tn|to|tp|tr|travel|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve' . '|vg|vi|vn|vu|wf|ws|xn--0zwm56d|xn--11b5bs3a9aj6g' . '|xn--80akhbyknj4f|xn--9t4b11yi5a|xn--deba0ad|xn--g6w251d' . '|xn--hgbk6aj7f53bba|xn--hlcj6aya9esc7a|xn--jxalpdlp' . '|xn--kgbechtv|xn--zckzah|ye|yt|yu|za|zm|zw)\.?$/'); define('Auth_OpenID___HostSegmentRe', "/^(?:[-a-zA-Z0-9!$&'\\(\\)\\*+,;=._~]|%[a-zA-Z0-9]{2})*$/"); class Auth_OpenID_TrustRoot { function buildDiscoveryURL($realm) { $parsed = Auth_OpenID_TrustRoot::_parse($realm); if ($parsed === false) { return false; } if ($parsed['wildcard']) { if ($parsed['host'][0] != '.') { return false; } $www_domain = 'www' . $parsed['host']; return sprintf('%s://%s%s', $parsed['scheme'], $www_domain, $parsed['path']); } else { return $parsed['unparsed']; } } static function _parse($trust_root) { $trust_root = Auth_OpenID_urinorm($trust_root); if ($trust_root === null) { return false; } if (preg_match("/:\/\/[^:]+(:\d+){2,}(\/|$)/", $trust_root)) { return false; } $parts = @parse_url($trust_root); if ($parts === false) { return false; } $required_parts = array('scheme', 'host'); $forbidden_parts = array('user', 'pass', 'fragment'); $keys = array_keys($parts); if (array_intersect($keys, $required_parts) != $required_parts) { return false; } if (array_intersect($keys, $forbidden_parts) != array()) { return false; } if (!preg_match(Auth_OpenID___HostSegmentRe, $parts['host'])) { return false; } $scheme = strtolower($parts['scheme']); $allowed_schemes = array('http', 'https'); if (!in_array($scheme, $allowed_schemes)) { return false; } $parts['scheme'] = $scheme; $host = strtolower($parts['host']); $hostparts = explode('*', $host); switch (count($hostparts)) { case 1: $parts['wildcard'] = false; break; case 2: if ($hostparts[0] || ($hostparts[1] && substr($hostparts[1], 0, 1) != '.')) { return false; } $host = $hostparts[1]; $parts['wildcard'] = true; break; default: return false; } if (strpos($host, ':') !== false) { return false; } $parts['host'] = $host; if (isset($parts['path'])) { $path = strtolower($parts['path']); if (substr($path, 0, 1) != '/') { return false; } } else { $path = '/'; } $parts['path'] = $path; if (!isset($parts['port'])) { $parts['port'] = false; } $parts['unparsed'] = $trust_root; return $parts; } static function isSane($trust_root) { $parts = Auth_OpenID_TrustRoot::_parse($trust_root); if ($parts === false) { return false; } if ($parts['host'] == 'localhost') { return true; } $host_parts = explode('.', $parts['host']); if ($parts['wildcard']) { array_shift($host_parts); } if ($host_parts && !$host_parts[count($host_parts) - 1]) { array_pop($host_parts); } if (!$host_parts) { return false; } if (in_array('', $host_parts, true)) { return false; } preg_match(Auth_OpenID___TLDs, $parts['host'], $matches); if (!$matches) { return false; } $tld = $matches[1]; if (count($host_parts) == 1) { return false; } if ($parts['wildcard']) { $second_level = $host_parts[count($host_parts) - 2]; if (strlen($tld) == 2 && strlen($second_level) <= 3) { return count($host_parts) > 2; } } return true; } function match($trust_root, $url) { $trust_root_parsed = Auth_OpenID_TrustRoot::_parse($trust_root); $url_parsed = Auth_OpenID_TrustRoot::_parse($url); if (!$trust_root_parsed || !$url_parsed) { return false; } if ($url_parsed['wildcard']) { return false; } if ($trust_root_parsed['wildcard']) { $host_tail = $trust_root_parsed['host']; $host = $url_parsed['host']; if ($host_tail && substr($host, -(strlen($host_tail))) != $host_tail && substr($host_tail, 1) != $host) { return false; } } else { if ($trust_root_parsed['host'] != $url_parsed['host']) { return false; } } $base_path = $trust_root_parsed['path']; $path = $url_parsed['path']; if (!isset($trust_root_parsed['query'])) { if ($base_path != $path) { if (substr($path, 0, strlen($base_path)) != $base_path) { return false; } if (substr($base_path, strlen($base_path) - 1, 1) != '/' && substr($path, strlen($base_path), 1) != '/') { return false; } } } else { $base_query = $trust_root_parsed['query']; $query = @$url_parsed['query']; $qplus = substr($query, 0, strlen($base_query) + 1); $bqplus = $base_query . '&'; if ($base_path != $path || ($base_query != $query && $qplus != $bqplus)) { return false; } } return ($trust_root_parsed['scheme'] == $url_parsed['scheme'] && $url_parsed['port'] === $trust_root_parsed['port']); } } function filter_extractReturnURL(&$endpoint) { if ($endpoint->matchTypes(array(Auth_OpenID_RP_RETURN_TO_URL_TYPE))) { return $endpoint; } else { return null; } } function &Auth_OpenID_extractReturnURL(&$endpoint_list) { $result = array(); foreach ($endpoint_list as $endpoint) { if (filter_extractReturnURL($endpoint)) { $result[] = $endpoint; } } return $result; } function Auth_OpenID_returnToMatches($allowed_return_to_urls, $return_to) { foreach ($allowed_return_to_urls as $allowed_return_to) { $return_realm = Auth_OpenID_TrustRoot::_parse($allowed_return_to); if ( ($return_realm !== false) && (!$return_realm['wildcard']) && (Auth_OpenID_TrustRoot::match($allowed_return_to, $return_to))) { return true; } } return false; } function Auth_OpenID_getAllowedReturnURLs($relying_party_url, &$fetcher, $discover_function=null) { if ($discover_function === null) { $discover_function = array('Auth_Yadis_Yadis', 'discover'); } $xrds_parse_cb = array('Auth_OpenID_ServiceEndpoint', 'fromXRDS'); list($rp_url_after_redirects, $endpoints) = Auth_Yadis_getServiceEndpoints($relying_party_url, $xrds_parse_cb, $discover_function, $fetcher); if ($rp_url_after_redirects != $relying_party_url) { return false; } call_user_func_array($discover_function, array($relying_party_url, $fetcher)); $return_to_urls = array(); $matching_endpoints = Auth_OpenID_extractReturnURL($endpoints); foreach ($matching_endpoints as $e) { $return_to_urls[] = $e->server_url; } return $return_to_urls; } function Auth_OpenID_verifyReturnTo($realm_str, $return_to, &$fetcher, $_vrfy='Auth_OpenID_getAllowedReturnURLs') { $disco_url = Auth_OpenID_TrustRoot::buildDiscoveryURL($realm_str); if ($disco_url === false) { return false; } $allowable_urls = call_user_func_array($_vrfy, array($disco_url, &$fetcher)); if ($allowable_urls === false) { return false; } if (Auth_OpenID_returnToMatches($allowable_urls, $return_to)) { return true; } else { return false; } }   define('SERVICES_YADIS_MATCH_ALL', 101); define('SERVICES_YADIS_MATCH_ANY', 102); define('SERVICES_YADIS_MAX_PRIORITY', pow(2, 30)); define('Auth_Yadis_XMLNS_XRD_2_0', 'xri://$xrd*($v*2.0)'); define('Auth_Yadis_XMLNS_XRDS', 'xri://$xrds'); function Auth_Yadis_getNSMap() { return array('xrds' => Auth_Yadis_XMLNS_XRDS, 'xrd' => Auth_Yadis_XMLNS_XRD_2_0); } function Auth_Yadis_array_scramble($arr) { $result = array(); while (count($arr)) { $index = array_rand($arr, 1); $result[] = $arr[$index]; unset($arr[$index]); } return $result; } class Auth_Yadis_Service { function Auth_Yadis_Service() { $this->element = null; $this->parser = null; } function getTypes() { $t = array(); foreach ($this->getElements('xrd:Type') as $elem) { $c = $this->parser->content($elem); if ($c) { $t[] = $c; } } return $t; } function matchTypes($type_uris) { $result = array(); foreach ($this->getTypes() as $typ) { if (in_array($typ, $type_uris)) { $result[] = $typ; } } return $result; } function getURIs() { $uris = array(); $last = array(); foreach ($this->getElements('xrd:URI') as $elem) { $uri_string = $this->parser->content($elem); $attrs = $this->parser->attributes($elem); if ($attrs && array_key_exists('priority', $attrs)) { $priority = intval($attrs['priority']); if (!array_key_exists($priority, $uris)) { $uris[$priority] = array(); } $uris[$priority][] = $uri_string; } else { $last[] = $uri_string; } } $keys = array_keys($uris); sort($keys); $result = array(); foreach ($keys as $k) { $new_uris = Auth_Yadis_array_scramble($uris[$k]); $result = array_merge($result, $new_uris); } $result = array_merge($result, Auth_Yadis_array_scramble($last)); return $result; } function getPriority() { $attributes = $this->parser->attributes($this->element); if (array_key_exists('priority', $attributes)) { return intval($attributes['priority']); } return null; } function getElements($name) { return $this->parser->evalXPath($name, $this->element); } } function Auth_Yadis_getXRDExpiration($xrd_element, $default=null) { $expires_element = $xrd_element->$parser->evalXPath('/xrd:Expires'); if ($expires_element === null) { return $default; } else { $expires_string = $expires_element->text; $t = strptime($expires_string, "%Y-%m-%dT%H:%M:%SZ"); if ($t === false) { return false; } return mktime($t['tm_hour'], $t['tm_min'], $t['tm_sec'], $t['tm_mon'], $t['tm_day'], $t['tm_year']); } } class Auth_Yadis_XRDS { function Auth_Yadis_XRDS(&$xmlParser, &$xrdNodes) { $this->parser =& $xmlParser; $this->xrdNode = $xrdNodes[count($xrdNodes) - 1]; $this->allXrdNodes =& $xrdNodes; $this->serviceList = array(); $this->_parse(); } static function parseXRDS($xml_string, $extra_ns_map = null) { $_null = null; if (!$xml_string) { return $_null; } $parser = Auth_Yadis_getXMLParser(); $ns_map = Auth_Yadis_getNSMap(); if ($extra_ns_map && is_array($extra_ns_map)) { $ns_map = array_merge($ns_map, $extra_ns_map); } if (!($parser && $parser->init($xml_string, $ns_map))) { return $_null; } $root = $parser->evalXPath('/xrds:XRDS[1]'); if (!$root) { return $_null; } if (is_array($root)) { $root = $root[0]; } $attrs = $parser->attributes($root); if (array_key_exists('xmlns:xrd', $attrs) && $attrs['xmlns:xrd'] != Auth_Yadis_XMLNS_XRDS) { return $_null; } else if (array_key_exists('xmlns', $attrs) && preg_match('/xri/', $attrs['xmlns']) && $attrs['xmlns'] != Auth_Yadis_XMLNS_XRD_2_0) { return $_null; } $xrd_nodes = $parser->evalXPath('/xrds:XRDS[1]/xrd:XRD'); if (!$xrd_nodes) { return $_null; } $xrds = new Auth_Yadis_XRDS($parser, $xrd_nodes); return $xrds; } function _addService($priority, $service) { $priority = intval($priority); if (!array_key_exists($priority, $this->serviceList)) { $this->serviceList[$priority] = array(); } $this->serviceList[$priority][] = $service; } function _parse() { $this->serviceList = array(); $services = $this->parser->evalXPath('xrd:Service', $this->xrdNode); foreach ($services as $node) { $s = new Auth_Yadis_Service(); $s->element = $node; $s->parser =& $this->parser; $priority = $s->getPriority(); if ($priority === null) { $priority = SERVICES_YADIS_MAX_PRIORITY; } $this->_addService($priority, $s); } } function services($filters = null, $filter_mode = SERVICES_YADIS_MATCH_ANY) { $pri_keys = array_keys($this->serviceList); sort($pri_keys, SORT_NUMERIC); if (!$filters || (!is_array($filters))) { $result = array(); foreach ($pri_keys as $pri) { $result = array_merge($result, $this->serviceList[$pri]); } return $result; } if (!in_array($filter_mode, array(SERVICES_YADIS_MATCH_ANY, SERVICES_YADIS_MATCH_ALL))) { return null; } $filtered = array(); foreach ($pri_keys as $priority_value) { $service_obj_list = $this->serviceList[$priority_value]; foreach ($service_obj_list as $service) { $matches = 0; foreach ($filters as $filter) { if (call_user_func_array($filter, array($service))) { $matches++; if ($filter_mode == SERVICES_YADIS_MATCH_ANY) { $pri = $service->getPriority(); if ($pri === null) { $pri = SERVICES_YADIS_MAX_PRIORITY; } if (!array_key_exists($pri, $filtered)) { $filtered[$pri] = array(); } $filtered[$pri][] = $service; break; } } } if (($filter_mode == SERVICES_YADIS_MATCH_ALL) && ($matches == count($filters))) { $pri = $service->getPriority(); if ($pri === null) { $pri = SERVICES_YADIS_MAX_PRIORITY; } if (!array_key_exists($pri, $filtered)) { $filtered[$pri] = array(); } $filtered[$pri][] = $service; } } } $pri_keys = array_keys($filtered); sort($pri_keys, SORT_NUMERIC); $result = array(); foreach ($pri_keys as $pri) { $result = array_merge($result, $filtered[$pri]); } return $result; } }   define('Auth_OpenID_AX_NS_URI', 'http://openid.net/srv/ax/1.0'); define('Auth_OpenID_AX_UNLIMITED_VALUES', 'unlimited'); define('Auth_OpenID_AX_MINIMUM_SUPPORTED_ALIAS_LENGTH', 32); class Auth_OpenID_AX { static function isError($thing) { return is_a($thing, 'Auth_OpenID_AX_Error'); } } function Auth_OpenID_AX_checkAlias($alias) { if (strpos($alias, ',') !== false) { return new Auth_OpenID_AX_Error(sprintf( "Alias %s must not contain comma", $alias)); } if (strpos($alias, '.') !== false) { return new Auth_OpenID_AX_Error(sprintf( "Alias %s must not contain period", $alias)); } return true; } class Auth_OpenID_AX_Error { function Auth_OpenID_AX_Error($message=null) { $this->message = $message; } } class Auth_OpenID_AX_Message extends Auth_OpenID_Extension { var $ns_alias = 'ax'; var $mode = null; var $ns_uri = Auth_OpenID_AX_NS_URI; function _checkMode($ax_args) { $mode = Auth_OpenID::arrayGet($ax_args, 'mode'); if ($mode != $this->mode) { return new Auth_OpenID_AX_Error( sprintf( "Expected mode '%s'; got '%s'", $this->mode, $mode)); } return true; } function _newArgs() { return array('mode' => $this->mode); } } class Auth_OpenID_AX_AttrInfo { function Auth_OpenID_AX_AttrInfo($type_uri, $count, $required, $alias) { $this->required = $required; $this->count = $count; $this->type_uri = $type_uri; $this->alias = $alias; } function make($type_uri, $count=1, $required=false, $alias=null) { if ($alias !== null) { $result = Auth_OpenID_AX_checkAlias($alias); if (Auth_OpenID_AX::isError($result)) { return $result; } } return new Auth_OpenID_AX_AttrInfo($type_uri, $count, $required, $alias); } function wantsUnlimitedValues() { return $this->count === Auth_OpenID_AX_UNLIMITED_VALUES; } } function Auth_OpenID_AX_toTypeURIs(&$namespace_map, $alias_list_s) { $uris = array(); if ($alias_list_s) { foreach (explode(',', $alias_list_s) as $alias) { $type_uri = $namespace_map->getNamespaceURI($alias); if ($type_uri === null) { return new Auth_OpenID_AX_Error( sprintf('No type is defined for attribute name %s', $alias) ); } else { $uris[] = $type_uri; } } } return $uris; } class Auth_OpenID_AX_FetchRequest extends Auth_OpenID_AX_Message { var $mode = 'fetch_request'; function Auth_OpenID_AX_FetchRequest($update_url=null) { $this->requested_attributes = array(); $this->update_url = $update_url; } function add($attribute) { if ($this->contains($attribute->type_uri)) { return new Auth_OpenID_AX_Error( sprintf("The attribute %s has already been requested", $attribute->type_uri)); } $this->requested_attributes[$attribute->type_uri] = $attribute; return true; } function getExtensionArgs() { $aliases = new Auth_OpenID_NamespaceMap(); $required = array(); $if_available = array(); $ax_args = $this->_newArgs(); foreach ($this->requested_attributes as $type_uri => $attribute) { if ($attribute->alias === null) { $alias = $aliases->add($type_uri); } else { $alias = $aliases->addAlias($type_uri, $attribute->alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $attribute->alias, $type_uri )); } } if ($attribute->required) { $required[] = $alias; } else { $if_available[] = $alias; } if ($attribute->count != 1) { $ax_args['count.' . $alias] = strval($attribute->count); } $ax_args['type.' . $alias] = $type_uri; } if ($required) { $ax_args['required'] = implode(',', $required); } if ($if_available) { $ax_args['if_available'] = implode(',', $if_available); } return $ax_args; } function getRequiredAttrs() { $required = array(); foreach ($this->requested_attributes as $type_uri => $attribute) { if ($attribute->required) { $required[] = $type_uri; } } return $required; } function &fromOpenIDRequest($request) { $m = $request->message; $obj = new Auth_OpenID_AX_FetchRequest(); $ax_args = $m->getArgs($obj->ns_uri); $result = $obj->parseExtensionArgs($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } if ($obj->update_url) { $realm = $m->getArg(Auth_OpenID_OPENID_NS, 'realm', $m->getArg( Auth_OpenID_OPENID_NS, 'return_to')); if (!$realm) { $obj = new Auth_OpenID_AX_Error( sprintf("Cannot validate update_url %s " . "against absent realm", $obj->update_url)); } else if (!Auth_OpenID_TrustRoot::match($realm, $obj->update_url)) { $obj = new Auth_OpenID_AX_Error( sprintf("Update URL %s failed validation against realm %s", $obj->update_url, $realm)); } } return $obj; } function parseExtensionArgs($ax_args) { $result = $this->_checkMode($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } $aliases = new Auth_OpenID_NamespaceMap(); foreach ($ax_args as $key => $value) { if (strpos($key, 'type.') === 0) { $alias = substr($key, 5); $type_uri = $value; $alias = $aliases->addAlias($type_uri, $alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $alias, $type_uri) ); } $count_s = Auth_OpenID::arrayGet($ax_args, 'count.' . $alias); if ($count_s) { $count = Auth_OpenID::intval($count_s); if (($count === false) && ($count_s === Auth_OpenID_AX_UNLIMITED_VALUES)) { $count = $count_s; } } else { $count = 1; } if ($count === false) { return new Auth_OpenID_AX_Error( sprintf("Integer value expected for %s, got %s", 'count.' . $alias, $count_s)); } $attrinfo = Auth_OpenID_AX_AttrInfo::make($type_uri, $count, false, $alias); if (Auth_OpenID_AX::isError($attrinfo)) { return $attrinfo; } $this->add($attrinfo); } } $required = Auth_OpenID_AX_toTypeURIs($aliases, Auth_OpenID::arrayGet($ax_args, 'required')); foreach ($required as $type_uri) { $attrib =& $this->requested_attributes[$type_uri]; $attrib->required = true; } $if_available = Auth_OpenID_AX_toTypeURIs($aliases, Auth_OpenID::arrayGet($ax_args, 'if_available')); $all_type_uris = array_merge($required, $if_available); foreach ($aliases->iterNamespaceURIs() as $type_uri) { if (!in_array($type_uri, $all_type_uris)) { return new Auth_OpenID_AX_Error( sprintf('Type URI %s was in the request but not ' . 'present in "required" or "if_available"', $type_uri)); } } $this->update_url = Auth_OpenID::arrayGet($ax_args, 'update_url'); return true; } function iterAttrs() { return array_values($this->requested_attributes); } function iterTypes() { return array_keys($this->requested_attributes); } function contains($type_uri) { return in_array($type_uri, $this->iterTypes()); } } class Auth_OpenID_AX_KeyValueMessage extends Auth_OpenID_AX_Message { function Auth_OpenID_AX_KeyValueMessage() { $this->data = array(); } function addValue($type_uri, $value) { if (!array_key_exists($type_uri, $this->data)) { $this->data[$type_uri] = array(); } $values =& $this->data[$type_uri]; $values[] = $value; } function setValues($type_uri, &$values) { $this->data[$type_uri] =& $values; } function _getExtensionKVArgs(&$aliases) { if ($aliases === null) { $aliases = new Auth_OpenID_NamespaceMap(); } $ax_args = array(); foreach ($this->data as $type_uri => $values) { $alias = $aliases->add($type_uri); $ax_args['type.' . $alias] = $type_uri; $ax_args['count.' . $alias] = strval(count($values)); foreach ($values as $i => $value) { $key = sprintf('value.%s.%d', $alias, $i + 1); $ax_args[$key] = $value; } } return $ax_args; } function parseExtensionArgs($ax_args) { $result = $this->_checkMode($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } $aliases = new Auth_OpenID_NamespaceMap(); foreach ($ax_args as $key => $value) { if (strpos($key, 'type.') === 0) { $type_uri = $value; $alias = substr($key, 5); $result = Auth_OpenID_AX_checkAlias($alias); if (Auth_OpenID_AX::isError($result)) { return $result; } $alias = $aliases->addAlias($type_uri, $alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $alias, $type_uri) ); } } } foreach ($aliases->iteritems() as $pair) { list($type_uri, $alias) = $pair; if (array_key_exists('count.' . $alias, $ax_args)) { $count_key = 'count.' . $alias; $count_s = $ax_args[$count_key]; $count = Auth_OpenID::intval($count_s); if ($count === false) { return new Auth_OpenID_AX_Error( sprintf("Integer value expected for %s, got %s", 'count. %s' . $alias, $count_s, Auth_OpenID_AX_UNLIMITED_VALUES) ); } $values = array(); for ($i = 1; $i < $count + 1; $i++) { $value_key = sprintf('value.%s.%d', $alias, $i); if (!array_key_exists($value_key, $ax_args)) { return new Auth_OpenID_AX_Error( sprintf( "No value found for key %s", $value_key)); } $value = $ax_args[$value_key]; $values[] = $value; } } else { $key = 'value.' . $alias; if (!array_key_exists($key, $ax_args)) { return new Auth_OpenID_AX_Error( sprintf( "No value found for key %s", $key)); } $value = $ax_args['value.' . $alias]; if ($value == '') { $values = array(); } else { $values = array($value); } } $this->data[$type_uri] = $values; } return true; } function getSingle($type_uri, $default=null) { $values = Auth_OpenID::arrayGet($this->data, $type_uri); if (!$values) { return $default; } else if (count($values) == 1) { return $values[0]; } else { return new Auth_OpenID_AX_Error( sprintf('More than one value present for %s', $type_uri) ); } } function get($type_uri) { if (array_key_exists($type_uri, $this->data)) { return $this->data[$type_uri]; } else { return new Auth_OpenID_AX_Error( sprintf("Type URI %s not found in response", $type_uri) ); } } function count($type_uri) { if (array_key_exists($type_uri, $this->data)) { return count($this->get($type_uri)); } else { return new Auth_OpenID_AX_Error( sprintf("Type URI %s not found in response", $type_uri) ); } } } class Auth_OpenID_AX_FetchResponse extends Auth_OpenID_AX_KeyValueMessage { var $mode = 'fetch_response'; function Auth_OpenID_AX_FetchResponse($update_url=null) { $this->Auth_OpenID_AX_KeyValueMessage(); $this->update_url = $update_url; } function getExtensionArgs($request=null) { $aliases = new Auth_OpenID_NamespaceMap(); $zero_value_types = array(); if ($request !== null) { foreach ($this->data as $type_uri => $unused) { if (!$request->contains($type_uri)) { return new Auth_OpenID_AX_Error( sprintf("Response attribute not present in request: %s", $type_uri) ); } } foreach ($request->iterAttrs() as $attr_info) { if ($attr_info->alias === null) { $aliases->add($attr_info->type_uri); } else { $alias = $aliases->addAlias($attr_info->type_uri, $attr_info->alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $attr_info->alias, $attr_info->type_uri) ); } } if (array_key_exists($attr_info->type_uri, $this->data)) { $values = $this->data[$attr_info->type_uri]; } else { $values = array(); $zero_value_types[] = $attr_info; } if (($attr_info->count != Auth_OpenID_AX_UNLIMITED_VALUES) && ($attr_info->count < count($values))) { return new Auth_OpenID_AX_Error( sprintf("More than the number of requested values " . "were specified for %s", $attr_info->type_uri) ); } } } $kv_args = $this->_getExtensionKVArgs($aliases); $ax_args = $this->_newArgs(); foreach ($zero_value_types as $attr_info) { $alias = $aliases->getAlias($attr_info->type_uri); $kv_args['type.' . $alias] = $attr_info->type_uri; $kv_args['count.' . $alias] = '0'; } $update_url = null; if ($request) { $update_url = $request->update_url; } else { $update_url = $this->update_url; } if ($update_url) { $ax_args['update_url'] = $update_url; } Auth_OpenID::update($ax_args, $kv_args); return $ax_args; } function parseExtensionArgs($ax_args) { $result = parent::parseExtensionArgs($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } $this->update_url = Auth_OpenID::arrayGet($ax_args, 'update_url'); return true; } function fromSuccessResponse($success_response, $signed=true) { $obj = new Auth_OpenID_AX_FetchResponse(); if ($signed) { $ax_args = $success_response->getSignedNS($obj->ns_uri); } else { $ax_args = $success_response->message->getArgs($obj->ns_uri); } if ($ax_args === null || Auth_OpenID::isFailure($ax_args) || sizeof($ax_args) == 0) { return null; } $result = $obj->parseExtensionArgs($ax_args); if (Auth_OpenID_AX::isError($result)) { return null; } return $obj; } } class Auth_OpenID_AX_StoreRequest extends Auth_OpenID_AX_KeyValueMessage { var $mode = 'store_request'; function getExtensionArgs($aliases=null) { $ax_args = $this->_newArgs(); $kv_args = $this->_getExtensionKVArgs($aliases); Auth_OpenID::update($ax_args, $kv_args); return $ax_args; } } class Auth_OpenID_AX_StoreResponse extends Auth_OpenID_AX_Message { var $SUCCESS_MODE = 'store_response_success'; var $FAILURE_MODE = 'store_response_failure'; function &make($succeeded=true, $error_message=null) { if (($succeeded) && ($error_message !== null)) { return new Auth_OpenID_AX_Error('An error message may only be '. 'included in a failing fetch response'); } return new Auth_OpenID_AX_StoreResponse($succeeded, $error_message); } function Auth_OpenID_AX_StoreResponse($succeeded=true, $error_message=null) { if ($succeeded) { $this->mode = $this->SUCCESS_MODE; } else { $this->mode = $this->FAILURE_MODE; } $this->error_message = $error_message; } function succeeded() { return $this->mode == $this->SUCCESS_MODE; } function getExtensionArgs() { $ax_args = $this->_newArgs(); if ((!$this->succeeded()) && $this->error_message) { $ax_args['error'] = $this->error_message; } return $ax_args; } }   if (!defined('Auth_OpenID_RAND_SOURCE')) { define('Auth_OpenID_RAND_SOURCE', '/dev/urandom'); } class Auth_OpenID_CryptUtil { function getBytes($num_bytes) { static $f = null; $bytes = ''; if ($f === null) { if (Auth_OpenID_RAND_SOURCE === null) { $f = false; } else { $f = @fopen(Auth_OpenID_RAND_SOURCE, "r"); if ($f === false) { $msg = 'Define Auth_OpenID_RAND_SOURCE as null to ' . ' continue with an insecure random number generator.'; trigger_error($msg, E_USER_ERROR); } } } if ($f === false) { $bytes = ''; for ($i = 0; $i < $num_bytes; $i += 4) { $bytes .= pack('L', mt_rand()); } $bytes = substr($bytes, 0, $num_bytes); } else { $bytes = fread($f, $num_bytes); } return $bytes; } function randomString($length, $population = null) { if ($population === null) { return Auth_OpenID_CryptUtil::getBytes($length); } $popsize = strlen($population); if ($popsize > 256) { $msg = 'More than 256 characters supplied to ' . __FUNCTION__; trigger_error($msg, E_USER_ERROR); } $duplicate = 256 % $popsize; $str = ""; for ($i = 0; $i < $length; $i++) { do { $n = ord(Auth_OpenID_CryptUtil::getBytes(1)); } while ($n < $duplicate); $n %= $popsize; $str .= $population[$n]; } return $str; } }   class Auth_OpenID_DatabaseConnection { function autoCommit($mode) { } function query($sql, $params = array()) { } function begin() { } function commit() { } function rollback() { } function getOne($sql, $params = array()) { } function getRow($sql, $params = array()) { } function getAll($sql, $params = array()) { } }   define('Auth_OpenID_XMLNS_1_0', 'http://openid.net/xmlns/1.0'); define('Auth_OpenID_TYPE_1_2', 'http://openid.net/signon/1.2'); define('Auth_OpenID_TYPE_1_1', 'http://openid.net/signon/1.1'); define('Auth_OpenID_TYPE_1_0', 'http://openid.net/signon/1.0'); define('Auth_OpenID_TYPE_2_0_IDP', 'http://specs.openid.net/auth/2.0/server'); define('Auth_OpenID_TYPE_2_0', 'http://specs.openid.net/auth/2.0/signon'); define('Auth_OpenID_RP_RETURN_TO_URL_TYPE', 'http://specs.openid.net/auth/2.0/return_to'); function Auth_OpenID_getOpenIDTypeURIs() { return array(Auth_OpenID_TYPE_2_0_IDP, Auth_OpenID_TYPE_2_0, Auth_OpenID_TYPE_1_2, Auth_OpenID_TYPE_1_1, Auth_OpenID_TYPE_1_0, Auth_OpenID_RP_RETURN_TO_URL_TYPE); } class Auth_OpenID_ServiceEndpoint { function Auth_OpenID_ServiceEndpoint() { $this->claimed_id = null; $this->server_url = null; $this->type_uris = array(); $this->local_id = null; $this->canonicalID = null; $this->used_yadis = false; $this->display_identifier = null; } function getDisplayIdentifier() { if ($this->display_identifier) { return $this->display_identifier; } if (! $this->claimed_id) { return $this->claimed_id; } $parsed = parse_url($this->claimed_id); $scheme = $parsed['scheme']; $host = $parsed['host']; $path = $parsed['path']; if (array_key_exists('query', $parsed)) { $query = $parsed['query']; $no_frag = "$scheme://$host$path?$query"; } else { $no_frag = "$scheme://$host$path"; } return $no_frag; } function usesExtension($extension_uri) { return in_array($extension_uri, $this->type_uris); } function preferredNamespace() { if (in_array(Auth_OpenID_TYPE_2_0_IDP, $this->type_uris) || in_array(Auth_OpenID_TYPE_2_0, $this->type_uris)) { return Auth_OpenID_OPENID2_NS; } else { return Auth_OpenID_OPENID1_NS; } } function matchTypes($type_uris) { $result = array(); foreach ($type_uris as $test_uri) { if ($this->supportsType($test_uri)) { $result[] = $test_uri; } } return $result; } function supportsType($type_uri) { return ((in_array($type_uri, $this->type_uris)) || (($type_uri == Auth_OpenID_TYPE_2_0) && $this->isOPIdentifier())); } function compatibilityMode() { return $this->preferredNamespace() != Auth_OpenID_OPENID2_NS; } function isOPIdentifier() { return in_array(Auth_OpenID_TYPE_2_0_IDP, $this->type_uris); } function fromOPEndpointURL($op_endpoint_url) { $obj = new Auth_OpenID_ServiceEndpoint(); $obj->server_url = $op_endpoint_url; $obj->type_uris = array(Auth_OpenID_TYPE_2_0_IDP); return $obj; } function parseService($yadis_url, $uri, $type_uris, $service_element) { $this->type_uris = $type_uris; $this->server_url = $uri; $this->used_yadis = true; if (!$this->isOPIdentifier()) { $this->claimed_id = $yadis_url; $this->local_id = Auth_OpenID_findOPLocalIdentifier( $service_element, $this->type_uris); if ($this->local_id === false) { return false; } } return true; } function getLocalID() { if ($this->local_id === null && $this->canonicalID === null) { return $this->claimed_id; } else { if ($this->local_id) { return $this->local_id; } else { return $this->canonicalID; } } } static function fromXRDS($uri, $xrds_text) { $xrds = Auth_Yadis_XRDS::parseXRDS($xrds_text); if ($xrds) { $yadis_services = $xrds->services(array('filter_MatchesAnyOpenIDType')); return Auth_OpenID_makeOpenIDEndpoints($uri, $yadis_services); } return null; } function fromDiscoveryResult($discoveryResult) { if ($discoveryResult->isXRDS()) { return Auth_OpenID_ServiceEndpoint::fromXRDS( $discoveryResult->normalized_uri, $discoveryResult->response_text); } else { return Auth_OpenID_ServiceEndpoint::fromHTML( $discoveryResult->normalized_uri, $discoveryResult->response_text); } } function fromHTML($uri, $html) { $discovery_types = array( array(Auth_OpenID_TYPE_2_0, 'openid2.provider', 'openid2.local_id'), array(Auth_OpenID_TYPE_1_1, 'openid.server', 'openid.delegate') ); $services = array(); foreach ($discovery_types as $triple) { list($type_uri, $server_rel, $delegate_rel) = $triple; $urls = Auth_OpenID_legacy_discover($html, $server_rel, $delegate_rel); if ($urls === false) { continue; } list($delegate_url, $server_url) = $urls; $service = new Auth_OpenID_ServiceEndpoint(); $service->claimed_id = $uri; $service->local_id = $delegate_url; $service->server_url = $server_url; $service->type_uris = array($type_uri); $services[] = $service; } return $services; } function copy() { $x = new Auth_OpenID_ServiceEndpoint(); $x->claimed_id = $this->claimed_id; $x->server_url = $this->server_url; $x->type_uris = $this->type_uris; $x->local_id = $this->local_id; $x->canonicalID = $this->canonicalID; $x->used_yadis = $this->used_yadis; return $x; } } function Auth_OpenID_findOPLocalIdentifier($service, $type_uris) { $service->parser->registerNamespace('openid', Auth_OpenID_XMLNS_1_0); $service->parser->registerNamespace('xrd', Auth_Yadis_XMLNS_XRD_2_0); $parser =& $service->parser; $permitted_tags = array(); if (in_array(Auth_OpenID_TYPE_1_1, $type_uris) || in_array(Auth_OpenID_TYPE_1_0, $type_uris)) { $permitted_tags[] = 'openid:Delegate'; } if (in_array(Auth_OpenID_TYPE_2_0, $type_uris)) { $permitted_tags[] = 'xrd:LocalID'; } $local_id = null; foreach ($permitted_tags as $tag_name) { $tags = $service->getElements($tag_name); foreach ($tags as $tag) { $content = $parser->content($tag); if ($local_id === null) { $local_id = $content; } else if ($local_id != $content) { return false; } } } return $local_id; } function filter_MatchesAnyOpenIDType($service) { $uris = $service->getTypes(); foreach ($uris as $uri) { if (in_array($uri, Auth_OpenID_getOpenIDTypeURIs())) { return true; } } return false; } function Auth_OpenID_bestMatchingService($service, $preferred_types) { foreach ($preferred_types as $index => $typ) { if (in_array($typ, $service->type_uris)) { return $index; } } return count($preferred_types); } function Auth_OpenID_arrangeByType($service_list, $preferred_types) { $prio_services = array(); foreach ($service_list as $index => $service) { $prio_services[] = array(Auth_OpenID_bestMatchingService($service, $preferred_types), $index, $service); } sort($prio_services); foreach ($prio_services as $index => $s) { $prio_services[$index] = $prio_services[$index][2]; } return $prio_services; } function Auth_OpenID_getOPOrUserServices($openid_services) { $op_services = Auth_OpenID_arrangeByType($openid_services, array(Auth_OpenID_TYPE_2_0_IDP)); $openid_services = Auth_OpenID_arrangeByType($openid_services, Auth_OpenID_getOpenIDTypeURIs()); if ($op_services) { return $op_services; } else { return $openid_services; } } function Auth_OpenID_makeOpenIDEndpoints($uri, $yadis_services) { $s = array(); if (!$yadis_services) { return $s; } foreach ($yadis_services as $service) { $type_uris = $service->getTypes(); $uris = $service->getURIs(); if ($type_uris && $uris) { foreach ($uris as $service_uri) { $openid_endpoint = new Auth_OpenID_ServiceEndpoint(); if ($openid_endpoint->parseService($uri, $service_uri, $type_uris, $service)) { $s[] = $openid_endpoint; } } } } return $s; } function Auth_OpenID_discoverWithYadis($uri, $fetcher, $endpoint_filter='Auth_OpenID_getOPOrUserServices', $discover_function=null) { if ($discover_function === null) { $discover_function = array('Auth_Yadis_Yadis', 'discover'); } $openid_services = array(); $response = call_user_func_array($discover_function, array($uri, $fetcher)); $yadis_url = $response->normalized_uri; $yadis_services = array(); if ($response->isFailure()) { return array($uri, array()); } $openid_services = Auth_OpenID_ServiceEndpoint::fromXRDS( $yadis_url, $response->response_text); if (!$openid_services) { if ($response->isXRDS()) { return Auth_OpenID_discoverWithoutYadis($uri, $fetcher); } $openid_services = Auth_OpenID_ServiceEndpoint::fromHTML( $yadis_url, $response->response_text); } $openid_services = call_user_func_array($endpoint_filter, array(&$openid_services)); return array($yadis_url, $openid_services); } function Auth_OpenID_discoverURI($uri, $fetcher) { $uri = Auth_OpenID::normalizeUrl($uri); return Auth_OpenID_discoverWithYadis($uri, $fetcher); } function Auth_OpenID_discoverWithoutYadis($uri, $fetcher) { $http_resp = @$fetcher->get($uri); if ($http_resp->status != 200 and $http_resp->status != 206) { return array($uri, array()); } $identity_url = $http_resp->final_url; $openid_services = Auth_OpenID_ServiceEndpoint::fromHTML( $identity_url, $http_resp->body); return array($identity_url, $openid_services); } function Auth_OpenID_discoverXRI($iname, $fetcher) { $resolver = new Auth_Yadis_ProxyResolver($fetcher); list($canonicalID, $yadis_services) = $resolver->query($iname, Auth_OpenID_getOpenIDTypeURIs(), array('filter_MatchesAnyOpenIDType')); $openid_services = Auth_OpenID_makeOpenIDEndpoints($iname, $yadis_services); $openid_services = Auth_OpenID_getOPOrUserServices($openid_services); for ($i = 0; $i < count($openid_services); $i++) { $openid_services[$i]->canonicalID = $canonicalID; $openid_services[$i]->claimed_id = $canonicalID; $openid_services[$i]->display_identifier = $iname; } return array($iname, $openid_services); } function Auth_OpenID_discover($uri, $fetcher) { if ($fetcher->isHTTPS($uri) && !$fetcher->supportsSSL()) { return array($uri, array()); } if (Auth_Yadis_identifierScheme($uri) == 'XRI') { $result = Auth_OpenID_discoverXRI($uri, $fetcher); } else { $result = Auth_OpenID_discoverURI($uri, $fetcher); } if (!$fetcher->supportsSSL()) { $http_endpoints = array(); list($new_uri, $endpoints) = $result; foreach ($endpoints as $e) { if (!$fetcher->isHTTPS($e->server_url)) { $http_endpoints[] = $e; } } $result = array($new_uri, $http_endpoints); } return $result; }   define('Auth_OpenID_SHA1_BLOCKSIZE', 64); function Auth_OpenID_SHA1($text) { if (function_exists('hash') && function_exists('hash_algos') && (in_array('sha1', hash_algos()))) { return hash('sha1', $text, true); } else if (function_exists('sha1')) { $hex = sha1($text); $raw = ''; for ($i = 0; $i < 40; $i += 2) { $hexcode = substr($hex, $i, 2); $charcode = (int)base_convert($hexcode, 16, 10); $raw .= chr($charcode); } return $raw; } else { trigger_error('No SHA1 function found', E_USER_ERROR); } } function Auth_OpenID_HMACSHA1($key, $text) { if (Auth_OpenID::bytes($key) > Auth_OpenID_SHA1_BLOCKSIZE) { $key = Auth_OpenID_SHA1($key, true); } $key = str_pad($key, Auth_OpenID_SHA1_BLOCKSIZE, chr(0x00)); $ipad = str_repeat(chr(0x36), Auth_OpenID_SHA1_BLOCKSIZE); $opad = str_repeat(chr(0x5c), Auth_OpenID_SHA1_BLOCKSIZE); $hash1 = Auth_OpenID_SHA1(($key ^ $ipad) . $text, true); $hmac = Auth_OpenID_SHA1(($key ^ $opad) . $hash1, true); return $hmac; } if (function_exists('hash') && function_exists('hash_algos') && (in_array('sha256', hash_algos()))) { function Auth_OpenID_SHA256($text) { return hash('sha256', $text, true); } define('Auth_OpenID_SHA256_SUPPORTED', true); } else { define('Auth_OpenID_SHA256_SUPPORTED', false); } if (function_exists('hash_hmac') && function_exists('hash_algos') && (in_array('sha256', hash_algos()))) { function Auth_OpenID_HMACSHA256($key, $text) { return hash_hmac('sha256', $text, $key, true); } define('Auth_OpenID_HMACSHA256_SUPPORTED', true); } else { define('Auth_OpenID_HMACSHA256_SUPPORTED', false); }   define('Auth_OpenID_FETCHER_MAX_RESPONSE_KB', 1024); define('Auth_OpenID_USER_AGENT', 'php-openid/'.Auth_OpenID_VERSION.' (php/'.phpversion().')'); class Auth_Yadis_HTTPResponse { function Auth_Yadis_HTTPResponse($final_url = null, $status = null, $headers = null, $body = null) { $this->final_url = $final_url; $this->status = $status; $this->headers = $headers; $this->body = $body; } } class Auth_Yadis_HTTPFetcher { var $timeout = 20; function canFetchURL($url) { if ($this->isHTTPS($url) && !$this->supportsSSL()) { Auth_OpenID::log("HTTPS URL unsupported fetching %s", $url); return false; } if (!$this->allowedURL($url)) { Auth_OpenID::log("URL fetching not allowed for '%s'", $url); return false; } return true; } function allowedURL($url) { return $this->URLHasAllowedScheme($url); } function supportsSSL() { trigger_error("not implemented", E_USER_ERROR); } function isHTTPS($url) { return (bool)preg_match('/^https:\/\//i', $url); } function URLHasAllowedScheme($url) { return (bool)preg_match('/^https?:\/\//i', $url); } function _findRedirect($headers) { foreach ($headers as $line) { if (strpos(strtolower($line), "location: ") === 0) { $parts = explode(" ", $line, 2); return $parts[1]; } } return null; } function get($url, $headers = null) { trigger_error("not implemented", E_USER_ERROR); } }   class Auth_OpenID_OpenIDStore { function storeAssociation($server_url, $association) { trigger_error("Auth_OpenID_OpenIDStore::storeAssociation ". "not implemented", E_USER_ERROR); } function cleanupNonces() { trigger_error("Auth_OpenID_OpenIDStore::cleanupNonces ". "not implemented", E_USER_ERROR); } function cleanupAssociations() { trigger_error("Auth_OpenID_OpenIDStore::cleanupAssociations ". "not implemented", E_USER_ERROR); } function cleanup() { return array($this->cleanupNonces(), $this->cleanupAssociations()); } function supportsCleanup() { return true; } function getAssociation($server_url, $handle = null) { trigger_error("Auth_OpenID_OpenIDStore::getAssociation ". "not implemented", E_USER_ERROR); } function removeAssociation($server_url, $handle) { trigger_error("Auth_OpenID_OpenIDStore::removeAssociation ". "not implemented", E_USER_ERROR); } function useNonce($server_url, $timestamp, $salt) { trigger_error("Auth_OpenID_OpenIDStore::useNonce ". "not implemented", E_USER_ERROR); } function reset() { } }   class Auth_OpenID_KVForm { static function toArray($kvs, $strict=false) { $lines = explode("\n", $kvs); $last = array_pop($lines); if ($last !== '') { array_push($lines, $last); if ($strict) { return false; } } $values = array(); for ($lineno = 0; $lineno < count($lines); $lineno++) { $line = $lines[$lineno]; $kv = explode(':', $line, 2); if (count($kv) != 2) { if ($strict) { return false; } continue; } $key = $kv[0]; $tkey = trim($key); if ($tkey != $key) { if ($strict) { return false; } } $value = $kv[1]; $tval = trim($value); if ($tval != $value) { if ($strict) { return false; } } $values[$tkey] = $tval; } return $values; } static function fromArray($values) { if ($values === null) { return null; } ksort($values); $serialized = ''; foreach ($values as $key => $value) { if (is_array($value)) { list($key, $value) = array($value[0], $value[1]); } if (strpos($key, ':') !== false) { return null; } if (strpos($key, "\n") !== false) { return null; } if (strpos($value, "\n") !== false) { return null; } $serialized .= "$key:$value\n"; } return $serialized; } }   class Auth_Yadis_PHPSession { function set($name, $value) { $_SESSION[$name] = $value; } function get($name, $default=null) { if (array_key_exists($name, $_SESSION)) { return $_SESSION[$name]; } else { return $default; } } function del($name) { unset($_SESSION[$name]); } function contents() { return $_SESSION; } } class Auth_Yadis_SessionLoader { function check($data) { return true; } function fromSession($data) { if (!$data) { return null; } $required = $this->requiredKeys(); foreach ($required as $k) { if (!array_key_exists($k, $data)) { return null; } } if (!$this->check($data)) { return null; } $data = array_merge($data, $this->prepareForLoad($data)); $obj = $this->newObject($data); if (!$obj) { return null; } foreach ($required as $k) { $obj->$k = $data[$k]; } return $obj; } function prepareForLoad($data) { return array(); } function newObject($data) { return null; } function toSession($obj) { $data = array(); foreach ($obj as $k => $v) { $data[$k] = $v; } $extra = $this->prepareForSave($obj); if ($extra && is_array($extra)) { foreach ($extra as $k => $v) { $data[$k] = $v; } } return $data; } function prepareForSave($obj) { return array(); } } class Auth_OpenID_ServiceEndpointLoader extends Auth_Yadis_SessionLoader { function newObject($data) { return new Auth_OpenID_ServiceEndpoint(); } function requiredKeys() { $obj = new Auth_OpenID_ServiceEndpoint(); $data = array(); foreach ($obj as $k => $v) { $data[] = $k; } return $data; } function check($data) { return is_array($data['type_uris']); } } class Auth_Yadis_ManagerLoader extends Auth_Yadis_SessionLoader { function requiredKeys() { return array('starting_url', 'yadis_url', 'services', 'session_key', '_current', 'stale'); } function newObject($data) { return new Auth_Yadis_Manager($data['starting_url'], $data['yadis_url'], $data['services'], $data['session_key']); } function check($data) { return is_array($data['services']); } function prepareForLoad($data) { $loader = new Auth_OpenID_ServiceEndpointLoader(); $services = array(); foreach ($data['services'] as $s) { $services[] = $loader->fromSession($s); } return array('services' => $services); } function prepareForSave($obj) { $loader = new Auth_OpenID_ServiceEndpointLoader(); $services = array(); foreach ($obj->services as $s) { $services[] = $loader->toSession($s); } return array('services' => $services); } } class Auth_Yadis_Manager { function Auth_Yadis_Manager($starting_url, $yadis_url, $services, $session_key) { $this->starting_url = $starting_url; $this->yadis_url = $yadis_url; $this->services = $services; $this->session_key = $session_key; $this->_current = null; $this->stale = false; } function length() { return count($this->services); } function nextService() { if ($this->services) { $this->_current = array_shift($this->services); } else { $this->_current = null; } return $this->_current; } function current() { return $this->_current; } function forURL($url) { return in_array($url, array($this->starting_url, $this->yadis_url)); } function started() { return $this->_current !== null; } } class Auth_Yadis_Discovery { var $DEFAULT_SUFFIX = 'auth'; var $PREFIX = '_yadis_services_'; function Auth_Yadis_Discovery(&$session, $url, $session_key_suffix = null) { $this->session =& $session; $this->url = $url; if ($session_key_suffix === null) { $session_key_suffix = $this->DEFAULT_SUFFIX; } $this->session_key_suffix = $session_key_suffix; $this->session_key = $this->PREFIX . $this->session_key_suffix; } function getNextService($discover_cb, &$fetcher) { $manager = $this->getManager(); if (!$manager || (!$manager->services)) { $this->destroyManager(); list($yadis_url, $services) = call_user_func($discover_cb, $this->url, $fetcher); $manager = $this->createManager($services, $yadis_url); } if ($manager) { $loader = new Auth_Yadis_ManagerLoader(); $service = $manager->nextService(); $this->session->set($this->session_key, serialize($loader->toSession($manager))); } else { $service = null; } return $service; } function cleanup($force=false) { $manager = $this->getManager($force); if ($manager) { $service = $manager->current(); $this->destroyManager($force); } else { $service = null; } return $service; } function getSessionKey() { return $this->PREFIX . $this->session_key_suffix; } function &getManager($force=false) { $manager_str = $this->session->get($this->getSessionKey()); $manager = null; if ($manager_str !== null) { $loader = new Auth_Yadis_ManagerLoader(); $manager = $loader->fromSession(unserialize($manager_str)); } if ($manager && ($manager->forURL($this->url) || $force)) { return $manager; } else { $unused = null; return $unused; } } function &createManager($services, $yadis_url = null) { $key = $this->getSessionKey(); if ($this->getManager()) { return $this->getManager(); } if ($services) { $loader = new Auth_Yadis_ManagerLoader(); $manager = new Auth_Yadis_Manager($this->url, $yadis_url, $services, $key); $this->session->set($this->session_key, serialize($loader->toSession($manager))); return $manager; } else { $unused = null; return $unused; } } function destroyManager($force=false) { if ($this->getManager($force) !== null) { $key = $this->getSessionKey(); $this->session->del($key); } } }   define('Auth_OpenID_IDENTIFIER_SELECT', "http://specs.openid.net/auth/2.0/identifier_select"); define('Auth_OpenID_SREG_URI', 'http://openid.net/sreg/1.0'); define('Auth_OpenID_OPENID1_NS', 'http://openid.net/signon/1.0'); define('Auth_OpenID_THE_OTHER_OPENID1_NS', 'http://openid.net/signon/1.1'); function Auth_OpenID_isOpenID1($ns) { return ($ns == Auth_OpenID_THE_OTHER_OPENID1_NS) || ($ns == Auth_OpenID_OPENID1_NS); } define('Auth_OpenID_OPENID2_NS', 'http://specs.openid.net/auth/2.0'); define('Auth_OpenID_NULL_NAMESPACE', 'Null namespace'); define('Auth_OpenID_OPENID_NS', 'OpenID namespace'); define('Auth_OpenID_BARE_NS', 'Bare namespace'); define('Auth_OpenID_NO_DEFAULT', 'NO DEFAULT ALLOWED'); define('Auth_OpenID_OPENID1_URL_LIMIT', 2047); global $Auth_OpenID_OPENID_PROTOCOL_FIELDS; $Auth_OpenID_OPENID_PROTOCOL_FIELDS = array( 'ns', 'mode', 'error', 'return_to', 'contact', 'reference', 'signed', 'assoc_type', 'session_type', 'dh_modulus', 'dh_gen', 'dh_consumer_public', 'claimed_id', 'identity', 'realm', 'invalidate_handle', 'op_endpoint', 'response_nonce', 'sig', 'assoc_handle', 'trust_root', 'openid'); global $Auth_OpenID_registered_aliases; $Auth_OpenID_registered_aliases = array(); function Auth_OpenID_registerNamespaceAlias($namespace_uri, $alias) { global $Auth_OpenID_registered_aliases; if (Auth_OpenID::arrayGet($Auth_OpenID_registered_aliases, $alias) == $namespace_uri) { return true; } if (in_array($namespace_uri, array_values($Auth_OpenID_registered_aliases))) { return false; } if (in_array($alias, array_keys($Auth_OpenID_registered_aliases))) { return false; } $Auth_OpenID_registered_aliases[$alias] = $namespace_uri; return true; } function Auth_OpenID_removeNamespaceAlias($namespace_uri, $alias) { global $Auth_OpenID_registered_aliases; if (Auth_OpenID::arrayGet($Auth_OpenID_registered_aliases, $alias) === $namespace_uri) { unset($Auth_OpenID_registered_aliases[$alias]); return true; } return false; } class Auth_OpenID_Mapping { function Auth_OpenID_Mapping($classic_array = null) { $this->keys = array(); $this->values = array(); if (is_array($classic_array)) { foreach ($classic_array as $key => $value) { $this->set($key, $value); } } } static function isA($thing) { return (is_object($thing) && strtolower(get_class($thing)) == 'auth_openid_mapping'); } function keys() { return $this->keys; } function values() { return $this->values; } function items() { $temp = array(); for ($i = 0; $i < count($this->keys); $i++) { $temp[] = array($this->keys[$i], $this->values[$i]); } return $temp; } function len() { return count($this->keys); } function set($key, $value) { $index = array_search($key, $this->keys); if ($index !== false) { $this->values[$index] = $value; } else { $this->keys[] = $key; $this->values[] = $value; } } function get($key, $default = null) { $index = array_search($key, $this->keys); if ($index !== false) { return $this->values[$index]; } else { return $default; } } function _reflow() { $old_keys = $this->keys; $old_values = $this->values; $this->keys = array(); $this->values = array(); foreach ($old_keys as $k) { $this->keys[] = $k; } foreach ($old_values as $v) { $this->values[] = $v; } } function del($key) { $index = array_search($key, $this->keys); if ($index !== false) { unset($this->keys[$index]); unset($this->values[$index]); $this->_reflow(); return true; } return false; } function contains($value) { return (array_search($value, $this->keys) !== false); } } class Auth_OpenID_NamespaceMap { function Auth_OpenID_NamespaceMap() { $this->alias_to_namespace = new Auth_OpenID_Mapping(); $this->namespace_to_alias = new Auth_OpenID_Mapping(); $this->implicit_namespaces = array(); } function getAlias($namespace_uri) { return $this->namespace_to_alias->get($namespace_uri); } function getNamespaceURI($alias) { return $this->alias_to_namespace->get($alias); } function iterNamespaceURIs() { return $this->namespace_to_alias->keys(); } function iterAliases() { return $this->alias_to_namespace->keys(); } function iteritems() { return $this->namespace_to_alias->items(); } function isImplicit($namespace_uri) { return in_array($namespace_uri, $this->implicit_namespaces); } function addAlias($namespace_uri, $desired_alias, $implicit=false) { global $Auth_OpenID_OPENID_PROTOCOL_FIELDS; if (in_array($desired_alias, $Auth_OpenID_OPENID_PROTOCOL_FIELDS)) { Auth_OpenID::log("\"%s\" is not an allowed namespace alias", $desired_alias); return null; } if (strpos($desired_alias, '.') !== false) { Auth_OpenID::log('"%s" must not contain a dot', $desired_alias); return null; } $current_namespace_uri = $this->alias_to_namespace->get($desired_alias); if (($current_namespace_uri !== null) && ($current_namespace_uri != $namespace_uri)) { Auth_OpenID::log('Cannot map "%s" because previous mapping exists', $namespace_uri); return null; } $alias = $this->namespace_to_alias->get($namespace_uri); if (($alias !== null) && ($alias != $desired_alias)) { Auth_OpenID::log('Cannot map %s to alias %s. ' . 'It is already mapped to alias %s', $namespace_uri, $desired_alias, $alias); return null; } assert((Auth_OpenID_NULL_NAMESPACE === $desired_alias) || is_string($desired_alias)); $this->alias_to_namespace->set($desired_alias, $namespace_uri); $this->namespace_to_alias->set($namespace_uri, $desired_alias); if ($implicit) { array_push($this->implicit_namespaces, $namespace_uri); } return $desired_alias; } function add($namespace_uri) { $alias = $this->namespace_to_alias->get($namespace_uri); if ($alias !== null) { return $alias; } $i = 0; while (1) { $alias = 'ext' . strval($i); if ($this->addAlias($namespace_uri, $alias) === null) { $i += 1; } else { return $alias; } } return null; } function contains($namespace_uri) { return $this->isDefined($namespace_uri); } function isDefined($namespace_uri) { return $this->namespace_to_alias->contains($namespace_uri); } } class Auth_OpenID_Message { function Auth_OpenID_Message($openid_namespace = null) { $this->allowed_openid_namespaces = array( Auth_OpenID_OPENID1_NS, Auth_OpenID_THE_OTHER_OPENID1_NS, Auth_OpenID_OPENID2_NS); $this->args = new Auth_OpenID_Mapping(); $this->namespaces = new Auth_OpenID_NamespaceMap(); if ($openid_namespace === null) { $this->_openid_ns_uri = null; } else { $implicit = Auth_OpenID_isOpenID1($openid_namespace); $this->setOpenIDNamespace($openid_namespace, $implicit); } } function isOpenID1() { return Auth_OpenID_isOpenID1($this->getOpenIDNamespace()); } function isOpenID2() { return $this->getOpenIDNamespace() == Auth_OpenID_OPENID2_NS; } static function fromPostArgs($args) { $obj = new Auth_OpenID_Message(); $openid_args = array(); foreach ($args as $key => $value) { if (is_array($value)) { return null; } $parts = explode('.', $key, 2); if (count($parts) == 2) { list($prefix, $rest) = $parts; } else { $prefix = null; } if ($prefix != 'openid') { $obj->args->set(array(Auth_OpenID_BARE_NS, $key), $value); } else { $openid_args[$rest] = $value; } } if ($obj->_fromOpenIDArgs($openid_args)) { return $obj; } else { return null; } } function fromOpenIDArgs($openid_args) { $obj = new Auth_OpenID_Message(); if ($obj->_fromOpenIDArgs($openid_args)) { return $obj; } else { return null; } } function _fromOpenIDArgs($openid_args) { global $Auth_OpenID_registered_aliases; if (!Auth_OpenID_Mapping::isA($openid_args)) { $openid_args = new Auth_OpenID_Mapping($openid_args); } $ns_args = array(); foreach ($openid_args->items() as $pair) { list($rest, $value) = $pair; $parts = explode('.', $rest, 2); if (count($parts) == 2) { list($ns_alias, $ns_key) = $parts; } else { $ns_alias = Auth_OpenID_NULL_NAMESPACE; $ns_key = $rest; } if ($ns_alias == 'ns') { if ($this->namespaces->addAlias($value, $ns_key) === null) { return false; } } else if (($ns_alias == Auth_OpenID_NULL_NAMESPACE) && ($ns_key == 'ns')) { if ($this->setOpenIDNamespace($value, false) === false) { return false; } } else { $ns_args[] = array($ns_alias, $ns_key, $value); } } if (!$this->getOpenIDNamespace()) { if ($this->setOpenIDNamespace(Auth_OpenID_OPENID1_NS, true) === false) { return false; } } foreach ($ns_args as $triple) { list($ns_alias, $ns_key, $value) = $triple; $ns_uri = $this->namespaces->getNamespaceURI($ns_alias); if ($ns_uri === null) { $ns_uri = $this->_getDefaultNamespace($ns_alias); if ($ns_uri === null) { $ns_uri = Auth_OpenID_OPENID_NS; $ns_key = sprintf('%s.%s', $ns_alias, $ns_key); } else { $this->namespaces->addAlias($ns_uri, $ns_alias, true); } } $this->setArg($ns_uri, $ns_key, $value); } return true; } function _getDefaultNamespace($mystery_alias) { global $Auth_OpenID_registered_aliases; if ($this->isOpenID1()) { return @$Auth_OpenID_registered_aliases[$mystery_alias]; } return null; } function setOpenIDNamespace($openid_ns_uri, $implicit) { if (!in_array($openid_ns_uri, $this->allowed_openid_namespaces)) { Auth_OpenID::log('Invalid null namespace: "%s"', $openid_ns_uri); return false; } $succeeded = $this->namespaces->addAlias($openid_ns_uri, Auth_OpenID_NULL_NAMESPACE, $implicit); if ($succeeded === false) { return false; } $this->_openid_ns_uri = $openid_ns_uri; return true; } function getOpenIDNamespace() { return $this->_openid_ns_uri; } function fromKVForm($kvform_string) { return Auth_OpenID_Message::fromOpenIDArgs( Auth_OpenID_KVForm::toArray($kvform_string)); } function copy() { return $this; } function toPostArgs() { $args = array(); foreach ($this->namespaces->iteritems() as $pair) { list($ns_uri, $alias) = $pair; if ($this->namespaces->isImplicit($ns_uri)) { continue; } if ($alias == Auth_OpenID_NULL_NAMESPACE) { $ns_key = 'openid.ns'; } else { $ns_key = 'openid.ns.' . $alias; } $args[$ns_key] = $ns_uri; } foreach ($this->args->items() as $pair) { list($ns_parts, $value) = $pair; list($ns_uri, $ns_key) = $ns_parts; $key = $this->getKey($ns_uri, $ns_key); $args[$key] = $value; } return $args; } function toArgs() { $post_args = $this->toPostArgs(); $kvargs = array(); foreach ($post_args as $k => $v) { if (strpos($k, 'openid.') !== 0) { return null; } else { $kvargs[substr($k, 7)] = $v; } } return $kvargs; } function toFormMarkup($action_url, $form_tag_attrs = null, $submit_text = "Continue") { $form = "<form accept-charset=\"UTF-8\" ". "enctype=\"application/x-www-form-urlencoded\""; if (!$form_tag_attrs) { $form_tag_attrs = array(); } $form_tag_attrs['action'] = $action_url; $form_tag_attrs['method'] = 'post'; unset($form_tag_attrs['enctype']); unset($form_tag_attrs['accept-charset']); if ($form_tag_attrs) { foreach ($form_tag_attrs as $name => $attr) { $form .= sprintf(" %s=\"%s\"", $name, $attr); } } $form .= ">\n"; foreach ($this->toPostArgs() as $name => $value) { $form .= sprintf( "<input type=\"hidden\" name=\"%s\" value=\"%s\" />\n", $name, $value); } $form .= sprintf("<input type=\"submit\" value=\"%s\" />\n", $submit_text); $form .= "</form>\n"; return $form; } function toURL($base_url) { return Auth_OpenID::appendArgs($base_url, $this->toPostArgs()); } function toKVForm() { return Auth_OpenID_KVForm::fromArray($this->toArgs()); } function toURLEncoded() { $args = array(); foreach ($this->toPostArgs() as $k => $v) { $args[] = array($k, $v); } sort($args); return Auth_OpenID::httpBuildQuery($args); } function _fixNS($namespace) { if ($namespace == Auth_OpenID_OPENID_NS) { if ($this->_openid_ns_uri === null) { return new Auth_OpenID_FailureResponse(null, 'OpenID namespace not set'); } else { $namespace = $this->_openid_ns_uri; } } if (($namespace != Auth_OpenID_BARE_NS) && (!is_string($namespace))) { $err_msg = sprintf("Namespace must be Auth_OpenID_BARE_NS, ". "Auth_OpenID_OPENID_NS or a string. got %s", print_r($namespace, true)); return new Auth_OpenID_FailureResponse(null, $err_msg); } if (($namespace != Auth_OpenID_BARE_NS) && (strpos($namespace, ':') === false)) { if ($namespace == 'sreg') { return Auth_OpenID_SREG_URI; } } return $namespace; } function hasKey($namespace, $ns_key) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return false; } else { return $this->args->contains(array($namespace, $ns_key)); } } function getKey($namespace, $ns_key) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } if ($namespace == Auth_OpenID_BARE_NS) { return $ns_key; } $ns_alias = $this->namespaces->getAlias($namespace); if ($ns_alias === null) { return null; } if ($ns_alias == Auth_OpenID_NULL_NAMESPACE) { $tail = $ns_key; } else { $tail = sprintf('%s.%s', $ns_alias, $ns_key); } return 'openid.' . $tail; } function getArg($namespace, $key, $default = null) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { if ((!$this->args->contains(array($namespace, $key))) && ($default == Auth_OpenID_NO_DEFAULT)) { $err_msg = sprintf("Namespace %s missing required field %s", $namespace, $key); return new Auth_OpenID_FailureResponse(null, $err_msg); } else { return $this->args->get(array($namespace, $key), $default); } } } function getArgs($namespace) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { $stuff = array(); foreach ($this->args->items() as $pair) { list($key, $value) = $pair; list($pair_ns, $ns_key) = $key; if ($pair_ns == $namespace) { $stuff[$ns_key] = $value; } } return $stuff; } } function updateArgs($namespace, $updates) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { foreach ($updates as $k => $v) { $this->setArg($namespace, $k, $v); } return true; } } function setArg($namespace, $key, $value) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { $this->args->set(array($namespace, $key), $value); if ($namespace !== Auth_OpenID_BARE_NS) { $this->namespaces->add($namespace); } return true; } } function delArg($namespace, $key) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { return $this->args->del(array($namespace, $key)); } } function getAliasedArg($aliased_key, $default = null) { if ($aliased_key == 'ns') { return $this->getOpenIDNamespace(); } $parts = explode('.', $aliased_key, 2); if (count($parts) != 2) { $ns = null; } else { list($alias, $key) = $parts; if ($alias == 'ns') { return $this->namespaces->getNamespaceURI($key); } else { $ns = $this->namespaces->getNamespaceURI($alias); } } if ($ns === null) { $key = $aliased_key; $ns = $this->getOpenIDNamespace(); } return $this->getArg($ns, $key, $default); } }   function Auth_Yadis_getUCSChars() { return array( array(0xA0, 0xD7FF), array(0xF900, 0xFDCF), array(0xFDF0, 0xFFEF), array(0x10000, 0x1FFFD), array(0x20000, 0x2FFFD), array(0x30000, 0x3FFFD), array(0x40000, 0x4FFFD), array(0x50000, 0x5FFFD), array(0x60000, 0x6FFFD), array(0x70000, 0x7FFFD), array(0x80000, 0x8FFFD), array(0x90000, 0x9FFFD), array(0xA0000, 0xAFFFD), array(0xB0000, 0xBFFFD), array(0xC0000, 0xCFFFD), array(0xD0000, 0xDFFFD), array(0xE1000, 0xEFFFD) ); } function Auth_Yadis_getIPrivateChars() { return array( array(0xE000, 0xF8FF), array(0xF0000, 0xFFFFD), array(0x100000, 0x10FFFD) ); } function Auth_Yadis_pct_escape_unicode($char_match) { $c = $char_match[0]; $result = ""; for ($i = 0; $i < strlen($c); $i++) { $result .= "%".sprintf("%X", ord($c[$i])); } return $result; } function Auth_Yadis_startswith($s, $stuff) { return strpos($s, $stuff) === 0; }   define('Auth_OpenID_Nonce_CHRS',"abcdefghijklmnopqrstuvwxyz" . "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"); global $Auth_OpenID_SKEW; $Auth_OpenID_SKEW = 60 * 60 * 5; define('Auth_OpenID_Nonce_REGEX', '/(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z(.*)/'); define('Auth_OpenID_Nonce_TIME_FMT', '%Y-%m-%dT%H:%M:%SZ'); function Auth_OpenID_splitNonce($nonce_string) { $result = preg_match(Auth_OpenID_Nonce_REGEX, $nonce_string, $matches); if ($result != 1 || count($matches) != 8) { return null; } list($unused, $tm_year, $tm_mon, $tm_mday, $tm_hour, $tm_min, $tm_sec, $uniquifier) = $matches; $timestamp = @gmmktime($tm_hour, $tm_min, $tm_sec, $tm_mon, $tm_mday, $tm_year); if ($timestamp === false || $timestamp < 0) { return null; } return array($timestamp, $uniquifier); } function Auth_OpenID_checkTimestamp($nonce_string, $allowed_skew = null, $now = null) { global $Auth_OpenID_SKEW; if ($allowed_skew === null) { $allowed_skew = $Auth_OpenID_SKEW; } $parts = Auth_OpenID_splitNonce($nonce_string); if ($parts == null) { return false; } if ($now === null) { $now = time(); } $stamp = $parts[0]; $past = $now - $allowed_skew; $future = $now + $allowed_skew; return (($past <= $stamp) && ($stamp <= $future)); } function Auth_OpenID_mkNonce($when = null) { $salt = Auth_OpenID_CryptUtil::randomString( 6, Auth_OpenID_Nonce_CHRS); if ($when === null) { $when = time(); } $time_str = gmstrftime(Auth_OpenID_Nonce_TIME_FMT, $when); return $time_str . $salt; }   class Auth_OpenID_Parse { var $_re_flags = "si"; var $_removed_re = "<!--.*?-->|<!\[CDATA\[.*?\]\]>|<script\b(?!:)[^>]*>.*?<\/script>"; var $_tag_expr = "<%s\b(?!:)([^>]*?)(?:\/>|>(.*?)(?:<\/?%s\s*>|\Z))"; var $_attr_find = '\b(\w+)=("[^"]*"|\'[^\']*\'|[^\'"\s\/<>]+)'; var $_open_tag_expr = "<%s\b"; var $_close_tag_expr = "<((\/%s\b)|(%s[^>\/]*\/))>"; function Auth_OpenID_Parse() { $this->_link_find = sprintf("/<link\b(?!:)([^>]*)(?!<)>/%s", $this->_re_flags); $this->_entity_replacements = array( 'amp' => '&', 'lt' => '<', 'gt' => '>', 'quot' => '"' ); $this->_attr_find = sprintf("/%s/%s", $this->_attr_find, $this->_re_flags); $this->_removed_re = sprintf("/%s/%s", $this->_removed_re, $this->_re_flags); $this->_ent_replace = sprintf("&(%s);", implode("|", $this->_entity_replacements)); } function tagMatcher($tag_name, $close_tags = null) { $expr = $this->_tag_expr; if ($close_tags) { $options = implode("|", array_merge(array($tag_name), $close_tags)); $closer = sprintf("(?:%s)", $options); } else { $closer = $tag_name; } $expr = sprintf($expr, $tag_name, $closer); return sprintf("/%s/%s", $expr, $this->_re_flags); } function openTag($tag_name) { $expr = sprintf($this->_open_tag_expr, $tag_name); return sprintf("/%s/%s", $expr, $this->_re_flags); } function closeTag($tag_name) { $expr = sprintf($this->_close_tag_expr, $tag_name, $tag_name); return sprintf("/%s/%s", $expr, $this->_re_flags); } function htmlBegin($s) { $matches = array(); $result = preg_match($this->openTag('html'), $s, $matches, PREG_OFFSET_CAPTURE); if ($result === false || !$matches) { return false; } return $matches[0][1]; } function htmlEnd($s) { $matches = array(); $result = preg_match($this->closeTag('html'), $s, $matches, PREG_OFFSET_CAPTURE); if ($result === false || !$matches) { return false; } return $matches[count($matches) - 1][1]; } function headFind() { return $this->tagMatcher('head', array('body', 'html')); } function replaceEntities($str) { foreach ($this->_entity_replacements as $old => $new) { $str = preg_replace(sprintf("/&%s;/", $old), $new, $str); } return $str; } function removeQuotes($str) { $matches = array(); $double = '/^"(.*)"$/'; $single = "/^\'(.*)\'$/"; if (preg_match($double, $str, $matches)) { return $matches[1]; } else if (preg_match($single, $str, $matches)) { return $matches[1]; } else { return $str; } } function parseLinkAttrs($html) { $stripped = preg_replace($this->_removed_re, "", $html); $html_begin = $this->htmlBegin($stripped); $html_end = $this->htmlEnd($stripped); if ($html_begin === false) { return array(); } if ($html_end === false) { $html_end = strlen($stripped); } $stripped = substr($stripped, $html_begin, $html_end - $html_begin); $head_re = $this->headFind(); $head_matches = array(); if (!preg_match($head_re, $stripped, $head_matches)) { return array(); } $link_data = array(); $link_matches = array(); if (!preg_match_all($this->_link_find, $head_matches[0], $link_matches)) { return array(); } foreach ($link_matches[0] as $link) { $attr_matches = array(); preg_match_all($this->_attr_find, $link, $attr_matches); $link_attrs = array(); foreach ($attr_matches[0] as $index => $full_match) { $name = $attr_matches[1][$index]; $value = $this->replaceEntities( $this->removeQuotes($attr_matches[2][$index])); $link_attrs[strtolower($name)] = $value; } $link_data[] = $link_attrs; } return $link_data; } function relMatches($rel_attr, $target_rel) { $rels = preg_split("/\s+/", trim($rel_attr)); foreach ($rels as $rel) { $rel = strtolower($rel); if ($rel == $target_rel) { return 1; } } return 0; } function linkHasRel($link_attrs, $target_rel) { $rel_attr = Auth_OpeniD::arrayGet($link_attrs, 'rel', null); return ($rel_attr && $this->relMatches($rel_attr, $target_rel)); } function findLinksRel($link_attrs_list, $target_rel) { $result = array(); foreach ($link_attrs_list as $attr) { if ($this->linkHasRel($attr, $target_rel)) { $result[] = $attr; } } return $result; } function findFirstHref($link_attrs_list, $target_rel) { $matches = $this->findLinksRel($link_attrs_list, $target_rel); if (!$matches) { return null; } $first = $matches[0]; return Auth_OpenID::arrayGet($first, 'href', null); } } function Auth_OpenID_legacy_discover($html_text, $server_rel, $delegate_rel) { $p = new Auth_OpenID_Parse(); $link_attrs = $p->parseLinkAttrs($html_text); $server_url = $p->findFirstHref($link_attrs, $server_rel); if ($server_url === null) { return false; } else { $delegate_url = $p->findFirstHref($link_attrs, $delegate_rel); return array($delegate_url, $server_url); } }   class Auth_Yadis_ParseHTML { var $_re_flags = "si"; var $_removed_re = "<!--.*?-->|<!\[CDATA\[.*?\]\]>|<script\b(?!:)[^>]*>.*?<\/script>"; var $_tag_expr = "<%s%s(?:\s.*?)?%s>"; var $_attr_find = '\b([-\w]+)=(".*?"|\'.*?\'|.+?)[\/\s>]'; function Auth_Yadis_ParseHTML() { $this->_attr_find = sprintf("/%s/%s", $this->_attr_find, $this->_re_flags); $this->_removed_re = sprintf("/%s/%s", $this->_removed_re, $this->_re_flags); $this->_entity_replacements = array( 'amp' => '&', 'lt' => '<', 'gt' => '>', 'quot' => '"' ); $this->_ent_replace = sprintf("&(%s);", implode("|", $this->_entity_replacements)); } function replaceEntities($str) { foreach ($this->_entity_replacements as $old => $new) { $str = preg_replace(sprintf("/&%s;/", $old), $new, $str); } $str = preg_replace('~&#x([0-9a-f]+);~ei', 'chr(hexdec("\\1"))', $str); $str = preg_replace('~&#([0-9]+);~e', 'chr(\\1)', $str); return $str; } function removeQuotes($str) { $matches = array(); $double = '/^"(.*)"$/'; $single = "/^\'(.*)\'$/"; if (preg_match($double, $str, $matches)) { return $matches[1]; } else if (preg_match($single, $str, $matches)) { return $matches[1]; } else { return $str; } } function tagPattern($tag_names, $close, $self_close) { if (is_array($tag_names)) { $tag_names = '(?:'.implode('|',$tag_names).')'; } if ($close) { $close = '\/' . (($close == 1)? '' : '?'); } else { $close = ''; } if ($self_close) { $self_close = '(?:\/\s*)' . (($self_close == 1)? '' : '?'); } else { $self_close = ''; } $expr = sprintf($this->_tag_expr, $close, $tag_names, $self_close); return sprintf("/%s/%s", $expr, $this->_re_flags); } function getMetaTags($html_string) { $html_string = preg_replace($this->_removed_re, "", $html_string); $key_tags = array($this->tagPattern('html', false, false), $this->tagPattern('head', false, false), $this->tagPattern('head', true, false), $this->tagPattern('html', true, false), $this->tagPattern(array( 'body', 'frameset', 'frame', 'p', 'div', 'table','span','a'), 'maybe', 'maybe')); $key_tags_pos = array(); foreach ($key_tags as $pat) { $matches = array(); preg_match($pat, $html_string, $matches, PREG_OFFSET_CAPTURE); if($matches) { $key_tags_pos[] = $matches[0][1]; } else { $key_tags_pos[] = null; } } if (is_null($key_tags_pos[1])) { return array(); } if (is_null($key_tags_pos[2])) { $key_tags_pos[2] = strlen($html_string); } foreach (array($key_tags_pos[3], $key_tags_pos[4]) as $pos) { if (!is_null($pos) && $pos < $key_tags_pos[2]) { $key_tags_pos[2] = $pos; } } if ($key_tags_pos[1] > $key_tags_pos[2]) { return array(); } if (!is_null($key_tags_pos[0]) && $key_tags_pos[1] < $key_tags_pos[0]) { return array(); } $html_string = substr($html_string, $key_tags_pos[1], ($key_tags_pos[2]-$key_tags_pos[1])); $link_data = array(); $link_matches = array(); if (!preg_match_all($this->tagPattern('meta', false, 'maybe'), $html_string, $link_matches)) { return array(); } foreach ($link_matches[0] as $link) { $attr_matches = array(); preg_match_all($this->_attr_find, $link, $attr_matches); $link_attrs = array(); foreach ($attr_matches[0] as $index => $full_match) { $name = $attr_matches[1][$index]; $value = $this->replaceEntities( $this->removeQuotes($attr_matches[2][$index])); $link_attrs[strtolower($name)] = $value; } $link_data[] = $link_attrs; } return $link_data; } function getHTTPEquiv($html_string) { $meta_tags = $this->getMetaTags($html_string); if ($meta_tags) { foreach ($meta_tags as $tag) { if (array_key_exists('http-equiv', $tag) && (in_array(strtolower($tag['http-equiv']), array('x-xrds-location', 'x-yadis-location'))) && array_key_exists('content', $tag)) { return $tag['content']; } } } return null; } }   global $Auth_OpenID_sreg_data_fields; $Auth_OpenID_sreg_data_fields = array( 'fullname' => 'Full Name', 'nickname' => 'Nickname', 'dob' => 'Date of Birth', 'email' => 'E-mail Address', 'gender' => 'Gender', 'postcode' => 'Postal Code', 'country' => 'Country', 'language' => 'Language', 'timezone' => 'Time Zone'); function Auth_OpenID_checkFieldName($field_name) { global $Auth_OpenID_sreg_data_fields; if (!in_array($field_name, array_keys($Auth_OpenID_sreg_data_fields))) { return false; } return true; } define('Auth_OpenID_SREG_NS_URI_1_0', 'http://openid.net/sreg/1.0'); define('Auth_OpenID_SREG_NS_URI_1_1', 'http://openid.net/extensions/sreg/1.1'); define('Auth_OpenID_SREG_NS_URI', Auth_OpenID_SREG_NS_URI_1_1); Auth_OpenID_registerNamespaceAlias(Auth_OpenID_SREG_NS_URI_1_1, 'sreg'); function Auth_OpenID_supportsSReg(&$endpoint) { return ($endpoint->usesExtension(Auth_OpenID_SREG_NS_URI_1_1) || $endpoint->usesExtension(Auth_OpenID_SREG_NS_URI_1_0)); } class Auth_OpenID_SRegBase extends Auth_OpenID_Extension { function _getSRegNS(&$message) { $alias = null; $found_ns_uri = null; foreach (array(Auth_OpenID_SREG_NS_URI_1_1, Auth_OpenID_SREG_NS_URI_1_0) as $sreg_ns_uri) { $alias = $message->namespaces->getAlias($sreg_ns_uri); if ($alias !== null) { $found_ns_uri = $sreg_ns_uri; break; } } if ($alias === null) { $found_ns_uri = Auth_OpenID_SREG_NS_URI_1_1; if ($message->namespaces->addAlias(Auth_OpenID_SREG_NS_URI_1_1, 'sreg') === null) { return null; } } return $found_ns_uri; } } class Auth_OpenID_SRegRequest extends Auth_OpenID_SRegBase { var $ns_alias = 'sreg'; function build($required=null, $optional=null, $policy_url=null, $sreg_ns_uri=Auth_OpenID_SREG_NS_URI, $cls='Auth_OpenID_SRegRequest') { $obj = new $cls(); $obj->required = array(); $obj->optional = array(); $obj->policy_url = $policy_url; $obj->ns_uri = $sreg_ns_uri; if ($required) { if (!$obj->requestFields($required, true, true)) { return null; } } if ($optional) { if (!$obj->requestFields($optional, false, true)) { return null; } } return $obj; } function fromOpenIDRequest($request, $cls='Auth_OpenID_SRegRequest') { $obj = call_user_func_array(array($cls, 'build'), array(null, null, null, Auth_OpenID_SREG_NS_URI, $cls)); $m = $request->message; $obj->ns_uri = $obj->_getSRegNS($m); $args = $m->getArgs($obj->ns_uri); if ($args === null || Auth_OpenID::isFailure($args)) { return null; } $obj->parseExtensionArgs($args); return $obj; } function parseExtensionArgs($args, $strict=false) { foreach (array('required', 'optional') as $list_name) { $required = ($list_name == 'required'); $items = Auth_OpenID::arrayGet($args, $list_name); if ($items) { foreach (explode(',', $items) as $field_name) { if (!$this->requestField($field_name, $required, $strict)) { if ($strict) { return false; } } } } } $this->policy_url = Auth_OpenID::arrayGet($args, 'policy_url'); return true; } function allRequestedFields() { return array_merge($this->required, $this->optional); } function wereFieldsRequested() { return count($this->allRequestedFields()); } function contains($field_name) { return (in_array($field_name, $this->required) || in_array($field_name, $this->optional)); } function requestField($field_name, $required=false, $strict=false) { if (!Auth_OpenID_checkFieldName($field_name)) { return false; } if ($strict) { if ($this->contains($field_name)) { return false; } } else { if (in_array($field_name, $this->required)) { return true; } if (in_array($field_name, $this->optional)) { if ($required) { unset($this->optional[array_search($field_name, $this->optional)]); } else { return true; } } } if ($required) { $this->required[] = $field_name; } else { $this->optional[] = $field_name; } return true; } function requestFields($field_names, $required=false, $strict=false) { if (!is_array($field_names)) { return false; } foreach ($field_names as $field_name) { if (!$this->requestField($field_name, $required, $strict=$strict)) { return false; } } return true; } function getExtensionArgs() { $args = array(); if ($this->required) { $args['required'] = implode(',', $this->required); } if ($this->optional) { $args['optional'] = implode(',', $this->optional); } if ($this->policy_url) { $args['policy_url'] = $this->policy_url; } return $args; } } class Auth_OpenID_SRegResponse extends Auth_OpenID_SRegBase { var $ns_alias = 'sreg'; function Auth_OpenID_SRegResponse($data=null, $sreg_ns_uri=Auth_OpenID_SREG_NS_URI) { if ($data === null) { $this->data = array(); } else { $this->data = $data; } $this->ns_uri = $sreg_ns_uri; } function extractResponse($request, $data) { $obj = new Auth_OpenID_SRegResponse(); $obj->ns_uri = $request->ns_uri; foreach ($request->allRequestedFields() as $field) { $value = Auth_OpenID::arrayGet($data, $field); if ($value !== null) { $obj->data[$field] = $value; } } return $obj; } static function fromSuccessResponse(&$success_response, $signed_only=true) { global $Auth_OpenID_sreg_data_fields; $obj = new Auth_OpenID_SRegResponse(); $obj->ns_uri = $obj->_getSRegNS($success_response->message); if ($signed_only) { $args = $success_response->getSignedNS($obj->ns_uri); } else { $args = $success_response->message->getArgs($obj->ns_uri); } if ($args === null || Auth_OpenID::isFailure($args)) { return null; } foreach ($Auth_OpenID_sreg_data_fields as $field_name => $desc) { if (in_array($field_name, array_keys($args))) { $obj->data[$field_name] = $args[$field_name]; } } return $obj; } function getExtensionArgs() { return $this->data; } function get($field_name, $default=null) { if (!Auth_OpenID_checkFieldName($field_name)) { return null; } return Auth_OpenID::arrayGet($this->data, $field_name, $default); } function contents() { return $this->data; } }   function Auth_OpenID_getURIPattern() { return '&^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?&'; } function Auth_OpenID_getAuthorityPattern() { return '/^([^@]*@)?([^:]*)(:.*)?/'; } function Auth_OpenID_getEncodedPattern() { return '/%([0-9A-Fa-f]{2})/'; } function Auth_OpenID_getURLIllegalCharRE() { return "/([^-A-Za-z0-9:\/\?#\[\]@\!\$&'\(\)\*\+,;=\._~\%])/"; } function Auth_OpenID_getUnreserved() { $_unreserved = array(); for ($i = 0; $i < 256; $i++) { $_unreserved[$i] = false; } for ($i = ord('A'); $i <= ord('Z'); $i++) { $_unreserved[$i] = true; } for ($i = ord('0'); $i <= ord('9'); $i++) { $_unreserved[$i] = true; } for ($i = ord('a'); $i <= ord('z'); $i++) { $_unreserved[$i] = true; } $_unreserved[ord('-')] = true; $_unreserved[ord('.')] = true; $_unreserved[ord('_')] = true; $_unreserved[ord('~')] = true; return $_unreserved; } function Auth_OpenID_getEscapeRE() { $parts = array(); foreach (array_merge(Auth_Yadis_getUCSChars(), Auth_Yadis_getIPrivateChars()) as $pair) { list($m, $n) = $pair; $parts[] = sprintf("%s-%s", chr($m), chr($n)); } return sprintf('[%s]', implode('', $parts)); } function Auth_OpenID_pct_encoded_replace_unreserved($mo) { $_unreserved = Auth_OpenID_getUnreserved(); $i = intval($mo[1], 16); if ($_unreserved[$i]) { return chr($i); } else { return strtoupper($mo[0]); } return $mo[0]; } function Auth_OpenID_pct_encoded_replace($mo) { return chr(intval($mo[1], 16)); } function Auth_OpenID_remove_dot_segments($path) { $result_segments = array(); while ($path) { if (Auth_Yadis_startswith($path, '../')) { $path = substr($path, 3); } else if (Auth_Yadis_startswith($path, './')) { $path = substr($path, 2); } else if (Auth_Yadis_startswith($path, '/./')) { $path = substr($path, 2); } else if ($path == '/.') { $path = '/'; } else if (Auth_Yadis_startswith($path, '/../')) { $path = substr($path, 3); if ($result_segments) { array_pop($result_segments); } } else if ($path == '/..') { $path = '/'; if ($result_segments) { array_pop($result_segments); } } else if (($path == '..') || ($path == '.')) { $path = ''; } else { $i = 0; if ($path[0] == '/') { $i = 1; } $i = strpos($path, '/', $i); if ($i === false) { $i = strlen($path); } $result_segments[] = substr($path, 0, $i); $path = substr($path, $i); } } return implode('', $result_segments); } function Auth_OpenID_urinorm($uri) { $uri_matches = array(); preg_match(Auth_OpenID_getURIPattern(), $uri, $uri_matches); if (count($uri_matches) < 9) { for ($i = count($uri_matches); $i <= 9; $i++) { $uri_matches[] = ''; } } $illegal_matches = array(); preg_match(Auth_OpenID_getURLIllegalCharRE(), $uri, $illegal_matches); if ($illegal_matches) { return null; } $scheme = $uri_matches[2]; if ($scheme) { $scheme = strtolower($scheme); } $scheme = $uri_matches[2]; if ($scheme === '') { return null; } $scheme = strtolower($scheme); if (!in_array($scheme, array('http', 'https'))) { return null; } $authority = $uri_matches[4]; if ($authority === '') { return null; } $authority_matches = array(); preg_match(Auth_OpenID_getAuthorityPattern(), $authority, $authority_matches); if (count($authority_matches) === 0) { return null; } if (count($authority_matches) < 4) { for ($i = count($authority_matches); $i <= 4; $i++) { $authority_matches[] = ''; } } list($_whole, $userinfo, $host, $port) = $authority_matches; if ($userinfo === null) { $userinfo = ''; } if (strpos($host, '%') !== -1) { $host = strtolower($host); $host = preg_replace_callback( Auth_OpenID_getEncodedPattern(), 'Auth_OpenID_pct_encoded_replace', $host); } else { $host = strtolower($host); } if ($port) { if (($port == ':') || ($scheme == 'http' && $port == ':80') || ($scheme == 'https' && $port == ':443')) { $port = ''; } } else { $port = ''; } $authority = $userinfo . $host . $port; $path = $uri_matches[5]; $path = preg_replace_callback( Auth_OpenID_getEncodedPattern(), 'Auth_OpenID_pct_encoded_replace_unreserved', $path); $path = Auth_OpenID_remove_dot_segments($path); if (!$path) { $path = '/'; } $query = $uri_matches[6]; if ($query === null) { $query = ''; } $fragment = $uri_matches[8]; if ($fragment === null) { $fragment = ''; } return $scheme . '://' . $authority . $path . $query . $fragment; }   class Auth_Yadis_XMLParser { function init($xml_string, $namespace_map) { if (!$this->setXML($xml_string)) { return false; } foreach ($namespace_map as $prefix => $uri) { if (!$this->registerNamespace($prefix, $uri)) { return false; } } return true; } function registerNamespace($prefix, $uri) { } function setXML($xml_string) { } function &evalXPath($xpath, $node = null) { } function content($node) { } function attributes($node) { } } class Auth_Yadis_domxml extends Auth_Yadis_XMLParser { function Auth_Yadis_domxml() { $this->xml = null; $this->doc = null; $this->xpath = null; $this->errors = array(); } function setXML($xml_string) { $this->xml = $xml_string; $this->doc = @domxml_open_mem($xml_string, DOMXML_LOAD_PARSING, $this->errors); if (!$this->doc) { return false; } $this->xpath = $this->doc->xpath_new_context(); return true; } function registerNamespace($prefix, $uri) { return xpath_register_ns($this->xpath, $prefix, $uri); } function &evalXPath($xpath, $node = null) { if ($node) { $result = @$this->xpath->xpath_eval($xpath, $node); } else { $result = @$this->xpath->xpath_eval($xpath); } if (!$result) { $n = array(); return $n; } if (!$result->nodeset) { $n = array(); return $n; } return $result->nodeset; } function content($node) { if ($node) { return $node->get_content(); } } function attributes($node) { if ($node) { $arr = $node->attributes(); $result = array(); if ($arr) { foreach ($arr as $attrnode) { $result[$attrnode->name] = $attrnode->value; } } return $result; } } } class Auth_Yadis_dom extends Auth_Yadis_XMLParser { function Auth_Yadis_dom() { $this->xml = null; $this->doc = null; $this->xpath = null; $this->errors = array(); } function setXML($xml_string) { $this->xml = $xml_string; $this->doc = new DOMDocument; if (!$this->doc) { return false; } if (!@$this->doc->loadXML($xml_string)) { return false; } $this->xpath = new DOMXPath($this->doc); if ($this->xpath) { return true; } else { return false; } } function registerNamespace($prefix, $uri) { return $this->xpath->registerNamespace($prefix, $uri); } function &evalXPath($xpath, $node = null) { if ($node) { $result = @$this->xpath->query($xpath, $node); } else { $result = @$this->xpath->query($xpath); } $n = array(); if (!$result) { return $n; } for ($i = 0; $i < $result->length; $i++) { $n[] = $result->item($i); } return $n; } function content($node) { if ($node) { return $node->textContent; } } function attributes($node) { if ($node) { $arr = $node->attributes; $result = array(); if ($arr) { for ($i = 0; $i < $arr->length; $i++) { $node = $arr->item($i); $result[$node->nodeName] = $node->nodeValue; } } return $result; } } } global $__Auth_Yadis_defaultParser; $__Auth_Yadis_defaultParser = null; function Auth_Yadis_setDefaultParser(&$parser) { global $__Auth_Yadis_defaultParser; $__Auth_Yadis_defaultParser =& $parser; } function Auth_Yadis_getSupportedExtensions() { return array( 'dom' => array('classname' => 'Auth_Yadis_dom', 'libname' => array('dom.so', 'dom.dll')), 'domxml' => array('classname' => 'Auth_Yadis_domxml', 'libname' => array('domxml.so', 'php_domxml.dll')), ); } function &Auth_Yadis_getXMLParser() { global $__Auth_Yadis_defaultParser; if (isset($__Auth_Yadis_defaultParser)) { return $__Auth_Yadis_defaultParser; } $p = null; $classname = null; $extensions = Auth_Yadis_getSupportedExtensions(); foreach ($extensions as $name => $params) { if (!extension_loaded($name)) { foreach ($params['libname'] as $libname) { if (@dl($libname)) { $classname = $params['classname']; } } } else { $classname = $params['classname']; } if (isset($classname)) { $p = new $classname(); return $p; } } if (!isset($p)) { trigger_error('No XML parser was found', E_USER_ERROR); } else { Auth_Yadis_setDefaultParser($p); } return $p; }   function Auth_Yadis_getDefaultProxy() { return 'http://xri.net/'; } function Auth_Yadis_getXRIAuthorities() { return array('!', '=', '@', '+', '$', '('); } function Auth_Yadis_getEscapeRE() { $parts = array(); foreach (array_merge(Auth_Yadis_getUCSChars(), Auth_Yadis_getIPrivateChars()) as $pair) { list($m, $n) = $pair; $parts[] = sprintf("%s-%s", chr($m), chr($n)); } return sprintf('/[%s]/', implode('', $parts)); } function Auth_Yadis_getXrefRE() { return '/\((.*?)\)/'; } function Auth_Yadis_identifierScheme($identifier) { if (Auth_Yadis_startswith($identifier, 'xri://') || ($identifier && in_array($identifier[0], Auth_Yadis_getXRIAuthorities()))) { return "XRI"; } else { return "URI"; } } function Auth_Yadis_toIRINormal($xri) { if (!Auth_Yadis_startswith($xri, 'xri://')) { $xri = 'xri://' . $xri; } return Auth_Yadis_escapeForIRI($xri); } function _escape_xref($xref_match) { $xref = $xref_match[0]; $xref = str_replace('/', '%2F', $xref); $xref = str_replace('?', '%3F', $xref); $xref = str_replace('#', '%23', $xref); return $xref; } function Auth_Yadis_escapeForIRI($xri) { $xri = str_replace('%', '%25', $xri); $xri = preg_replace_callback(Auth_Yadis_getXrefRE(), '_escape_xref', $xri); return $xri; } function Auth_Yadis_toURINormal($xri) { return Auth_Yadis_iriToURI(Auth_Yadis_toIRINormal($xri)); } function Auth_Yadis_iriToURI($iri) { if (1) { return $iri; } else { return preg_replace_callback(Auth_Yadis_getEscapeRE(), 'Auth_Yadis_pct_escape_unicode', $iri); } } function Auth_Yadis_XRIAppendArgs($url, $args) { if (count($args) == 0) { return $url; } if (array_key_exists(0, $args) && is_array($args[0])) { } else { $keys = array_keys($args); sort($keys); $new_args = array(); foreach ($keys as $key) { $new_args[] = array($key, $args[$key]); } $args = $new_args; } if (strpos(rtrim($url, '?'), '?') !== false) { $sep = '&'; } else { $sep = '?'; } return $url . $sep . Auth_OpenID::httpBuildQuery($args); } function Auth_Yadis_providerIsAuthoritative($providerID, $canonicalID) { $lastbang = strrpos($canonicalID, '!'); $p = substr($canonicalID, 0, $lastbang); return $p == $providerID; } function Auth_Yadis_rootAuthority($xri) { $root = null; if (Auth_Yadis_startswith($xri, 'xri://')) { $xri = substr($xri, 6); } $authority = explode('/', $xri, 2); $authority = $authority[0]; if ($authority[0] == '(') { $root = substr($authority, 0, strpos($authority, ')') + 1); } else if (in_array($authority[0], Auth_Yadis_getXRIAuthorities())) { $root = $authority[0]; } else { $_segments = explode("!", $authority); $segments = array(); foreach ($_segments as $s) { $segments = array_merge($segments, explode("*", $s)); } $root = $segments[0]; } return Auth_Yadis_XRI($root); } function Auth_Yadis_XRI($xri) { if (!Auth_Yadis_startswith($xri, 'xri://')) { $xri = 'xri://' . $xri; } return $xri; } function Auth_Yadis_getCanonicalID($iname, $xrds) { $xrd_list = array_reverse($xrds->allXrdNodes); $parser =& $xrds->parser; $node = $xrd_list[0]; $canonicalID_nodes = $parser->evalXPath('xrd:CanonicalID', $node); if (!$canonicalID_nodes) { return false; } $canonicalID = $canonicalID_nodes[0]; $canonicalID = Auth_Yadis_XRI($parser->content($canonicalID)); $childID = $canonicalID; for ($i = 1; $i < count($xrd_list); $i++) { $xrd = $xrd_list[$i]; $parent_sought = substr($childID, 0, strrpos($childID, '!')); $parentCID = $parser->evalXPath('xrd:CanonicalID', $xrd); if (!$parentCID) { return false; } $parentCID = Auth_Yadis_XRI($parser->content($parentCID[0])); if (strcasecmp($parent_sought, $parentCID)) { return false; } $childID = $parent_sought; } $root = Auth_Yadis_rootAuthority($iname); if (!Auth_Yadis_providerIsAuthoritative($root, $childID)) { return false; } return $canonicalID; } ?>