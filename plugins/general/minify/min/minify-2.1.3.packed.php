<?php  class Minify_Cache_APC { public function __construct($expire = 0) { $this->_exp = $expire; } public function store($id, $data) { return apc_store($id, "{$_SERVER['REQUEST_TIME']}|{$data}", $this->_exp); } public function getSize($id) { return $this->_fetch($id) ? strlen($this->_data) : false; } public function isValid($id, $srcMtime) { return ($this->_fetch($id) && ($this->_lm >= $srcMtime)); } public function display($id) { echo $this->_fetch($id) ? $this->_data : ''; } public function fetch($id) { return $this->_fetch($id) ? $this->_data : ''; } private $_exp = null; private $_lm = null; private $_data = null; private $_id = null; private function _fetch($id) { if ($this->_id === $id) { return true; } $ret = apc_fetch($id); if (false === $ret) { $this->_id = null; return false; } list($this->_lm, $this->_data) = explode('|', $ret, 2); $this->_id = $id; return true; } }   abstract class Minify_Controller_Base { abstract public function setupSources($options); public function getDefaultMinifyOptions() { return array( 'isPublic' => true ,'encodeOutput' => function_exists('gzdeflate') ,'encodeMethod' => null ,'encodeLevel' => 9 ,'minifierOptions' => array() ,'contentTypeCharset' => 'utf-8' ,'maxAge' => 1800 ,'rewriteCssUris' => true ,'bubbleCssImports' => false ,'quiet' => false ,'debug' => false ,'badRequestHeader' => 'HTTP/1.0 400 Bad Request' ,'postprocessor' => null ,'postprocessorRequire' => null ); } public function getDefaultMinifers() { $ret[Minify::TYPE_JS] = array('JSMin', 'minify'); $ret[Minify::TYPE_CSS] = array('Minify_CSS', 'minify'); $ret[Minify::TYPE_HTML] = array('Minify_HTML', 'minify'); return $ret; } public function loadMinifier($minifierCallback) { if (is_array($minifierCallback) && is_string($minifierCallback[0]) && !class_exists($minifierCallback[0], false)) { } } public static function _fileIsSafe($file, $safeDirs) { $pathOk = false; foreach ((array)$safeDirs as $safeDir) { if (strpos($file, $safeDir) === 0) { $pathOk = true; break; } } $base = basename($file); if (! $pathOk || ! is_file($file) || $base[0] === '.') { return false; } list($revExt) = explode('.', strrev($base)); return in_array(strrev($revExt), array('js', 'css', 'html', 'txt')); } public $sources = array(); public final function mixInDefaultOptions($options) { $ret = array_merge( $this->getDefaultMinifyOptions(), $options ); if (! isset($options['minifiers'])) { $options['minifiers'] = array(); } $ret['minifiers'] = array_merge( $this->getDefaultMinifers(), $options['minifiers'] ); return $ret; } public final function analyzeSources($options = array()) { if ($this->sources) { if (! isset($options['contentType'])) { $options['contentType'] = Minify_Source::getContentType($this->sources); } if (! isset($options['lastModifiedTime'])) { $max = 0; foreach ($this->sources as $source) { $max = max($source->lastModified, $max); } $options['lastModifiedTime'] = $max; } } return $options; } protected function log($msg) { Minify_Logger::log($msg); } }   class Minify_Build { public $lastModified = 0; public static $ampersand = '&amp;'; public function uri($uri, $forceAmpersand = false) { $sep = ($forceAmpersand || strpos($uri, '?') !== false) ? self::$ampersand : '?'; return "{$uri}{$sep}{$this->lastModified}"; } public function __construct($sources) { $max = 0; foreach ((array)$sources as $source) { if ($source instanceof Minify_Source) { $max = max($max, $source->lastModified); } elseif (is_string($source)) { if (0 === strpos($source, '//')) { $source = $_SERVER['DOCUMENT_ROOT'] . substr($source, 1); } if (is_file($source)) { $max = max($max, filemtime($source)); } } } $this->lastModified = $max; } }   class Minify_CommentPreserver { public static $prepend = "\n"; public static $append = "\n"; public static function process($content, $processor, $args = array()) { $ret = ''; while (true) { list($beforeComment, $comment, $afterComment) = self::_nextComment($content); if ('' !== $beforeComment) { $callArgs = $args; array_unshift($callArgs, $beforeComment); $ret .= call_user_func_array($processor, $callArgs); } if (false === $comment) { break; } $ret .= $comment; $content = $afterComment; } return $ret; } private static function _nextComment($in) { if ( false === ($start = strpos($in, '/*!')) || false === ($end = strpos($in, '*/', $start + 3)) ) { return array($in, false, false); } $ret = array( substr($in, 0, $start) ,self::$prepend . '/*' . substr($in, $start + 3, $end - $start - 1) . self::$append ); $endChars = (strlen($in) - $end - 2); $ret[] = (0 === $endChars) ? '' : substr($in, -$endChars); return $ret; } }   class Minify_CSS_Compressor { public static function process($css, $options = array()) { $obj = new Minify_CSS_Compressor($options); return $obj->_process($css); } protected $_options = null; protected $_inHack = false; private function __construct($options) { $this->_options = $options; } protected function _process($css) { $css = str_replace("\r\n", "\n", $css); $css = preg_replace('@>/\\*\\s*\\*/@', '>/*keep*/', $css); $css = preg_replace('@/\\*\\s*\\*/\\s*:@', '/*keep*/:', $css); $css = preg_replace('@:\\s*/\\*\\s*\\*/@', ':/*keep*/', $css); $css = preg_replace_callback('@\\s*/\\*([\\s\\S]*?)\\*/\\s*@' ,array($this, '_commentCB'), $css); $css = preg_replace('/\\s*{\\s*/', '{', $css); $css = preg_replace('/;?\\s*}\\s*/', '}', $css); $css = preg_replace('/\\s*;\\s*/', ';', $css); $css = preg_replace('/
                url\\(      # url(
                \\s*
                ([^\\)]+?)  # 1 = the URL (really just a bunch of non right parenthesis)
                \\s*
                \\)         # )
            /x', 'url($1)', $css); $css = preg_replace('/
                \\s*
                ([{;])              # 1 = beginning of block or rule separator 
                \\s*
                ([\\*_]?[\\w\\-]+)  # 2 = property (and maybe IE filter)
                \\s*
                :
                \\s*
                (\\b|[#\'"])        # 3 = first character of a value
            /x', '$1$2:$3', $css); $css = preg_replace_callback('/
                (?:              # non-capture
                    \\s*
                    [^~>+,\\s]+  # selector part
                    \\s*
                    [,>+~]       # combinators
                )+
                \\s*
                [^~>+,\\s]+      # selector part
                {                # open declaration block
            /x' ,array($this, '_selectorsCB'), $css); $css = preg_replace('/([^=])#([a-f\\d])\\2([a-f\\d])\\3([a-f\\d])\\4([\\s;\\}])/i' , '$1#$2$3$4$5', $css); $css = preg_replace_callback('/font-family:([^;}]+)([;}])/' ,array($this, '_fontFamilyCB'), $css); $css = preg_replace('/@import\\s+url/', '@import url', $css); $css = preg_replace('/[ \\t]*\\n+\\s*/', "\n", $css); $css = preg_replace('/([\\w#\\.\\*]+)\\s+([\\w#\\.\\*]+){/', "$1\n$2{", $css); $css = preg_replace('/
            ((?:padding|margin|border|outline):\\d+(?:px|em)?) # 1 = prop : 1st numeric value
            \\s+
            /x' ,"$1\n", $css); $css = preg_replace('/:first-l(etter|ine)\\{/', ':first-l$1 {', $css); return trim($css); } protected function _selectorsCB($m) { return preg_replace('/\\s*([,>+~])\\s*/', '$1', $m[0]); } protected function _commentCB($m) { $hasSurroundingWs = (trim($m[0]) !== $m[1]); $m = $m[1]; if ($m === 'keep') { return '/**/'; } if ($m === '" "') { return '/*" "*/'; } if (preg_match('@";\\}\\s*\\}/\\*\\s+@', $m)) { return '/*";}}/* */'; } if ($this->_inHack) { if (preg_match('@
                    ^/               # comment started like /*/
                    \\s*
                    (\\S[\\s\\S]+?)  # has at least some non-ws content
                    \\s*
                    /\\*             # ends like /*/ or /**/
                @x', $m, $n)) { $this->_inHack = false; return "/*/{$n[1]}/**/"; } } if (substr($m, -1) === '\\') { $this->_inHack = true; return '/*\\*/'; } if ($m !== '' && $m[0] === '/') { $this->_inHack = true; return '/*/*/'; } if ($this->_inHack) { $this->_inHack = false; return '/**/'; } return $hasSurroundingWs ? ' ' : ''; } protected function _fontFamilyCB($m) { $m[1] = preg_replace('/
                \\s*
                (
                    "[^"]+"      # 1 = family in double qutoes
                    |\'[^\']+\'  # or 1 = family in single quotes
                    |[\\w\\-]+   # or 1 = unquoted family
                )
                \\s*
            /x', '$1', $m[1]); return 'font-family:' . $m[1] . $m[2]; } }   class HTTP_ConditionalGet { public $cacheIsValid = null; public function __construct($spec) { $scope = (isset($spec['isPublic']) && $spec['isPublic']) ? 'public' : 'private'; $maxAge = 0; if (isset($spec['setExpires']) && is_numeric($spec['setExpires']) && ! isset($spec['maxAge'])) { $spec['maxAge'] = $spec['setExpires'] - $_SERVER['REQUEST_TIME']; } if (isset($spec['maxAge'])) { $maxAge = $spec['maxAge']; $this->_headers['Expires'] = self::gmtDate( $_SERVER['REQUEST_TIME'] + $spec['maxAge'] ); } $etagAppend = ''; if (isset($spec['encoding'])) { $this->_stripEtag = true; $this->_headers['Vary'] = 'Accept-Encoding'; if ('' !== $spec['encoding']) { if (0 === strpos($spec['encoding'], 'x-')) { $spec['encoding'] = substr($spec['encoding'], 2); } $etagAppend = ';' . substr($spec['encoding'], 0, 2); } } if (isset($spec['lastModifiedTime'])) { $this->_setLastModified($spec['lastModifiedTime']); if (isset($spec['eTag'])) { $this->_setEtag($spec['eTag'], $scope); } else { $this->_setEtag($spec['lastModifiedTime'] . $etagAppend, $scope); } } elseif (isset($spec['eTag'])) { $this->_setEtag($spec['eTag'], $scope); } elseif (isset($spec['contentHash'])) { $this->_setEtag($spec['contentHash'] . $etagAppend, $scope); } $this->_headers['Cache-Control'] = "max-age={$maxAge}, {$scope}"; $this->cacheIsValid = (isset($spec['invalidate']) && $spec['invalidate']) ? false : $this->_isCacheValid(); } public function getHeaders() { return $this->_headers; } public function setContentLength($bytes) { return $this->_headers['Content-Length'] = $bytes; } public function sendHeaders() { $headers = $this->_headers; if (array_key_exists('_responseCode', $headers)) { header($headers['_responseCode']); unset($headers['_responseCode']); } foreach ($headers as $name => $val) { header($name . ': ' . $val); } } public static function check($lastModifiedTime = null, $isPublic = false, $options = array()) { if (null !== $lastModifiedTime) { $options['lastModifiedTime'] = (int)$lastModifiedTime; } $options['isPublic'] = (bool)$isPublic; $cg = new HTTP_ConditionalGet($options); $cg->sendHeaders(); if ($cg->cacheIsValid) { exit(); } } public static function gmtDate($time) { return gmdate('D, d M Y H:i:s \G\M\T', $time); } protected $_headers = array(); protected $_lmTime = null; protected $_etag = null; protected $_stripEtag = false; protected function _setEtag($hash, $scope) { $this->_etag = '"' . substr($scope, 0, 3) . $hash . '"'; $this->_headers['ETag'] = $this->_etag; } protected function _setLastModified($time) { $this->_lmTime = (int)$time; $this->_headers['Last-Modified'] = self::gmtDate($time); } protected function _isCacheValid() { if (null === $this->_etag) { return false; } $isValid = ($this->resourceMatchedEtag() || $this->resourceNotModified()); if ($isValid) { $this->_headers['_responseCode'] = 'HTTP/1.0 304 Not Modified'; } return $isValid; } protected function resourceMatchedEtag() { if (!isset($_SERVER['HTTP_IF_NONE_MATCH'])) { return false; } $clientEtagList = get_magic_quotes_gpc() ? stripslashes($_SERVER['HTTP_IF_NONE_MATCH']) : $_SERVER['HTTP_IF_NONE_MATCH']; $clientEtags = explode(',', $clientEtagList); $compareTo = $this->normalizeEtag($this->_etag); foreach ($clientEtags as $clientEtag) { if ($this->normalizeEtag($clientEtag) === $compareTo) { $this->_headers['ETag'] = trim($clientEtag); return true; } } return false; } protected function normalizeEtag($etag) { $etag = trim($etag); return $this->_stripEtag ? preg_replace('/;\\w\\w"$/', '"', $etag) : $etag; } protected function resourceNotModified() { if (!isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) { return false; } $ifModifiedSince = $_SERVER['HTTP_IF_MODIFIED_SINCE']; if (false !== ($semicolon = strrpos($ifModifiedSince, ';'))) { $ifModifiedSince = substr($ifModifiedSince, 0, $semicolon); } if ($ifModifiedSince == self::gmtDate($this->_lmTime)) { $this->_headers['ETag'] = $this->normalizeEtag($this->_etag); return true; } return false; } }   class Minify_CSS { public static function minify($css, $options = array()) { if (isset($options['preserveComments']) && !$options['preserveComments']) { $css = Minify_CSS_Compressor::process($css, $options); } else { $css = Minify_CommentPreserver::process( $css ,array('Minify_CSS_Compressor', 'process') ,array($options) ); } if (! isset($options['currentDir']) && ! isset($options['prependRelativePath'])) { return $css; } if (isset($options['currentDir'])) { return Minify_CSS_UriRewriter::rewrite( $css ,$options['currentDir'] ,isset($options['docRoot']) ? $options['docRoot'] : $_SERVER['DOCUMENT_ROOT'] ,isset($options['symlinks']) ? $options['symlinks'] : array() ); } else { return Minify_CSS_UriRewriter::prepend( $css ,$options['prependRelativePath'] ); } } }   class Solar_Dir { protected static $_tmp; public static function exists($dir) { $dir = trim($dir); if (! $dir) { return false; } $abs = ($dir[0] == '/' || $dir[0] == '\\' || $dir[1] == ':'); if ($abs && is_dir($dir)) { return $dir; } $path = explode(PATH_SEPARATOR, ini_get('include_path')); foreach ($path as $base) { $target = rtrim($base, '\\/') . DIRECTORY_SEPARATOR . $dir; if (is_dir($target)) { return $target; } } return false; } public static function fix($dir) { $dir = str_replace('/', DIRECTORY_SEPARATOR, $dir); return rtrim($dir, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR; } public static function name($file, $up = 0) { $dir = dirname($file); while ($up --) { $dir = dirname($dir); } return $dir; } public static function tmp($sub = '') { if (! Solar_Dir::$_tmp) { if (function_exists('sys_get_temp_dir')) { $tmp = sys_get_temp_dir(); } else { $tmp = Solar_Dir::_tmp(); } Solar_Dir::$_tmp = rtrim($tmp, DIRECTORY_SEPARATOR); } $sub = trim($sub); if ($sub) { $sub = trim($sub, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR; } return Solar_Dir::$_tmp . DIRECTORY_SEPARATOR . $sub; } protected static function _tmp() { if (strtolower(substr(PHP_OS, 0, 3)) != 'win') { $tmp = empty($_ENV['TMPDIR']) ? getenv('TMPDIR') : $_ENV['TMPDIR']; if ($tmp) { return $tmp; } else { return '/tmp'; } } $tmp = empty($_ENV['TEMP']) ? getenv('TEMP') : $_ENV['TEMP']; if ($tmp) { return $tmp; } $tmp = empty($_ENV['TMP']) ? getenv('TMP') : $_ENV['TMP']; if ($tmp) { return $tmp; } $tmp = empty($_ENV['windir']) ? getenv('windir') : $_ENV['windir']; if ($tmp) { return $tmp; } return getenv('SystemRoot') . '\\temp'; } }   class HTTP_Encoder { public static $encodeToIe6 = false; public static $compressionLevel = 6; public function __construct($spec) { $this->_content = $spec['content']; $this->_headers['Content-Length'] = (string)strlen($this->_content); if (isset($spec['type'])) { $this->_headers['Content-Type'] = $spec['type']; } if (isset($spec['method']) && in_array($spec['method'], array('gzip', 'deflate', 'compress', ''))) { $this->_encodeMethod = array($spec['method'], $spec['method']); } else { $this->_encodeMethod = self::getAcceptedEncoding(); } } public function getContent() { return $this->_content; } public function getHeaders() { return $this->_headers; } public function sendHeaders() { foreach ($this->_headers as $name => $val) { header($name . ': ' . $val); } } public function sendAll() { $this->sendHeaders(); echo $this->_content; } public static function getAcceptedEncoding($allowCompress = true, $allowDeflate = true) { if (! isset($_SERVER['HTTP_ACCEPT_ENCODING']) || self::_isBuggyIe()) { return array('', ''); } $ae = $_SERVER['HTTP_ACCEPT_ENCODING']; if (0 === strpos($ae, 'gzip,') || 0 === strpos($ae, 'deflate, gzip,') ) { return array('gzip', 'gzip'); } if (preg_match( '@(?:^|,)\\s*((?:x-)?gzip)\\s*(?:$|,|;\\s*q=(?:0\\.|1))@' ,$ae ,$m)) { return array('gzip', $m[1]); } if ($allowDeflate) { $aeRev = strrev($ae); if (0 === strpos($aeRev, 'etalfed ,') || 0 === strpos($aeRev, 'etalfed,') || 0 === strpos($ae, 'deflate,') || preg_match( '@(?:^|,)\\s*deflate\\s*(?:$|,|;\\s*q=(?:0\\.|1))@', $ae)) { return array('deflate', 'deflate'); } } if ($allowCompress && preg_match( '@(?:^|,)\\s*((?:x-)?compress)\\s*(?:$|,|;\\s*q=(?:0\\.|1))@' ,$ae ,$m)) { return array('compress', $m[1]); } return array('', ''); } public function encode($compressionLevel = null) { $this->_headers['Vary'] = 'Accept-Encoding'; if (null === $compressionLevel) { $compressionLevel = self::$compressionLevel; } if ('' === $this->_encodeMethod[0] || ($compressionLevel == 0) || !extension_loaded('zlib')) { return false; } if ($this->_encodeMethod[0] === 'deflate') { $encoded = gzdeflate($this->_content, $compressionLevel); } elseif ($this->_encodeMethod[0] === 'gzip') { $encoded = gzencode($this->_content, $compressionLevel); } else { $encoded = gzcompress($this->_content, $compressionLevel); } if (false === $encoded) { return false; } $this->_headers['Content-Length'] = strlen($encoded); $this->_headers['Content-Encoding'] = $this->_encodeMethod[1]; $this->_content = $encoded; return true; } public static function output($content, $compressionLevel = null) { if (null === $compressionLevel) { $compressionLevel = self::$compressionLevel; } $he = new HTTP_Encoder(array('content' => $content)); $ret = $he->encode($compressionLevel); $he->sendAll(); return $ret; } protected $_content = ''; protected $_headers = array(); protected $_encodeMethod = array('', ''); protected static function _isBuggyIe() { $ua = $_SERVER['HTTP_USER_AGENT']; if (0 !== strpos($ua, 'Mozilla/4.0 (compatible; MSIE ') || false !== strpos($ua, 'Opera')) { return false; } $version = (float)substr($ua, 30); return self::$encodeToIe6 ? ($version < 6 || ($version == 6 && false === strpos($ua, 'SV1'))) : ($version < 7); } }   class Minify_Cache_File { public function __construct($path = '', $fileLocking = false) { if (! $path) { $path = rtrim(Solar_Dir::tmp(), DIRECTORY_SEPARATOR); } $this->_locking = $fileLocking; $this->_path = $path; } public function store($id, $data) { $flag = $this->_locking ? LOCK_EX : null; if (is_file($this->_path . '/' . $id)) { @unlink($this->_path . '/' . $id); } if (! @file_put_contents($this->_path . '/' . $id, $data, $flag)) { return false; } if ($data !== $this->fetch($id)) { @unlink($file); return false; } return true; } public function getSize($id) { return filesize($this->_path . '/' . $id); } public function isValid($id, $srcMtime) { $file = $this->_path . '/' . $id; return (is_file($file) && (filemtime($file) >= $srcMtime)); } public function display($id) { if ($this->_locking) { $fp = fopen($this->_path . '/' . $id, 'rb'); flock($fp, LOCK_SH); fpassthru($fp); flock($fp, LOCK_UN); fclose($fp); } else { readfile($this->_path . '/' . $id); } } public function fetch($id) { if ($this->_locking) { $fp = fopen($this->_path . '/' . $id, 'rb'); flock($fp, LOCK_SH); $ret = stream_get_contents($fp); flock($fp, LOCK_UN); fclose($fp); return $ret; } else { return file_get_contents($this->_path . '/' . $id); } } public function getPath() { return $this->_path; } private $_path = null; private $_locking = null; }   class FirePHP { const VERSION = '0.2.0'; const LOG = 'LOG'; const INFO = 'INFO'; const WARN = 'WARN'; const ERROR = 'ERROR'; const DUMP = 'DUMP'; const TRACE = 'TRACE'; const EXCEPTION = 'EXCEPTION'; const TABLE = 'TABLE'; const GROUP_START = 'GROUP_START'; const GROUP_END = 'GROUP_END'; protected static $instance = null; protected $messageIndex = 1; protected $options = array(); protected $objectFilters = array(); protected $objectStack = array(); protected $enabled = true; function __construct() { $this->options['maxObjectDepth'] = 10; $this->options['maxArrayDepth'] = 20; $this->options['useNativeJsonEncode'] = true; $this->options['includeLineNumbers'] = true; } public function __sleep() { return array('options','objectFilters','enabled'); } public static function getInstance($AutoCreate=false) { if($AutoCreate===true && !self::$instance) { self::init(); } return self::$instance; } public static function init() { return self::$instance = new self(); } public function setEnabled($Enabled) { $this->enabled = $Enabled; } public function getEnabled() { return $this->enabled; } public function setObjectFilter($Class, $Filter) { $this->objectFilters[$Class] = $Filter; } public function setOptions($Options) { $this->options = array_merge($this->options,$Options); } public function registerErrorHandler() { set_error_handler(array($this,'errorHandler')); } public function errorHandler($errno, $errstr, $errfile, $errline, $errcontext) { if (error_reporting() == 0) { return; } if (error_reporting() & $errno) { throw new ErrorException($errstr, 0, $errno, $errfile, $errline); } } public function registerExceptionHandler() { set_exception_handler(array($this,'exceptionHandler')); } function exceptionHandler($Exception) { $this->fb($Exception); } public function setProcessorUrl($URL) { $this->setHeader('X-FirePHP-ProcessorURL', $URL); } public function setRendererUrl($URL) { $this->setHeader('X-FirePHP-RendererURL', $URL); } public function group($Name) { return $this->fb(null, $Name, FirePHP::GROUP_START); } public function groupEnd() { return $this->fb(null, null, FirePHP::GROUP_END); } public function log($Object, $Label=null) { return $this->fb($Object, $Label, FirePHP::LOG); } public function info($Object, $Label=null) { return $this->fb($Object, $Label, FirePHP::INFO); } public function warn($Object, $Label=null) { return $this->fb($Object, $Label, FirePHP::WARN); } public function error($Object, $Label=null) { return $this->fb($Object, $Label, FirePHP::ERROR); } public function dump($Key, $Variable) { return $this->fb($Variable, $Key, FirePHP::DUMP); } public function trace($Label) { return $this->fb($Label, FirePHP::TRACE); } public function table($Label, $Table) { return $this->fb($Table, $Label, FirePHP::TABLE); } public function detectClientExtension() { if(!@preg_match_all('/\sFirePHP\/([\.|\d]*)\s?/si',$this->getUserAgent(),$m) || !version_compare($m[1][0],'0.0.6','>=')) { return false; } return true; } public function fb($Object) { if(!$this->enabled) { return false; } if (headers_sent($filename, $linenum)) { throw $this->newException('Headers already sent in '.$filename.' on line '.$linenum.'. Cannot send log data to FirePHP. You must have Output Buffering enabled via ob_start() or output_buffering ini directive.'); } $Type = null; $Label = null; if(func_num_args()==1) { } else if(func_num_args()==2) { switch(func_get_arg(1)) { case self::LOG: case self::INFO: case self::WARN: case self::ERROR: case self::DUMP: case self::TRACE: case self::EXCEPTION: case self::TABLE: case self::GROUP_START: case self::GROUP_END: $Type = func_get_arg(1); break; default: $Label = func_get_arg(1); break; } } else if(func_num_args()==3) { $Type = func_get_arg(2); $Label = func_get_arg(1); } else { throw $this->newException('Wrong number of arguments to fb() function!'); } if(!$this->detectClientExtension()) { return false; } $meta = array(); $skipFinalObjectEncode = false; if($Object instanceof Exception) { $meta['file'] = $this->_escapeTraceFile($Object->getFile()); $meta['line'] = $Object->getLine(); $trace = $Object->getTrace(); if($Object instanceof ErrorException && isset($trace[0]['function']) && $trace[0]['function']=='errorHandler' && isset($trace[0]['class']) && $trace[0]['class']=='FirePHP') { $severity = false; switch($Object->getSeverity()) { case E_WARNING: $severity = 'E_WARNING'; break; case E_NOTICE: $severity = 'E_NOTICE'; break; case E_USER_ERROR: $severity = 'E_USER_ERROR'; break; case E_USER_WARNING: $severity = 'E_USER_WARNING'; break; case E_USER_NOTICE: $severity = 'E_USER_NOTICE'; break; case E_STRICT: $severity = 'E_STRICT'; break; case E_RECOVERABLE_ERROR: $severity = 'E_RECOVERABLE_ERROR'; break; case E_DEPRECATED: $severity = 'E_DEPRECATED'; break; case E_USER_DEPRECATED: $severity = 'E_USER_DEPRECATED'; break; } $Object = array('Class'=>get_class($Object), 'Message'=>$severity.': '.$Object->getMessage(), 'File'=>$this->_escapeTraceFile($Object->getFile()), 'Line'=>$Object->getLine(), 'Type'=>'trigger', 'Trace'=>$this->_escapeTrace(array_splice($trace,2))); $skipFinalObjectEncode = true; } else { $Object = array('Class'=>get_class($Object), 'Message'=>$Object->getMessage(), 'File'=>$this->_escapeTraceFile($Object->getFile()), 'Line'=>$Object->getLine(), 'Type'=>'throw', 'Trace'=>$this->_escapeTrace($trace)); $skipFinalObjectEncode = true; } $Type = self::EXCEPTION; } else if($Type==self::TRACE) { $trace = debug_backtrace(); if(!$trace) return false; for( $i=0 ; $i<sizeof($trace) ; $i++ ) { if(isset($trace[$i]['class']) && isset($trace[$i]['file']) && ($trace[$i]['class']=='FirePHP' || $trace[$i]['class']=='FB') && (substr($this->_standardizePath($trace[$i]['file']),-18,18)=='FirePHPCore/fb.php' || substr($this->_standardizePath($trace[$i]['file']),-29,29)=='FirePHPCore/FirePHP.class.php')) { } else if(isset($trace[$i]['class']) && isset($trace[$i+1]['file']) && $trace[$i]['class']=='FirePHP' && substr($this->_standardizePath($trace[$i+1]['file']),-18,18)=='FirePHPCore/fb.php') { } else if($trace[$i]['function']=='fb' || $trace[$i]['function']=='trace' || $trace[$i]['function']=='send') { $Object = array('Class'=>isset($trace[$i]['class'])?$trace[$i]['class']:'', 'Type'=>isset($trace[$i]['type'])?$trace[$i]['type']:'', 'Function'=>isset($trace[$i]['function'])?$trace[$i]['function']:'', 'Message'=>$trace[$i]['args'][0], 'File'=>isset($trace[$i]['file'])?$this->_escapeTraceFile($trace[$i]['file']):'', 'Line'=>isset($trace[$i]['line'])?$trace[$i]['line']:'', 'Args'=>isset($trace[$i]['args'])?$this->encodeObject($trace[$i]['args']):'', 'Trace'=>$this->_escapeTrace(array_splice($trace,$i+1))); $skipFinalObjectEncode = true; $meta['file'] = isset($trace[$i]['file'])?$this->_escapeTraceFile($trace[$i]['file']):''; $meta['line'] = isset($trace[$i]['line'])?$trace[$i]['line']:''; break; } } } else if($Type==self::TABLE) { if(isset($Object[0]) && is_string($Object[0])) { $Object[1] = $this->encodeTable($Object[1]); } else { $Object = $this->encodeTable($Object); } $skipFinalObjectEncode = true; } else { if($Type===null) { $Type = self::LOG; } } if($this->options['includeLineNumbers']) { if(!isset($meta['file']) || !isset($meta['line'])) { $trace = debug_backtrace(); for( $i=0 ; $trace && $i<sizeof($trace) ; $i++ ) { if(isset($trace[$i]['class']) && isset($trace[$i]['file']) && ($trace[$i]['class']=='FirePHP' || $trace[$i]['class']=='FB') && (substr($this->_standardizePath($trace[$i]['file']),-18,18)=='FirePHPCore/fb.php' || substr($this->_standardizePath($trace[$i]['file']),-29,29)=='FirePHPCore/FirePHP.class.php')) { } else if(isset($trace[$i]['class']) && isset($trace[$i+1]['file']) && $trace[$i]['class']=='FirePHP' && substr($this->_standardizePath($trace[$i+1]['file']),-18,18)=='FirePHPCore/fb.php') { } else if(isset($trace[$i]['file']) && substr($this->_standardizePath($trace[$i]['file']),-18,18)=='FirePHPCore/fb.php') { } else { $meta['file'] = isset($trace[$i]['file'])?$this->_escapeTraceFile($trace[$i]['file']):''; $meta['line'] = isset($trace[$i]['line'])?$trace[$i]['line']:''; break; } } } } else { unset($meta['file']); unset($meta['line']); } $this->setHeader('X-Wf-Protocol-1','http://meta.wildfirehq.org/Protocol/JsonStream/0.2'); $this->setHeader('X-Wf-1-Plugin-1','http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/'.self::VERSION); $structure_index = 1; if($Type==self::DUMP) { $structure_index = 2; $this->setHeader('X-Wf-1-Structure-2','http://meta.firephp.org/Wildfire/Structure/FirePHP/Dump/0.1'); } else { $this->setHeader('X-Wf-1-Structure-1','http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1'); } if($Type==self::DUMP) { $msg = '{"'.$Label.'":'.$this->jsonEncode($Object, $skipFinalObjectEncode).'}'; } else { $msg_meta = array('Type'=>$Type); if($Label!==null) { $msg_meta['Label'] = $Label; } if(isset($meta['file'])) { $msg_meta['File'] = $meta['file']; } if(isset($meta['line'])) { $msg_meta['Line'] = $meta['line']; } $msg = '['.$this->jsonEncode($msg_meta).','.$this->jsonEncode($Object, $skipFinalObjectEncode).']'; } $parts = explode("\n",chunk_split($msg, 5000, "\n")); for( $i=0 ; $i<count($parts) ; $i++) { $part = $parts[$i]; if ($part) { if(count($parts)>2) { $this->setHeader('X-Wf-1-'.$structure_index.'-'.'1-'.$this->messageIndex, (($i==0)?strlen($msg):'') . '|' . $part . '|' . (($i<count($parts)-2)?'\\':'')); } else { $this->setHeader('X-Wf-1-'.$structure_index.'-'.'1-'.$this->messageIndex, strlen($part) . '|' . $part . '|'); } $this->messageIndex++; if ($this->messageIndex > 99999) { throw new Exception('Maximum number (99,999) of messages reached!'); } } } $this->setHeader('X-Wf-1-Index',$this->messageIndex-1); return true; } protected function _standardizePath($Path) { return preg_replace('/\\\\+/','/',$Path); } protected function _escapeTrace($Trace) { if(!$Trace) return $Trace; for( $i=0 ; $i<sizeof($Trace) ; $i++ ) { if(isset($Trace[$i]['file'])) { $Trace[$i]['file'] = $this->_escapeTraceFile($Trace[$i]['file']); } if(isset($Trace[$i]['args'])) { $Trace[$i]['args'] = $this->encodeObject($Trace[$i]['args']); } } return $Trace; } protected function _escapeTraceFile($File) { if(strpos($File,'\\')) { $file = preg_replace('/\\\\+/','\\',$File); return $file; } return $File; } protected function setHeader($Name, $Value) { return header($Name.': '.$Value); } protected function getUserAgent() { if(!isset($_SERVER['HTTP_USER_AGENT'])) return false; return $_SERVER['HTTP_USER_AGENT']; } protected function newException($Message) { return new Exception($Message); } protected function jsonEncode($Object, $skipObjectEncode=false) { if(!$skipObjectEncode) { $Object = $this->encodeObject($Object); } if(function_exists('json_encode') && $this->options['useNativeJsonEncode']!=false) { return json_encode($Object); } else { return $this->json_encode($Object); } } protected function encodeTable($Table) { if(!$Table) return $Table; for( $i=0 ; $i<count($Table) ; $i++ ) { if(is_array($Table[$i])) { for( $j=0 ; $j<count($Table[$i]) ; $j++ ) { $Table[$i][$j] = $this->encodeObject($Table[$i][$j]); } } } return $Table; } protected function encodeObject($Object, $ObjectDepth = 1, $ArrayDepth = 1) { $return = array(); if (is_object($Object)) { if ($ObjectDepth > $this->options['maxObjectDepth']) { return '** Max Object Depth ('.$this->options['maxObjectDepth'].') **'; } foreach ($this->objectStack as $refVal) { if ($refVal === $Object) { return '** Recursion ('.get_class($Object).') **'; } } array_push($this->objectStack, $Object); $return['__className'] = $class = get_class($Object); $reflectionClass = new ReflectionClass($class); $properties = array(); foreach( $reflectionClass->getProperties() as $property) { $properties[$property->getName()] = $property; } $members = (array)$Object; foreach( $properties as $raw_name => $property ) { $name = $raw_name; if($property->isStatic()) { $name = 'static:'.$name; } if($property->isPublic()) { $name = 'public:'.$name; } else if($property->isPrivate()) { $name = 'private:'.$name; $raw_name = "\0".$class."\0".$raw_name; } else if($property->isProtected()) { $name = 'protected:'.$name; $raw_name = "\0".'*'."\0".$raw_name; } if(!(isset($this->objectFilters[$class]) && is_array($this->objectFilters[$class]) && in_array($raw_name,$this->objectFilters[$class]))) { if(array_key_exists($raw_name,$members) && !$property->isStatic()) { $return[$name] = $this->encodeObject($members[$raw_name], $ObjectDepth + 1, 1); } else { if(method_exists($property,'setAccessible')) { $property->setAccessible(true); $return[$name] = $this->encodeObject($property->getValue($Object), $ObjectDepth + 1, 1); } else if($property->isPublic()) { $return[$name] = $this->encodeObject($property->getValue($Object), $ObjectDepth + 1, 1); } else { $return[$name] = '** Need PHP 5.3 to get value **'; } } } else { $return[$name] = '** Excluded by Filter **'; } } foreach( $members as $raw_name => $value ) { $name = $raw_name; if ($name{0} == "\0") { $parts = explode("\0", $name); $name = $parts[2]; } if(!isset($properties[$name])) { $name = 'undeclared:'.$name; if(!(isset($this->objectFilters[$class]) && is_array($this->objectFilters[$class]) && in_array($raw_name,$this->objectFilters[$class]))) { $return[$name] = $this->encodeObject($value, $ObjectDepth + 1, 1); } else { $return[$name] = '** Excluded by Filter **'; } } } array_pop($this->objectStack); } elseif (is_array($Object)) { if ($ArrayDepth > $this->options['maxArrayDepth']) { return '** Max Array Depth ('.$this->options['maxArrayDepth'].') **'; } foreach ($Object as $key => $val) { if($key=='GLOBALS' && is_array($val) && array_key_exists('GLOBALS',$val)) { $val['GLOBALS'] = '** Recursion (GLOBALS) **'; } $return[$key] = $this->encodeObject($val, 1, $ArrayDepth + 1); } } else { if(self::is_utf8($Object)) { return $Object; } else { return utf8_encode($Object); } } return $return; } protected static function is_utf8($str) { $c=0; $b=0; $bits=0; $len=strlen($str); for($i=0; $i<$len; $i++){ $c=ord($str[$i]); if($c > 128){ if(($c >= 254)) return false; elseif($c >= 252) $bits=6; elseif($c >= 248) $bits=5; elseif($c >= 240) $bits=4; elseif($c >= 224) $bits=3; elseif($c >= 192) $bits=2; else return false; if(($i+$bits) > $len) return false; while($bits > 1){ $i++; $b=ord($str[$i]); if($b < 128 || $b > 191) return false; $bits--; } } } return true; } private $json_objectStack = array(); private function json_utf82utf16($utf8) { if(function_exists('mb_convert_encoding')) { return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8'); } switch(strlen($utf8)) { case 1: return $utf8; case 2: return chr(0x07 & (ord($utf8{0}) >> 2)) . chr((0xC0 & (ord($utf8{0}) << 6)) | (0x3F & ord($utf8{1}))); case 3: return chr((0xF0 & (ord($utf8{0}) << 4)) | (0x0F & (ord($utf8{1}) >> 2))) . chr((0xC0 & (ord($utf8{1}) << 6)) | (0x7F & ord($utf8{2}))); } return ''; } private function json_encode($var) { if(is_object($var)) { if(in_array($var,$this->json_objectStack)) { return '"** Recursion **"'; } } switch (gettype($var)) { case 'boolean': return $var ? 'true' : 'false'; case 'NULL': return 'null'; case 'integer': return (int) $var; case 'double': case 'float': return (float) $var; case 'string': $ascii = ''; $strlen_var = strlen($var); for ($c = 0; $c < $strlen_var; ++$c) { $ord_var_c = ord($var{$c}); switch (true) { case $ord_var_c == 0x08: $ascii .= '\b'; break; case $ord_var_c == 0x09: $ascii .= '\t'; break; case $ord_var_c == 0x0A: $ascii .= '\n'; break; case $ord_var_c == 0x0C: $ascii .= '\f'; break; case $ord_var_c == 0x0D: $ascii .= '\r'; break; case $ord_var_c == 0x22: case $ord_var_c == 0x2F: case $ord_var_c == 0x5C: $ascii .= '\\'.$var{$c}; break; case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)): $ascii .= $var{$c}; break; case (($ord_var_c & 0xE0) == 0xC0): $char = pack('C*', $ord_var_c, ord($var{$c + 1})); $c += 1; $utf16 = $this->json_utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xF0) == 0xE0): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2})); $c += 2; $utf16 = $this->json_utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xF8) == 0xF0): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3})); $c += 3; $utf16 = $this->json_utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xFC) == 0xF8): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3}), ord($var{$c + 4})); $c += 4; $utf16 = $this->json_utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xFE) == 0xFC): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3}), ord($var{$c + 4}), ord($var{$c + 5})); $c += 5; $utf16 = $this->json_utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; } } return '"'.$ascii.'"'; case 'array': if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) { $this->json_objectStack[] = $var; $properties = array_map(array($this, 'json_name_value'), array_keys($var), array_values($var)); array_pop($this->json_objectStack); foreach($properties as $property) { if($property instanceof Exception) { return $property; } } return '{' . join(',', $properties) . '}'; } $this->json_objectStack[] = $var; $elements = array_map(array($this, 'json_encode'), $var); array_pop($this->json_objectStack); foreach($elements as $element) { if($element instanceof Exception) { return $element; } } return '[' . join(',', $elements) . ']'; case 'object': $vars = self::encodeObject($var); $this->json_objectStack[] = $var; $properties = array_map(array($this, 'json_name_value'), array_keys($vars), array_values($vars)); array_pop($this->json_objectStack); foreach($properties as $property) { if($property instanceof Exception) { return $property; } } return '{' . join(',', $properties) . '}'; default: return null; } } private function json_name_value($name, $value) { if($name=='GLOBALS' && is_array($value) && array_key_exists('GLOBALS',$value)) { $value['GLOBALS'] = '** Recursion **'; } $encoded_value = $this->json_encode($value); if($encoded_value instanceof Exception) { return $encoded_value; } return $this->json_encode(strval($name)) . ':' . $encoded_value; } }   return array( );   class Minify_HTML { public static function minify($html, $options = array()) { $min = new Minify_HTML($html, $options); return $min->process(); } public function __construct($html, $options = array()) { $this->_html = str_replace("\r\n", "\n", trim($html)); if (isset($options['xhtml'])) { $this->_isXhtml = (bool)$options['xhtml']; } if (isset($options['cssMinifier'])) { $this->_cssMinifier = $options['cssMinifier']; } if (isset($options['jsMinifier'])) { $this->_jsMinifier = $options['jsMinifier']; } } public function process() { if ($this->_isXhtml === null) { $this->_isXhtml = (false !== strpos($this->_html, '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML')); } $this->_replacementHash = 'MINIFYHTML' . md5($_SERVER['REQUEST_TIME']); $this->_placeholders = array(); $this->_html = preg_replace_callback( '/(\\s*)(<script\\b[^>]*?>)([\\s\\S]*?)<\\/script>(\\s*)/i' ,array($this, '_removeScriptCB') ,$this->_html); $this->_html = preg_replace_callback( '/\\s*(<style\\b[^>]*?>)([\\s\\S]*?)<\\/style>\\s*/i' ,array($this, '_removeStyleCB') ,$this->_html); $this->_html = preg_replace_callback( '/<!--([\\s\\S]*?)-->/' ,array($this, '_commentCB') ,$this->_html); $this->_html = preg_replace_callback('/\\s*(<pre\\b[^>]*?>[\\s\\S]*?<\\/pre>)\\s*/i' ,array($this, '_removePreCB') ,$this->_html); $this->_html = preg_replace_callback( '/\\s*(<textarea\\b[^>]*?>[\\s\\S]*?<\\/textarea>)\\s*/i' ,array($this, '_removeTextareaCB') ,$this->_html); $this->_html = preg_replace('/^\\s+|\\s+$/m', '', $this->_html); $this->_html = preg_replace('/\\s+(<\\/?(?:area|base(?:font)?|blockquote|body' .'|caption|center|cite|col(?:group)?|dd|dir|div|dl|dt|fieldset|form' .'|frame(?:set)?|h[1-6]|head|hr|html|legend|li|link|map|menu|meta' .'|ol|opt(?:group|ion)|p|param|t(?:able|body|head|d|h||r|foot|itle)' .'|ul)\\b[^>]*>)/i', '$1', $this->_html); $this->_html = preg_replace_callback( '/>([^<]+)</' ,array($this, '_outsideTagCB') ,$this->_html); $this->_html = preg_replace('/(<[a-z\\-]+)\\s+([^>]+>)/i', "$1\n$2", $this->_html); $this->_html = str_replace( array_keys($this->_placeholders) ,array_values($this->_placeholders) ,$this->_html ); return $this->_html; } protected function _commentCB($m) { return (0 === strpos($m[1], '[') || false !== strpos($m[1], '<![')) ? $m[0] : ''; } protected function _reservePlace($content) { $placeholder = '%' . $this->_replacementHash . count($this->_placeholders) . '%'; $this->_placeholders[$placeholder] = $content; return $placeholder; } protected $_isXhtml = null; protected $_replacementHash = null; protected $_placeholders = array(); protected $_cssMinifier = null; protected $_jsMinifier = null; protected function _outsideTagCB($m) { return '>' . preg_replace('/^\\s+|\\s+$/', ' ', $m[1]) . '<'; } protected function _removePreCB($m) { return $this->_reservePlace($m[1]); } protected function _removeTextareaCB($m) { return $this->_reservePlace($m[1]); } protected function _removeStyleCB($m) { $openStyle = $m[1]; $css = $m[2]; $css = preg_replace('/(?:^\\s*<!--|-->\\s*$)/', '', $css); $css = $this->_removeCdata($css); $minifier = $this->_cssMinifier ? $this->_cssMinifier : 'trim'; $css = call_user_func($minifier, $css); return $this->_reservePlace($this->_needsCdata($css) ? "{$openStyle}/*<![CDATA[*/{$css}/*]]>*/</style>" : "{$openStyle}{$css}</style>" ); } protected function _removeScriptCB($m) { $openScript = $m[2]; $js = $m[3]; $ws1 = ($m[1] === '') ? '' : ' '; $ws2 = ($m[4] === '') ? '' : ' '; $js = preg_replace('/(?:^\\s*<!--\\s*|\\s*(?:\\/\\/)?\\s*-->\\s*$)/', '', $js); $js = $this->_removeCdata($js); $minifier = $this->_jsMinifier ? $this->_jsMinifier : 'trim'; $js = call_user_func($minifier, $js); return $this->_reservePlace($this->_needsCdata($js) ? "{$ws1}{$openScript}/*<![CDATA[*/{$js}/*]]>*/</script>{$ws2}" : "{$ws1}{$openScript}{$js}</script>{$ws2}" ); } protected function _removeCdata($str) { return (false !== strpos($str, '<![CDATA[')) ? str_replace(array('<![CDATA[', ']]>'), '', $str) : $str; } protected function _needsCdata($str) { return ($this->_isXhtml && preg_match('/(?:[<&]|\\-\\-|\\]\\]>)/', $str)); } }   class Minify_ImportProcessor { public static $filesIncluded = array(); public static function process($file) { self::$filesIncluded = array(); self::$_isCss = (strtolower(substr($file, -4)) === '.css'); $obj = new Minify_ImportProcessor(dirname($file)); return $obj->_getContent($file); } private $_currentDir = null; private $_importedContent = ''; private static $_isCss = null; private function __construct($currentDir) { $this->_currentDir = $currentDir; } private function _getContent($file) { $file = realpath($file); if (! $file || in_array($file, self::$filesIncluded) || false === ($content = @file_get_contents($file)) ) { return ''; } self::$filesIncluded[] = realpath($file); $this->_currentDir = dirname($file); if (pack("CCC",0xef,0xbb,0xbf) === substr($content, 0, 3)) { $content = substr($content, 3); } $content = str_replace("\r\n", "\n", $content); $content = preg_replace_callback( '/
                @import\\s+
                (?:url\\(\\s*)?      # maybe url(
                [\'"]?               # maybe quote
                (.*?)                # 1 = URI
                [\'"]?               # maybe end quote
                (?:\\s*\\))?         # maybe )
                ([a-zA-Z,\\s]*)?     # 2 = media list
                ;                    # end token
            /x' ,array($this, '_importCB') ,$content ); if (self::$_isCss) { $content = preg_replace_callback( '/url\\(\\s*([^\\)\\s]+)\\s*\\)/' ,array($this, '_urlCB') ,$content ); } return $this->_importedContent . $content; } private function _importCB($m) { $url = $m[1]; $mediaList = preg_replace('/\\s+/', '', $m[2]); if (strpos($url, '://') > 0) { return self::$_isCss ? $m[0] : "/* Minify_ImportProcessor will not include remote content */"; } if ('/' === $url[0]) { $url = ltrim($url, '/'); $file = realpath($_SERVER['DOCUMENT_ROOT']) . DIRECTORY_SEPARATOR . strtr($url, '/', DIRECTORY_SEPARATOR); } else { $file = $this->_currentDir . DIRECTORY_SEPARATOR . strtr($url, '/', DIRECTORY_SEPARATOR); } $obj = new Minify_ImportProcessor(dirname($file)); $content = $obj->_getContent($file); if ('' === $content) { return self::$_isCss ? $m[0] : "/* Minify_ImportProcessor could not fetch '{$file}' */";; } return (!self::$_isCss || preg_match('@(?:^$|\\ball\\b)@', $mediaList)) ? $content : "@media {$mediaList} {\n{$content}\n}\n"; } private function _urlCB($m) { $quote = ($m[1][0] === "'" || $m[1][0] === '"') ? $m[1][0] : ''; $url = ($quote === '') ? $m[1] : substr($m[1], 1, strlen($m[1]) - 2); if ('/' !== $url[0]) { if (strpos($url, '//') > 0) { } else { $path = $this->_currentDir . DIRECTORY_SEPARATOR . strtr($url, '/', DIRECTORY_SEPARATOR); $path = substr($path, strlen(realpath($_SERVER['DOCUMENT_ROOT']))); $url = strtr($path, '/\\', '//'); $url = str_replace('/./', '/', $url); do { $url = preg_replace('@/[^/]+/\\.\\./@', '/', $url, 1, $changed); } while ($changed); } } return "url({$quote}{$url}{$quote})"; } }   class JSMin { const ORD_LF = 10; const ORD_SPACE = 32; const ACTION_KEEP_A = 1; const ACTION_DELETE_A = 2; const ACTION_DELETE_A_B = 3; protected $a = "\n"; protected $b = ''; protected $input = ''; protected $inputIndex = 0; protected $inputLength = 0; protected $lookAhead = null; protected $output = ''; public static function minify($js) { $jsmin = new JSMin($js); return $jsmin->min(); } public function __construct($input) { $this->input = str_replace("\r\n", "\n", $input); $this->inputLength = strlen($this->input); } public function min() { if ($this->output !== '') { return $this->output; } $this->action(self::ACTION_DELETE_A_B); while ($this->a !== null) { $command = self::ACTION_KEEP_A; if ($this->a === ' ') { if (! $this->isAlphaNum($this->b)) { $command = self::ACTION_DELETE_A; } } elseif ($this->a === "\n") { if ($this->b === ' ') { $command = self::ACTION_DELETE_A_B; } elseif (false === strpos('{[(+-', $this->b) && ! $this->isAlphaNum($this->b)) { $command = self::ACTION_DELETE_A; } } elseif (! $this->isAlphaNum($this->a)) { if ($this->b === ' ' || ($this->b === "\n" && (false === strpos('}])+-"\'', $this->a)))) { $command = self::ACTION_DELETE_A_B; } } $this->action($command); } $this->output = trim($this->output); return $this->output; } protected function action($command) { switch ($command) { case self::ACTION_KEEP_A: $this->output .= $this->a; case self::ACTION_DELETE_A: $this->a = $this->b; if ($this->a === "'" || $this->a === '"') { $str = $this->a; while (true) { $this->output .= $this->a; $this->a = $this->get(); if ($this->a === $this->b) { break; } if (ord($this->a) <= self::ORD_LF) { throw new JSMin_UnterminatedStringException( 'Unterminated String: ' . var_export($str, true)); } $str .= $this->a; if ($this->a === '\\') { $this->output .= $this->a; $this->a = $this->get(); $str .= $this->a; } } } case self::ACTION_DELETE_A_B: $this->b = $this->next(); if ($this->b === '/' && $this->isRegexpLiteral()) { $this->output .= $this->a . $this->b; $pattern = '/'; while (true) { $this->a = $this->get(); $pattern .= $this->a; if ($this->a === '/') { break; } elseif ($this->a === '\\') { $this->output .= $this->a; $this->a = $this->get(); $pattern .= $this->a; } elseif (ord($this->a) <= self::ORD_LF) { throw new JSMin_UnterminatedRegExpException( 'Unterminated RegExp: '. var_export($pattern, true)); } $this->output .= $this->a; } $this->b = $this->next(); } } } protected function isRegexpLiteral() { if (false !== strpos("\n{;(,=:[!&|?", $this->a)) { return true; } if (' ' === $this->a) { $length = strlen($this->output); if ($length < 2) { return true; } if (preg_match('/(?:case|else|in|return|typeof)$/', $this->output, $m)) { if ($this->output === $m[0]) { return true; } $charBeforeKeyword = substr($this->output, $length - strlen($m[0]) - 1, 1); if (! $this->isAlphaNum($charBeforeKeyword)) { return true; } } } return false; } protected function get() { $c = $this->lookAhead; $this->lookAhead = null; if ($c === null) { if ($this->inputIndex < $this->inputLength) { $c = $this->input[$this->inputIndex]; $this->inputIndex += 1; } else { return null; } } if ($c === "\r" || $c === "\n") { return "\n"; } if (ord($c) < self::ORD_SPACE) { return ' '; } return $c; } protected function peek() { $this->lookAhead = $this->get(); return $this->lookAhead; } protected function isAlphaNum($c) { return (preg_match('/^[0-9a-zA-Z_\\$\\\\]$/', $c) || ord($c) > 126); } protected function singleLineComment() { $comment = ''; while (true) { $get = $this->get(); $comment .= $get; if (ord($get) <= self::ORD_LF) { if (preg_match('/^\\/@(?:cc_on|if|elif|else|end)\\b/', $comment)) { return "/{$comment}"; } return $get; } } } protected function multipleLineComment() { $this->get(); $comment = ''; while (true) { $get = $this->get(); if ($get === '*') { if ($this->peek() === '/') { $this->get(); if (0 === strpos($comment, '!')) { return "\n/*" . substr($comment, 1) . "*/\n"; } if (preg_match('/^@(?:cc_on|if|elif|else|end)\\b/', $comment)) { return "/*{$comment}*/"; } return ' '; } } elseif ($get === null) { throw new JSMin_UnterminatedCommentException('Unterminated Comment: ' . var_export('/*' . $comment, true)); } $comment .= $get; } } protected function next() { $get = $this->get(); if ($get !== '/') { return $get; } switch ($this->peek()) { case '/': return $this->singleLineComment(); case '*': return $this->multipleLineComment(); default: return $get; } } } class JSMin_UnterminatedStringException extends Exception {} class JSMin_UnterminatedCommentException extends Exception {} class JSMin_UnterminatedRegExpException extends Exception {}   define('TOKEN_END', 1); define('TOKEN_NUMBER', 2); define('TOKEN_IDENTIFIER', 3); define('TOKEN_STRING', 4); define('TOKEN_REGEXP', 5); define('TOKEN_NEWLINE', 6); define('TOKEN_CONDCOMMENT_MULTILINE', 7); define('JS_SCRIPT', 100); define('JS_BLOCK', 101); define('JS_LABEL', 102); define('JS_FOR_IN', 103); define('JS_CALL', 104); define('JS_NEW_WITH_ARGS', 105); define('JS_INDEX', 106); define('JS_ARRAY_INIT', 107); define('JS_OBJECT_INIT', 108); define('JS_PROPERTY_INIT', 109); define('JS_GETTER', 110); define('JS_SETTER', 111); define('JS_GROUP', 112); define('JS_LIST', 113); define('DECLARED_FORM', 0); define('EXPRESSED_FORM', 1); define('STATEMENT_FORM', 2); class JSMinPlus { private $parser; private $reserved = array( 'break', 'case', 'catch', 'continue', 'default', 'delete', 'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'abstract', 'boolean', 'byte', 'char', 'class', 'const', 'debugger', 'double', 'enum', 'export', 'extends', 'final', 'float', 'goto', 'implements', 'import', 'int', 'interface', 'long', 'native', 'package', 'private', 'protected', 'public', 'short', 'static', 'super', 'synchronized', 'throws', 'transient', 'volatile', 'arguments', 'eval', 'true', 'false', 'Infinity', 'NaN', 'null', 'undefined' ); private function __construct() { $this->parser = new JSParser(); } public static function minify($js, $filename='') { static $instance; if(!$instance) $instance = new JSMinPlus(); return $instance->min($js, $filename); } private function min($js, $filename) { try { $n = $this->parser->parse($js, $filename, 1); return $this->parseTree($n); } catch(Exception $e) { echo $e->getMessage() . "\n"; } return false; } private function parseTree($n, $noBlockGrouping = false) { $s = ''; switch ($n->type) { case KEYWORD_FUNCTION: $s .= 'function' . ($n->name ? ' ' . $n->name : '') . '('; $params = $n->params; for ($i = 0, $j = count($params); $i < $j; $i++) $s .= ($i ? ',' : '') . $params[$i]; $s .= '){' . $this->parseTree($n->body, true) . '}'; break; case JS_SCRIPT: $noBlockGrouping = true; case JS_BLOCK: $childs = $n->treeNodes; for ($c = 0, $i = 0, $j = count($childs); $i < $j; $i++) { $t = $this->parseTree($childs[$i]); if (strlen($t)) { if ($c) { if ($childs[$i]->type == KEYWORD_FUNCTION && $childs[$i]->functionForm == DECLARED_FORM) $s .= "\n"; else $s .= ';'; } $s .= $t; $c++; } } if ($c > 1 && !$noBlockGrouping) { $s = '{' . $s . '}'; } break; case KEYWORD_IF: $s = 'if(' . $this->parseTree($n->condition) . ')'; $thenPart = $this->parseTree($n->thenPart); $elsePart = $n->elsePart ? $this->parseTree($n->elsePart) : null; if ($thenPart[0] != '{') { if (strpos($thenPart, 'if(') !== false) $thenPart = '{' . $thenPart . '}'; elseif ($elsePart) $thenPart .= ';'; } $s .= $thenPart; if ($elsePart) { $s .= 'else'; if ($elsePart[0] != '{') $s .= ' '; $s .= $elsePart; } break; case KEYWORD_SWITCH: $s = 'switch(' . $this->parseTree($n->discriminant) . '){'; $cases = $n->cases; for ($i = 0, $j = count($cases); $i < $j; $i++) { $case = $cases[$i]; if ($case->type == KEYWORD_CASE) $s .= 'case' . ($case->caseLabel->type != TOKEN_STRING ? ' ' : '') . $this->parseTree($case->caseLabel) . ':'; else $s .= 'default:'; $statement = $this->parseTree($case->statements); if ($statement) $s .= $statement . ';'; } $s = rtrim($s, ';') . '}'; break; case KEYWORD_FOR: $s = 'for(' . ($n->setup ? $this->parseTree($n->setup) : '') . ';' . ($n->condition ? $this->parseTree($n->condition) : '') . ';' . ($n->update ? $this->parseTree($n->update) : '') . ')' . $this->parseTree($n->body); break; case KEYWORD_WHILE: $s = 'while(' . $this->parseTree($n->condition) . ')' . $this->parseTree($n->body); break; case JS_FOR_IN: $s = 'for(' . ($n->varDecl ? $this->parseTree($n->varDecl) : $this->parseTree($n->iterator)) . ' in ' . $this->parseTree($n->object) . ')' . $this->parseTree($n->body); break; case KEYWORD_DO: $s = 'do{' . $this->parseTree($n->body, true) . '}while(' . $this->parseTree($n->condition) . ')'; break; case KEYWORD_BREAK: case KEYWORD_CONTINUE: $s = $n->value . ($n->label ? ' ' . $n->label : ''); break; case KEYWORD_TRY: $s = 'try{' . $this->parseTree($n->tryBlock, true) . '}'; $catchClauses = $n->catchClauses; for ($i = 0, $j = count($catchClauses); $i < $j; $i++) { $t = $catchClauses[$i]; $s .= 'catch(' . $t->varName . ($t->guard ? ' if ' . $this->parseTree($t->guard) : '') . '){' . $this->parseTree($t->block, true) . '}'; } if ($n->finallyBlock) $s .= 'finally{' . $this->parseTree($n->finallyBlock, true) . '}'; break; case KEYWORD_THROW: $s = 'throw ' . $this->parseTree($n->exception); break; case KEYWORD_RETURN: $s = 'return' . ($n->value ? ' ' . $this->parseTree($n->value) : ''); break; case KEYWORD_WITH: $s = 'with(' . $this->parseTree($n->object) . ')' . $this->parseTree($n->body); break; case KEYWORD_VAR: case KEYWORD_CONST: $s = $n->value . ' '; $childs = $n->treeNodes; for ($i = 0, $j = count($childs); $i < $j; $i++) { $t = $childs[$i]; $s .= ($i ? ',' : '') . $t->name; $u = $t->initializer; if ($u) $s .= '=' . $this->parseTree($u); } break; case KEYWORD_DEBUGGER: throw new Exception('NOT IMPLEMENTED: DEBUGGER'); break; case TOKEN_CONDCOMMENT_MULTILINE: $s = $n->value . ' '; $childs = $n->treeNodes; for ($i = 0, $j = count($childs); $i < $j; $i++) $s .= $this->parseTree($childs[$i]); break; case OP_SEMICOLON: if ($expression = $n->expression) $s = $this->parseTree($expression); break; case JS_LABEL: $s = $n->label . ':' . $this->parseTree($n->statement); break; case OP_COMMA: $childs = $n->treeNodes; for ($i = 0, $j = count($childs); $i < $j; $i++) $s .= ($i ? ',' : '') . $this->parseTree($childs[$i]); break; case OP_ASSIGN: $s = $this->parseTree($n->treeNodes[0]) . $n->value . $this->parseTree($n->treeNodes[1]); break; case OP_HOOK: $s = $this->parseTree($n->treeNodes[0]) . '?' . $this->parseTree($n->treeNodes[1]) . ':' . $this->parseTree($n->treeNodes[2]); break; case OP_OR: case OP_AND: case OP_BITWISE_OR: case OP_BITWISE_XOR: case OP_BITWISE_AND: case OP_EQ: case OP_NE: case OP_STRICT_EQ: case OP_STRICT_NE: case OP_LT: case OP_LE: case OP_GE: case OP_GT: case OP_LSH: case OP_RSH: case OP_URSH: case OP_MUL: case OP_DIV: case OP_MOD: $s = $this->parseTree($n->treeNodes[0]) . $n->type . $this->parseTree($n->treeNodes[1]); break; case OP_PLUS: case OP_MINUS: $s = $this->parseTree($n->treeNodes[0]) . $n->type; $nextTokenType = $n->treeNodes[1]->type; if ( $nextTokenType == OP_PLUS || $nextTokenType == OP_MINUS || $nextTokenType == OP_INCREMENT || $nextTokenType == OP_DECREMENT || $nextTokenType == OP_UNARY_PLUS || $nextTokenType == OP_UNARY_MINUS ) $s .= ' '; $s .= $this->parseTree($n->treeNodes[1]); break; case KEYWORD_IN: $s = $this->parseTree($n->treeNodes[0]) . ' in ' . $this->parseTree($n->treeNodes[1]); break; case KEYWORD_INSTANCEOF: $s = $this->parseTree($n->treeNodes[0]) . ' instanceof ' . $this->parseTree($n->treeNodes[1]); break; case KEYWORD_DELETE: $s = 'delete ' . $this->parseTree($n->treeNodes[0]); break; case KEYWORD_VOID: $s = 'void(' . $this->parseTree($n->treeNodes[0]) . ')'; break; case KEYWORD_TYPEOF: $s = 'typeof ' . $this->parseTree($n->treeNodes[0]); break; case OP_NOT: case OP_BITWISE_NOT: case OP_UNARY_PLUS: case OP_UNARY_MINUS: $s = $n->value . $this->parseTree($n->treeNodes[0]); break; case OP_INCREMENT: case OP_DECREMENT: if ($n->postfix) $s = $this->parseTree($n->treeNodes[0]) . $n->value; else $s = $n->value . $this->parseTree($n->treeNodes[0]); break; case OP_DOT: $s = $this->parseTree($n->treeNodes[0]) . '.' . $this->parseTree($n->treeNodes[1]); break; case JS_INDEX: $s = $this->parseTree($n->treeNodes[0]); if ( $n->treeNodes[0]->type == TOKEN_IDENTIFIER && $n->treeNodes[1]->type == TOKEN_STRING && $this->isValidIdentifier(substr($n->treeNodes[1]->value, 1, -1)) ) $s .= '.' . substr($n->treeNodes[1]->value, 1, -1); else $s .= '[' . $this->parseTree($n->treeNodes[1]) . ']'; break; case JS_LIST: $childs = $n->treeNodes; for ($i = 0, $j = count($childs); $i < $j; $i++) $s .= ($i ? ',' : '') . $this->parseTree($childs[$i]); break; case JS_CALL: $s = $this->parseTree($n->treeNodes[0]) . '(' . $this->parseTree($n->treeNodes[1]) . ')'; break; case KEYWORD_NEW: case JS_NEW_WITH_ARGS: $s = 'new ' . $this->parseTree($n->treeNodes[0]) . '(' . ($n->type == JS_NEW_WITH_ARGS ? $this->parseTree($n->treeNodes[1]) : '') . ')'; break; case JS_ARRAY_INIT: $s = '['; $childs = $n->treeNodes; for ($i = 0, $j = count($childs); $i < $j; $i++) { $s .= ($i ? ',' : '') . $this->parseTree($childs[$i]); } $s .= ']'; break; case JS_OBJECT_INIT: $s = '{'; $childs = $n->treeNodes; for ($i = 0, $j = count($childs); $i < $j; $i++) { $t = $childs[$i]; if ($i) $s .= ','; if ($t->type == JS_PROPERTY_INIT) { if ( $t->treeNodes[0]->type == TOKEN_STRING && $this->isValidIdentifier(substr($t->treeNodes[0]->value, 1, -1)) ) $s .= substr($t->treeNodes[0]->value, 1, -1); else $s .= $t->treeNodes[0]->value; $s .= ':' . $this->parseTree($t->treeNodes[1]); } else { $s .= $t->type == JS_GETTER ? 'get' : 'set'; $s .= ' ' . $t->name . '('; $params = $t->params; for ($i = 0, $j = count($params); $i < $j; $i++) $s .= ($i ? ',' : '') . $params[$i]; $s .= '){' . $this->parseTree($t->body, true) . '}'; } } $s .= '}'; break; case KEYWORD_NULL: case KEYWORD_THIS: case KEYWORD_TRUE: case KEYWORD_FALSE: case TOKEN_IDENTIFIER: case TOKEN_NUMBER: case TOKEN_STRING: case TOKEN_REGEXP: $s = $n->value; break; case JS_GROUP: $s = '(' . $this->parseTree($n->treeNodes[0]) . ')'; break; default: throw new Exception('UNKNOWN TOKEN TYPE: ' . $n->type); } return $s; } private function isValidIdentifier($string) { return preg_match('/^[a-zA-Z_][a-zA-Z0-9_]*$/', $string) && !in_array($string, $this->reserved); } } class JSParser { private $t; private $opPrecedence = array( ';' => 0, ',' => 1, '=' => 2, '?' => 2, ':' => 2, '||' => 4, '&&' => 5, '|' => 6, '^' => 7, '&' => 8, '==' => 9, '!=' => 9, '===' => 9, '!==' => 9, '<' => 10, '<=' => 10, '>=' => 10, '>' => 10, 'in' => 10, 'instanceof' => 10, '<<' => 11, '>>' => 11, '>>>' => 11, '+' => 12, '-' => 12, '*' => 13, '/' => 13, '%' => 13, 'delete' => 14, 'void' => 14, 'typeof' => 14, '!' => 14, '~' => 14, 'U+' => 14, 'U-' => 14, '++' => 15, '--' => 15, 'new' => 16, '.' => 17, JS_NEW_WITH_ARGS => 0, JS_INDEX => 0, JS_CALL => 0, JS_ARRAY_INIT => 0, JS_OBJECT_INIT => 0, JS_GROUP => 0 ); private $opArity = array( ',' => -2, '=' => 2, '?' => 3, '||' => 2, '&&' => 2, '|' => 2, '^' => 2, '&' => 2, '==' => 2, '!=' => 2, '===' => 2, '!==' => 2, '<' => 2, '<=' => 2, '>=' => 2, '>' => 2, 'in' => 2, 'instanceof' => 2, '<<' => 2, '>>' => 2, '>>>' => 2, '+' => 2, '-' => 2, '*' => 2, '/' => 2, '%' => 2, 'delete' => 1, 'void' => 1, 'typeof' => 1, '!' => 1, '~' => 1, 'U+' => 1, 'U-' => 1, '++' => 1, '--' => 1, 'new' => 1, '.' => 2, JS_NEW_WITH_ARGS => 2, JS_INDEX => 2, JS_CALL => 2, JS_ARRAY_INIT => 1, JS_OBJECT_INIT => 1, JS_GROUP => 1, TOKEN_CONDCOMMENT_MULTILINE => 1 ); public function __construct() { $this->t = new JSTokenizer(); } public function parse($s, $f, $l) { $this->t->init($s, $f, $l); $x = new JSCompilerContext(false); $n = $this->Script($x); if (!$this->t->isDone()) throw $this->t->newSyntaxError('Syntax error'); return $n; } private function Script($x) { $n = $this->Statements($x); $n->type = JS_SCRIPT; $n->funDecls = $x->funDecls; $n->varDecls = $x->varDecls; return $n; } private function Statements($x) { $n = new JSNode($this->t, JS_BLOCK); array_push($x->stmtStack, $n); while (!$this->t->isDone() && $this->t->peek() != OP_RIGHT_CURLY) $n->addNode($this->Statement($x)); array_pop($x->stmtStack); return $n; } private function Block($x) { $this->t->mustMatch(OP_LEFT_CURLY); $n = $this->Statements($x); $this->t->mustMatch(OP_RIGHT_CURLY); return $n; } private function Statement($x) { $tt = $this->t->get(); $n2 = null; switch ($tt) { case KEYWORD_FUNCTION: return $this->FunctionDefinition( $x, true, count($x->stmtStack) > 1 ? STATEMENT_FORM : DECLARED_FORM ); break; case OP_LEFT_CURLY: $n = $this->Statements($x); $this->t->mustMatch(OP_RIGHT_CURLY); return $n; case KEYWORD_IF: $n = new JSNode($this->t); $n->condition = $this->ParenExpression($x); array_push($x->stmtStack, $n); $n->thenPart = $this->Statement($x); $n->elsePart = $this->t->match(KEYWORD_ELSE) ? $this->Statement($x) : null; array_pop($x->stmtStack); return $n; case KEYWORD_SWITCH: $n = new JSNode($this->t); $this->t->mustMatch(OP_LEFT_PAREN); $n->discriminant = $this->Expression($x); $this->t->mustMatch(OP_RIGHT_PAREN); $n->cases = array(); $n->defaultIndex = -1; array_push($x->stmtStack, $n); $this->t->mustMatch(OP_LEFT_CURLY); while (($tt = $this->t->get()) != OP_RIGHT_CURLY) { switch ($tt) { case KEYWORD_DEFAULT: if ($n->defaultIndex >= 0) throw $this->t->newSyntaxError('More than one switch default'); case KEYWORD_CASE: $n2 = new JSNode($this->t); if ($tt == KEYWORD_DEFAULT) $n->defaultIndex = count($n->cases); else $n2->caseLabel = $this->Expression($x, OP_COLON); break; default: throw $this->t->newSyntaxError('Invalid switch case'); } $this->t->mustMatch(OP_COLON); $n2->statements = new JSNode($this->t, JS_BLOCK); while (($tt = $this->t->peek()) != KEYWORD_CASE && $tt != KEYWORD_DEFAULT && $tt != OP_RIGHT_CURLY) $n2->statements->addNode($this->Statement($x)); array_push($n->cases, $n2); } array_pop($x->stmtStack); return $n; case KEYWORD_FOR: $n = new JSNode($this->t); $n->isLoop = true; $this->t->mustMatch(OP_LEFT_PAREN); if (($tt = $this->t->peek()) != OP_SEMICOLON) { $x->inForLoopInit = true; if ($tt == KEYWORD_VAR || $tt == KEYWORD_CONST) { $this->t->get(); $n2 = $this->Variables($x); } else { $n2 = $this->Expression($x); } $x->inForLoopInit = false; } if ($n2 && $this->t->match(KEYWORD_IN)) { $n->type = JS_FOR_IN; if ($n2->type == KEYWORD_VAR) { if (count($n2->treeNodes) != 1) { throw $this->t->SyntaxError( 'Invalid for..in left-hand side', $this->t->filename, $n2->lineno ); } $n->iterator = $n2->treeNodes[0]; $n->varDecl = $n2; } else { $n->iterator = $n2; $n->varDecl = null; } $n->object = $this->Expression($x); } else { $n->setup = $n2 ? $n2 : null; $this->t->mustMatch(OP_SEMICOLON); $n->condition = $this->t->peek() == OP_SEMICOLON ? null : $this->Expression($x); $this->t->mustMatch(OP_SEMICOLON); $n->update = $this->t->peek() == OP_RIGHT_PAREN ? null : $this->Expression($x); } $this->t->mustMatch(OP_RIGHT_PAREN); $n->body = $this->nest($x, $n); return $n; case KEYWORD_WHILE: $n = new JSNode($this->t); $n->isLoop = true; $n->condition = $this->ParenExpression($x); $n->body = $this->nest($x, $n); return $n; case KEYWORD_DO: $n = new JSNode($this->t); $n->isLoop = true; $n->body = $this->nest($x, $n, KEYWORD_WHILE); $n->condition = $this->ParenExpression($x); if (!$x->ecmaStrictMode) { $this->t->match(OP_SEMICOLON); return $n; } break; case KEYWORD_BREAK: case KEYWORD_CONTINUE: $n = new JSNode($this->t); if ($this->t->peekOnSameLine() == TOKEN_IDENTIFIER) { $this->t->get(); $n->label = $this->t->currentToken()->value; } $ss = $x->stmtStack; $i = count($ss); $label = $n->label; if ($label) { do { if (--$i < 0) throw $this->t->newSyntaxError('Label not found'); } while ($ss[$i]->label != $label); } else { do { if (--$i < 0) throw $this->t->newSyntaxError('Invalid ' . $tt); } while (!$ss[$i]->isLoop && ($tt != KEYWORD_BREAK || $ss[$i]->type != KEYWORD_SWITCH)); } $n->target = $ss[$i]; break; case KEYWORD_TRY: $n = new JSNode($this->t); $n->tryBlock = $this->Block($x); $n->catchClauses = array(); while ($this->t->match(KEYWORD_CATCH)) { $n2 = new JSNode($this->t); $this->t->mustMatch(OP_LEFT_PAREN); $n2->varName = $this->t->mustMatch(TOKEN_IDENTIFIER)->value; if ($this->t->match(KEYWORD_IF)) { if ($x->ecmaStrictMode) throw $this->t->newSyntaxError('Illegal catch guard'); if (count($n->catchClauses) && !end($n->catchClauses)->guard) throw $this->t->newSyntaxError('Guarded catch after unguarded'); $n2->guard = $this->Expression($x); } else { $n2->guard = null; } $this->t->mustMatch(OP_RIGHT_PAREN); $n2->block = $this->Block($x); array_push($n->catchClauses, $n2); } if ($this->t->match(KEYWORD_FINALLY)) $n->finallyBlock = $this->Block($x); if (!count($n->catchClauses) && !$n->finallyBlock) throw $this->t->newSyntaxError('Invalid try statement'); return $n; case KEYWORD_CATCH: case KEYWORD_FINALLY: throw $this->t->newSyntaxError($tt + ' without preceding try'); case KEYWORD_THROW: $n = new JSNode($this->t); $n->exception = $this->Expression($x); break; case KEYWORD_RETURN: if (!$x->inFunction) throw $this->t->newSyntaxError('Invalid return'); $n = new JSNode($this->t); $tt = $this->t->peekOnSameLine(); if ($tt != TOKEN_END && $tt != TOKEN_NEWLINE && $tt != OP_SEMICOLON && $tt != OP_RIGHT_CURLY) $n->value = $this->Expression($x); else $n->value = null; break; case KEYWORD_WITH: $n = new JSNode($this->t); $n->object = $this->ParenExpression($x); $n->body = $this->nest($x, $n); return $n; case KEYWORD_VAR: case KEYWORD_CONST: $n = $this->Variables($x); break; case TOKEN_CONDCOMMENT_MULTILINE: $n = new JSNode($this->t); return $n; case KEYWORD_DEBUGGER: $n = new JSNode($this->t); break; case TOKEN_NEWLINE: case OP_SEMICOLON: $n = new JSNode($this->t, OP_SEMICOLON); $n->expression = null; return $n; default: if ($tt == TOKEN_IDENTIFIER) { $this->t->scanOperand = false; $tt = $this->t->peek(); $this->t->scanOperand = true; if ($tt == OP_COLON) { $label = $this->t->currentToken()->value; $ss = $x->stmtStack; for ($i = count($ss) - 1; $i >= 0; --$i) { if ($ss[$i]->label == $label) throw $this->t->newSyntaxError('Duplicate label'); } $this->t->get(); $n = new JSNode($this->t, JS_LABEL); $n->label = $label; $n->statement = $this->nest($x, $n); return $n; } } $n = new JSNode($this->t, OP_SEMICOLON); $this->t->unget(); $n->expression = $this->Expression($x); $n->end = $n->expression->end; break; } if ($this->t->lineno == $this->t->currentToken()->lineno) { $tt = $this->t->peekOnSameLine(); if ($tt != TOKEN_END && $tt != TOKEN_NEWLINE && $tt != OP_SEMICOLON && $tt != OP_RIGHT_CURLY) throw $this->t->newSyntaxError('Missing ; before statement'); } $this->t->match(OP_SEMICOLON); return $n; } private function FunctionDefinition($x, $requireName, $functionForm) { $f = new JSNode($this->t); if ($f->type != KEYWORD_FUNCTION) $f->type = ($f->value == 'get') ? JS_GETTER : JS_SETTER; if ($this->t->match(TOKEN_IDENTIFIER)) $f->name = $this->t->currentToken()->value; elseif ($requireName) throw $this->t->newSyntaxError('Missing function identifier'); $this->t->mustMatch(OP_LEFT_PAREN); $f->params = array(); while (($tt = $this->t->get()) != OP_RIGHT_PAREN) { if ($tt != TOKEN_IDENTIFIER) throw $this->t->newSyntaxError('Missing formal parameter'); array_push($f->params, $this->t->currentToken()->value); if ($this->t->peek() != OP_RIGHT_PAREN) $this->t->mustMatch(OP_COMMA); } $this->t->mustMatch(OP_LEFT_CURLY); $x2 = new JSCompilerContext(true); $f->body = $this->Script($x2); $this->t->mustMatch(OP_RIGHT_CURLY); $f->end = $this->t->currentToken()->end; $f->functionForm = $functionForm; if ($functionForm == DECLARED_FORM) array_push($x->funDecls, $f); return $f; } private function Variables($x) { $n = new JSNode($this->t); do { $this->t->mustMatch(TOKEN_IDENTIFIER); $n2 = new JSNode($this->t); $n2->name = $n2->value; if ($this->t->match(OP_ASSIGN)) { if ($this->t->currentToken()->assignOp) throw $this->t->newSyntaxError('Invalid variable initialization'); $n2->initializer = $this->Expression($x, OP_COMMA); } $n2->readOnly = $n->type == KEYWORD_CONST; $n->addNode($n2); array_push($x->varDecls, $n2); } while ($this->t->match(OP_COMMA)); return $n; } private function Expression($x, $stop=false) { $operators = array(); $operands = array(); $n = false; $bl = $x->bracketLevel; $cl = $x->curlyLevel; $pl = $x->parenLevel; $hl = $x->hookLevel; while (($tt = $this->t->get()) != TOKEN_END) { if ($tt == $stop && $x->bracketLevel == $bl && $x->curlyLevel == $cl && $x->parenLevel == $pl && $x->hookLevel == $hl ) { break; } switch ($tt) { case OP_SEMICOLON: break 2; case OP_ASSIGN: case OP_HOOK: case OP_COLON: if ($this->t->scanOperand) break 2; while ( !empty($operators) && ( $this->opPrecedence[end($operators)->type] > $this->opPrecedence[$tt] || ($tt == OP_COLON && end($operators)->type == OP_ASSIGN) ) ) $this->reduce($operators, $operands); if ($tt == OP_COLON) { $n = end($operators); if ($n->type != OP_HOOK) throw $this->t->newSyntaxError('Invalid label'); --$x->hookLevel; } else { array_push($operators, new JSNode($this->t)); if ($tt == OP_ASSIGN) end($operands)->assignOp = $this->t->currentToken()->assignOp; else ++$x->hookLevel; } $this->t->scanOperand = true; break; case KEYWORD_IN: if ($x->inForLoopInit && !$x->hookLevel && !$x->bracketLevel && !$x->curlyLevel && !$x->parenLevel ) { break 2; } case OP_COMMA: case OP_OR: case OP_AND: case OP_BITWISE_OR: case OP_BITWISE_XOR: case OP_BITWISE_AND: case OP_EQ: case OP_NE: case OP_STRICT_EQ: case OP_STRICT_NE: case OP_LT: case OP_LE: case OP_GE: case OP_GT: case KEYWORD_INSTANCEOF: case OP_LSH: case OP_RSH: case OP_URSH: case OP_PLUS: case OP_MINUS: case OP_MUL: case OP_DIV: case OP_MOD: case OP_DOT: if ($this->t->scanOperand) break 2; while ( !empty($operators) && $this->opPrecedence[end($operators)->type] >= $this->opPrecedence[$tt] ) $this->reduce($operators, $operands); if ($tt == OP_DOT) { $this->t->mustMatch(TOKEN_IDENTIFIER); array_push($operands, new JSNode($this->t, OP_DOT, array_pop($operands), new JSNode($this->t))); } else { array_push($operators, new JSNode($this->t)); $this->t->scanOperand = true; } break; case KEYWORD_DELETE: case KEYWORD_VOID: case KEYWORD_TYPEOF: case OP_NOT: case OP_BITWISE_NOT: case OP_UNARY_PLUS: case OP_UNARY_MINUS: case KEYWORD_NEW: if (!$this->t->scanOperand) break 2; array_push($operators, new JSNode($this->t)); break; case OP_INCREMENT: case OP_DECREMENT: if ($this->t->scanOperand) { array_push($operators, new JSNode($this->t)); } else { $t = $this->t->tokens[($this->t->tokenIndex + $this->t->lookahead - 1) & 3]; if ($t && $t->lineno != $this->t->lineno) break 2; if (!empty($operators)) { while ($this->opPrecedence[end($operators)->type] > $this->opPrecedence[$tt]) $this->reduce($operators, $operands); } $n = new JSNode($this->t, $tt, array_pop($operands)); $n->postfix = true; array_push($operands, $n); } break; case KEYWORD_FUNCTION: if (!$this->t->scanOperand) break 2; array_push($operands, $this->FunctionDefinition($x, false, EXPRESSED_FORM)); $this->t->scanOperand = false; break; case KEYWORD_NULL: case KEYWORD_THIS: case KEYWORD_TRUE: case KEYWORD_FALSE: case TOKEN_IDENTIFIER: case TOKEN_NUMBER: case TOKEN_STRING: case TOKEN_REGEXP: if (!$this->t->scanOperand) break 2; array_push($operands, new JSNode($this->t)); $this->t->scanOperand = false; break; case TOKEN_CONDCOMMENT_MULTILINE: if ($this->t->scanOperand) array_push($operators, new JSNode($this->t)); else array_push($operands, new JSNode($this->t)); break; case OP_LEFT_BRACKET: if ($this->t->scanOperand) { $n = new JSNode($this->t, JS_ARRAY_INIT); while (($tt = $this->t->peek()) != OP_RIGHT_BRACKET) { if ($tt == OP_COMMA) { $this->t->get(); $n->addNode(null); continue; } $n->addNode($this->Expression($x, OP_COMMA)); if (!$this->t->match(OP_COMMA)) break; } $this->t->mustMatch(OP_RIGHT_BRACKET); array_push($operands, $n); $this->t->scanOperand = false; } else { array_push($operators, new JSNode($this->t, JS_INDEX)); $this->t->scanOperand = true; ++$x->bracketLevel; } break; case OP_RIGHT_BRACKET: if ($this->t->scanOperand || $x->bracketLevel == $bl) break 2; while ($this->reduce($operators, $operands)->type != JS_INDEX) continue; --$x->bracketLevel; break; case OP_LEFT_CURLY: if (!$this->t->scanOperand) break 2; ++$x->curlyLevel; $n = new JSNode($this->t, JS_OBJECT_INIT); while (!$this->t->match(OP_RIGHT_CURLY)) { do { $tt = $this->t->get(); $tv = $this->t->currentToken()->value; if (($tv == 'get' || $tv == 'set') && $this->t->peek() == TOKEN_IDENTIFIER) { if ($x->ecmaStrictMode) throw $this->t->newSyntaxError('Illegal property accessor'); $n->addNode($this->FunctionDefinition($x, true, EXPRESSED_FORM)); } else { switch ($tt) { case TOKEN_IDENTIFIER: case TOKEN_NUMBER: case TOKEN_STRING: $id = new JSNode($this->t); break; case OP_RIGHT_CURLY: if ($x->ecmaStrictMode) throw $this->t->newSyntaxError('Illegal trailing ,'); break 3; default: throw $this->t->newSyntaxError('Invalid property name'); } $this->t->mustMatch(OP_COLON); $n->addNode(new JSNode($this->t, JS_PROPERTY_INIT, $id, $this->Expression($x, OP_COMMA))); } } while ($this->t->match(OP_COMMA)); $this->t->mustMatch(OP_RIGHT_CURLY); break; } array_push($operands, $n); $this->t->scanOperand = false; --$x->curlyLevel; break; case OP_RIGHT_CURLY: if (!$this->t->scanOperand && $x->curlyLevel != $cl) throw new Exception('PANIC: right curly botch'); break 2; case OP_LEFT_PAREN: if ($this->t->scanOperand) { array_push($operators, new JSNode($this->t, JS_GROUP)); } else { while ( !empty($operators) && $this->opPrecedence[end($operators)->type] > $this->opPrecedence[KEYWORD_NEW] ) $this->reduce($operators, $operands); $n = end($operators); $this->t->scanOperand = true; if ($this->t->match(OP_RIGHT_PAREN)) { if ($n && $n->type == KEYWORD_NEW) { array_pop($operators); $n->addNode(array_pop($operands)); } else { $n = new JSNode($this->t, JS_CALL, array_pop($operands), new JSNode($this->t, JS_LIST)); } array_push($operands, $n); $this->t->scanOperand = false; break; } if ($n && $n->type == KEYWORD_NEW) $n->type = JS_NEW_WITH_ARGS; else array_push($operators, new JSNode($this->t, JS_CALL)); } ++$x->parenLevel; break; case OP_RIGHT_PAREN: if ($this->t->scanOperand || $x->parenLevel == $pl) break 2; while (($tt = $this->reduce($operators, $operands)->type) != JS_GROUP && $tt != JS_CALL && $tt != JS_NEW_WITH_ARGS ) { continue; } if ($tt != JS_GROUP) { $n = end($operands); if ($n->treeNodes[1]->type != OP_COMMA) $n->treeNodes[1] = new JSNode($this->t, JS_LIST, $n->treeNodes[1]); else $n->treeNodes[1]->type = JS_LIST; } --$x->parenLevel; break; default: break 2; } } if ($x->hookLevel != $hl) throw $this->t->newSyntaxError('Missing : after ?'); if ($x->parenLevel != $pl) throw $this->t->newSyntaxError('Missing ) in parenthetical'); if ($x->bracketLevel != $bl) throw $this->t->newSyntaxError('Missing ] in index expression'); if ($this->t->scanOperand) throw $this->t->newSyntaxError('Missing operand'); $this->t->scanOperand = true; $this->t->unget(); while (count($operators)) $this->reduce($operators, $operands); return array_pop($operands); } private function ParenExpression($x) { $this->t->mustMatch(OP_LEFT_PAREN); $n = $this->Expression($x); $this->t->mustMatch(OP_RIGHT_PAREN); return $n; } private function nest($x, $node, $end = false) { array_push($x->stmtStack, $node); $n = $this->statement($x); array_pop($x->stmtStack); if ($end) $this->t->mustMatch($end); return $n; } private function reduce($operators, $operands) { $n = array_pop($operators); $op = $n->type; $arity = $this->opArity[$op]; $c = count($operands); if ($arity == -2) { if ($c >= 2) { $left = $operands[$c - 2]; if ($left->type == $op) { $right = array_pop($operands); $left->addNode($right); return $left; } } $arity = 2; } $a = array_splice($operands, $c - $arity); for ($i = 0; $i < $arity; $i++) $n->addNode($a[$i]); $te = $this->t->currentToken()->end; if ($n->end < $te) $n->end = $te; array_push($operands, $n); return $n; } } class JSCompilerContext { public $inFunction = false; public $inForLoopInit = false; public $ecmaStrictMode = false; public $bracketLevel = 0; public $curlyLevel = 0; public $parenLevel = 0; public $hookLevel = 0; public $stmtStack = array(); public $funDecls = array(); public $varDecls = array(); public function __construct($inFunction) { $this->inFunction = $inFunction; } } class JSNode { private $type; private $value; private $lineno; private $start; private $end; public $treeNodes = array(); public $funDecls = array(); public $varDecls = array(); public function __construct($t, $type=0) { if ($token = $t->currentToken()) { $this->type = $type ? $type : $token->type; $this->value = $token->value; $this->lineno = $token->lineno; $this->start = $token->start; $this->end = $token->end; } else { $this->type = $type; $this->lineno = $t->lineno; } if (($numargs = func_num_args()) > 2) { $args = func_get_args();; for ($i = 2; $i < $numargs; $i++) $this->addNode($args[$i]); } } public function __set($name, $value) { $this->$name = $value; } public function __get($name) { if (isset($this->$name)) return $this->$name; return null; } public function addNode($node) { $this->treeNodes[] = $node; } } class JSTokenizer { private $cursor = 0; private $source; public $tokens = array(); public $tokenIndex = 0; public $lookahead = 0; public $scanNewlines = false; public $scanOperand = true; public $filename; public $lineno; private $keywords = array( 'break', 'case', 'catch', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'false', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'null', 'return', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with' ); private $opTypeNames = array( ';' => 'SEMICOLON', ',' => 'COMMA', '?' => 'HOOK', ':' => 'COLON', '||' => 'OR', '&&' => 'AND', '|' => 'BITWISE_OR', '^' => 'BITWISE_XOR', '&' => 'BITWISE_AND', '===' => 'STRICT_EQ', '==' => 'EQ', '=' => 'ASSIGN', '!==' => 'STRICT_NE', '!=' => 'NE', '<<' => 'LSH', '<=' => 'LE', '<' => 'LT', '>>>' => 'URSH', '>>' => 'RSH', '>=' => 'GE', '>' => 'GT', '++' => 'INCREMENT', '--' => 'DECREMENT', '+' => 'PLUS', '-' => 'MINUS', '*' => 'MUL', '/' => 'DIV', '%' => 'MOD', '!' => 'NOT', '~' => 'BITWISE_NOT', '.' => 'DOT', '[' => 'LEFT_BRACKET', ']' => 'RIGHT_BRACKET', '{' => 'LEFT_CURLY', '}' => 'RIGHT_CURLY', '(' => 'LEFT_PAREN', ')' => 'RIGHT_PAREN', '@*/' => 'CONDCOMMENT_END' ); private $assignOps = array('|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'); private $opRegExp; public function __construct() { $this->opRegExp = '#^(' . implode('|', array_map('preg_quote', array_keys($this->opTypeNames))) . ')#'; foreach ($this->opTypeNames as $operand => $name) define('OP_' . $name, $operand); define('OP_UNARY_PLUS', 'U+'); define('OP_UNARY_MINUS', 'U-'); foreach ($this->keywords as $keyword) define('KEYWORD_' . strtoupper($keyword), $keyword); } public function init($source, $filename = '', $lineno = 1) { $this->source = $source; $this->filename = $filename ? $filename : '[inline]'; $this->lineno = $lineno; $this->cursor = 0; $this->tokens = array(); $this->tokenIndex = 0; $this->lookahead = 0; $this->scanNewlines = false; $this->scanOperand = true; } public function getInput($chunksize) { if ($chunksize) return substr($this->source, $this->cursor, $chunksize); return substr($this->source, $this->cursor); } public function isDone() { return $this->peek() == TOKEN_END; } public function match($tt) { return $this->get() == $tt || $this->unget(); } public function mustMatch($tt) { if (!$this->match($tt)) throw $this->newSyntaxError('Unexpected token; token ' . $tt . ' expected'); return $this->currentToken(); } public function peek() { if ($this->lookahead) { $next = $this->tokens[($this->tokenIndex + $this->lookahead) & 3]; if ($this->scanNewlines && $next->lineno != $this->lineno) $tt = TOKEN_NEWLINE; else $tt = $next->type; } else { $tt = $this->get(); $this->unget(); } return $tt; } public function peekOnSameLine() { $this->scanNewlines = true; $tt = $this->peek(); $this->scanNewlines = false; return $tt; } public function currentToken() { if (!empty($this->tokens)) return $this->tokens[$this->tokenIndex]; } public function get($chunksize = 1000) { while($this->lookahead) { $this->lookahead--; $this->tokenIndex = ($this->tokenIndex + 1) & 3; $token = $this->tokens[$this->tokenIndex]; if ($token->type != TOKEN_NEWLINE || $this->scanNewlines) return $token->type; } $conditional_comment = false; while(true) { $input = $this->getInput($chunksize); $re = $this->scanNewlines ? '/^[ \r\t]+/' : '/^\s+/'; if (preg_match($re, $input, $match)) { $spaces = $match[0]; $spacelen = strlen($spaces); $this->cursor += $spacelen; if (!$this->scanNewlines) $this->lineno += substr_count($spaces, "\n"); if ($spacelen == $chunksize) continue; $input = $this->getInput($chunksize); if ($input == '' || $input[0] != '/') break; } if (!preg_match('/^\/(?:\*(@(?:cc_on|if|elif|else|end))?(?:.|\n)*?\*\/|\/.*)/', $input, $match)) { if (!$chunksize) break; $chunksize = null; continue; } if (!empty($match[1])) { $conditional_comment = true; break; } else { $this->cursor += strlen($match[0]); $this->lineno += substr_count($match[0], "\n"); } } if ($input == '') { $tt = TOKEN_END; $match = array(''); } elseif ($conditional_comment) { $tt = TOKEN_CONDCOMMENT_MULTILINE; } else { switch ($input[0]) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': if (preg_match('/^\d+\.\d*(?:[eE][-+]?\d+)?|^\d+(?:\.\d*)?[eE][-+]?\d+/', $input, $match)) { $tt = TOKEN_NUMBER; } elseif (preg_match('/^0[xX][\da-fA-F]+|^0[0-7]*|^\d+/', $input, $match)) { $tt = TOKEN_NUMBER; } break; case '"': case "'": if (preg_match('/^"(?:\\\\(?:.|\r?\n)|[^\\\\"\r\n])*"|^\'(?:\\\\(?:.|\r?\n)|[^\\\\\'\r\n])*\'/', $input, $match)) { $tt = TOKEN_STRING; } else { if ($chunksize) return $this->get(null); throw $this->newSyntaxError('Unterminated string literal'); } break; case '/': if ($this->scanOperand && preg_match('/^\/((?:\\\\.|\[(?:\\\\.|[^\]])*\]|[^\/])+)\/([gimy]*)/', $input, $match)) { $tt = TOKEN_REGEXP; break; } case '|': case '^': case '&': case '<': case '>': case '+': case '-': case '*': case '%': case '=': case '!': preg_match($this->opRegExp, $input, $match); $op = $match[0]; if (in_array($op, $this->assignOps) && $input[strlen($op)] == '=') { $tt = OP_ASSIGN; $match[0] .= '='; } else { $tt = $op; if ($this->scanOperand) { if ($op == OP_PLUS) $tt = OP_UNARY_PLUS; elseif ($op == OP_MINUS) $tt = OP_UNARY_MINUS; } $op = null; } break; case '.': if (preg_match('/^\.\d+(?:[eE][-+]?\d+)?/', $input, $match)) { $tt = TOKEN_NUMBER; break; } case ';': case ',': case '?': case ':': case '~': case '[': case ']': case '{': case '}': case '(': case ')': $match = array($input[0]); $tt = $input[0]; break; case '@': throw $this->newSyntaxError('Illegal token'); break; case "\n": if ($this->scanNewlines) { $match = array("\n"); $tt = TOKEN_NEWLINE; } else throw $this->newSyntaxError('Illegal token'); break; default: if (preg_match('/^[$\w]+/', $input, $match)) { $tt = in_array($match[0], $this->keywords) ? $match[0] : TOKEN_IDENTIFIER; } else throw $this->newSyntaxError('Illegal token'); } } $this->tokenIndex = ($this->tokenIndex + 1) & 3; if (!isset($this->tokens[$this->tokenIndex])) $this->tokens[$this->tokenIndex] = new JSToken(); $token = $this->tokens[$this->tokenIndex]; $token->type = $tt; if ($tt == OP_ASSIGN) $token->assignOp = $op; $token->start = $this->cursor; $token->value = $match[0]; $this->cursor += strlen($match[0]); $token->end = $this->cursor; $token->lineno = $this->lineno; return $tt; } public function unget() { if (++$this->lookahead == 4) throw $this->newSyntaxError('PANIC: too much lookahead!'); $this->tokenIndex = ($this->tokenIndex - 1) & 3; } public function newSyntaxError($m) { return new Exception('Parse error: ' . $m . ' in file \'' . $this->filename . '\' on line ' . $this->lineno); } } class JSToken { public $type; public $value; public $start; public $end; public $lineno; public $assignOp; }   class Minify_Lines { public static function minify($content, $options = array()) { $id = (isset($options['id']) && $options['id']) ? $options['id'] : ''; $content = str_replace("\r\n", "\n", $content); $lines = explode("\n", $content); $numLines = count($lines); $padTo = strlen($numLines); $inComment = false; $i = 0; $newLines = array(); while (null !== ($line = array_shift($lines))) { if (('' !== $id) && (0 == $i % 50)) { array_push($newLines, '', "/* {$id} */", ''); } ++$i; $newLines[] = self::_addNote($line, $i, $inComment, $padTo); $inComment = self::_eolInComment($line, $inComment); } $content = implode("\n", $newLines) . "\n"; if (isset($options['currentDir'])) { Minify_CSS_UriRewriter::$debugText = ''; $content = Minify_CSS_UriRewriter::rewrite( $content ,$options['currentDir'] ,isset($options['docRoot']) ? $options['docRoot'] : $_SERVER['DOCUMENT_ROOT'] ,isset($options['symlinks']) ? $options['symlinks'] : array() ); $content = "/* Minify_CSS_UriRewriter::\$debugText\n\n" . Minify_CSS_UriRewriter::$debugText . "*/\n" . $content; } return $content; } private static function _eolInComment($line, $inComment) { while (strlen($line)) { $search = $inComment ? '*/' : '/*'; $pos = strpos($line, $search); if (false === $pos) { return $inComment; } else { if ($pos == 0 || ($inComment ? substr($line, $pos, 3) : substr($line, $pos-1, 3)) != '*/*') { $inComment = ! $inComment; } $line = substr($line, $pos + 2); } } return $inComment; } private static function _addNote($line, $note, $inComment, $padTo) { return $inComment ? '/* ' . str_pad($note, $padTo, ' ', STR_PAD_RIGHT) . ' *| ' . $line : '/* ' . str_pad($note, $padTo, ' ', STR_PAD_RIGHT) . ' */ ' . $line; } }   class Minify_Logger { public static function setLogger($obj = null) { self::$_logger = $obj ? $obj : null; } public static function log($msg, $label = 'Minify') { if (! self::$_logger) return; self::$_logger->log($msg, $label); } private static $_logger = null; }   class Minify_Cache_Memcache { public function __construct($memcache, $expire = 0) { $this->_mc = $memcache; $this->_exp = $expire; } public function store($id, $data) { return $this->_mc->set($id, "{$_SERVER['REQUEST_TIME']}|{$data}", 0, $this->_exp); } public function getSize($id) { return $this->_fetch($id) ? strlen($this->_data) : false; } public function isValid($id, $srcMtime) { return ($this->_fetch($id) && ($this->_lm >= $srcMtime)); } public function display($id) { echo $this->_fetch($id) ? $this->_data : ''; } public function fetch($id) { return $this->_fetch($id) ? $this->_data : ''; } private $_mc = null; private $_exp = null; private $_lm = null; private $_data = null; private $_id = null; private function _fetch($id) { if ($this->_id === $id) { return true; } $ret = $this->_mc->get($id); if (false === $ret) { $this->_id = null; return false; } list($this->_lm, $this->_data) = explode('|', $ret, 2); $this->_id = $id; return true; } }   class Minify { const VERSION = '2.1.3'; const TYPE_CSS = 'text/css'; const TYPE_HTML = 'text/html'; const TYPE_JS = 'application/x-javascript'; public static $uploaderHoursBehind = 0; public static $importWarning = "/* See http://code.google.com/p/minify/wiki/CommonProblems#@imports_can_appear_in_invalid_locations_in_combined_CSS_files */\n"; public static function setCache($cache = '', $fileLocking = true) { if (is_string($cache)) { self::$_cache = new Minify_Cache_File($cache, $fileLocking); } else { self::$_cache = $cache; } } public static function serve($controller, $options = array()) { if (is_string($controller)) { $class = 'Minify_Controller_' . $controller; if (! class_exists($class, false)) { } $controller = new $class(); } $options = $controller->setupSources($options); $options = $controller->analyzeSources($options); self::$_options = $controller->mixInDefaultOptions($options); if (! $controller->sources) { if (! self::$_options['quiet']) { header(self::$_options['badRequestHeader']); echo self::$_options['badRequestHeader']; return; } else { list(,$statusCode) = explode(' ', self::$_options['badRequestHeader']); return array( 'success' => false ,'statusCode' => (int)$statusCode ,'content' => '' ,'headers' => array() ); } } self::$_controller = $controller; if (self::$_options['debug']) { self::_setupDebug($controller->sources); self::$_options['maxAge'] = 0; } if (self::$_options['encodeOutput']) { if (self::$_options['encodeMethod'] !== null) { $contentEncoding = self::$_options['encodeMethod']; } else { list(self::$_options['encodeMethod'], $contentEncoding) = HTTP_Encoder::getAcceptedEncoding(false, false); } } else { self::$_options['encodeMethod'] = ''; } $cgOptions = array( 'lastModifiedTime' => self::$_options['lastModifiedTime'] ,'isPublic' => self::$_options['isPublic'] ,'encoding' => self::$_options['encodeMethod'] ); if (self::$_options['maxAge'] > 0) { $cgOptions['maxAge'] = self::$_options['maxAge']; } $cg = new HTTP_ConditionalGet($cgOptions); if ($cg->cacheIsValid) { if (! self::$_options['quiet']) { $cg->sendHeaders(); return; } else { return array( 'success' => true ,'statusCode' => 304 ,'content' => '' ,'headers' => $cg->getHeaders() ); } } else { $headers = $cg->getHeaders(); unset($cg); } if (self::$_options['contentType'] === self::TYPE_CSS && self::$_options['rewriteCssUris']) { reset($controller->sources); while (list($key, $source) = each($controller->sources)) { if ($source->filepath && !isset($source->minifyOptions['currentDir']) && !isset($source->minifyOptions['prependRelativePath']) ) { $source->minifyOptions['currentDir'] = dirname($source->filepath); } } } if (null !== self::$_cache) { $cacheId = 'minify_' . self::_getCacheId(); $fullCacheId = (self::$_options['encodeMethod']) ? $cacheId . '.gz' : $cacheId; $cacheIsReady = self::$_cache->isValid($fullCacheId, self::$_options['lastModifiedTime']); if ($cacheIsReady) { $cacheContentLength = self::$_cache->getSize($fullCacheId); } else { $content = self::_combineMinify(); self::$_cache->store($cacheId, $content); if (function_exists('gzencode')) { self::$_cache->store($cacheId . '.gz', gzencode($content, self::$_options['encodeLevel'])); } } } else { $cacheIsReady = false; $content = self::_combineMinify(); } if (! $cacheIsReady && self::$_options['encodeMethod']) { $content = gzencode($content, self::$_options['encodeLevel']); } $headers['Content-Length'] = $cacheIsReady ? $cacheContentLength : strlen($content); $headers['Content-Type'] = self::$_options['contentTypeCharset'] ? self::$_options['contentType'] . '; charset=' . self::$_options['contentTypeCharset'] : self::$_options['contentType']; if (self::$_options['encodeMethod'] !== '') { $headers['Content-Encoding'] = $contentEncoding; } if (self::$_options['encodeOutput']) { $headers['Vary'] = 'Accept-Encoding'; } if (! self::$_options['quiet']) { foreach ($headers as $name => $val) { header($name . ': ' . $val); } if ($cacheIsReady) { self::$_cache->display($fullCacheId); } else { echo $content; } } else { return array( 'success' => true ,'statusCode' => 200 ,'content' => $cacheIsReady ? self::$_cache->fetch($fullCacheId) : $content ,'headers' => $headers ); } } public static function combine($sources, $options = array()) { $cache = self::$_cache; self::$_cache = null; $options = array_merge(array( 'files' => (array)$sources ,'quiet' => true ,'encodeMethod' => '' ,'lastModifiedTime' => 0 ), $options); $out = self::serve('Files', $options); self::$_cache = $cache; return $out['content']; } public static function setDocRoot($unsetPathInfo = false) { if (isset($_SERVER['SERVER_SOFTWARE']) && 0 === strpos($_SERVER['SERVER_SOFTWARE'], 'Microsoft-IIS/') ) { $_SERVER['DOCUMENT_ROOT'] = rtrim(substr( $_SERVER['PATH_TRANSLATED'] ,0 ,strlen($_SERVER['PATH_TRANSLATED']) - strlen($_SERVER['SCRIPT_NAME']) ), '\\'); if ($unsetPathInfo) { unset($_SERVER['PATH_INFO']); } Minify_Logger::log("setDocRoot() set DOCUMENT_ROOT to \"{$_SERVER['DOCUMENT_ROOT']}\""); } } private static $_cache = null; protected static $_controller = null; protected static $_options = null; protected static function _setupDebug($sources) { foreach ($sources as $source) { $source->minifier = array('Minify_Lines', 'minify'); $id = $source->getId(); $source->minifyOptions = array( 'id' => (is_file($id) ? basename($id) : $id) ); } } protected static function _combineMinify() { $type = self::$_options['contentType']; $implodeSeparator = ($type === self::TYPE_JS) ? "\n;" : ''; $defaultOptions = isset(self::$_options['minifierOptions'][$type]) ? self::$_options['minifierOptions'][$type] : array(); $defaultMinifier = isset(self::$_options['minifiers'][$type]) ? self::$_options['minifiers'][$type] : false; if (Minify_Source::haveNoMinifyPrefs(self::$_controller->sources)) { foreach (self::$_controller->sources as $source) { $pieces[] = $source->getContent(); } $content = implode($implodeSeparator, $pieces); if ($defaultMinifier) { self::$_controller->loadMinifier($defaultMinifier); $content = call_user_func($defaultMinifier, $content, $defaultOptions); } } else { foreach (self::$_controller->sources as $source) { $minifier = (null !== $source->minifier) ? $source->minifier : $defaultMinifier; $options = (null !== $source->minifyOptions) ? array_merge($defaultOptions, $source->minifyOptions) : $defaultOptions; if ($minifier) { self::$_controller->loadMinifier($minifier); $pieces[] = call_user_func($minifier, $source->getContent(), $options); } else { $pieces[] = $source->getContent(); } } $content = implode($implodeSeparator, $pieces); } if ($type === self::TYPE_CSS && false !== strpos($content, '@import')) { $content = self::_handleCssImports($content); } if (self::$_options['postprocessorRequire']) { } if (self::$_options['postprocessor']) { $content = call_user_func(self::$_options['postprocessor'], $content, $type); } return $content; } protected static function _getCacheId() { return md5(serialize(array( Minify_Source::getDigest(self::$_controller->sources) ,self::$_options['minifiers'] ,self::$_options['minifierOptions'] ,self::$_options['postprocessor'] ,self::$_options['bubbleCssImports'] ))); } protected static function _handleCssImports($css) { if (self::$_options['bubbleCssImports']) { preg_match_all('/@import.*?;/', $css, $imports); $css = implode('', $imports[0]) . preg_replace('/@import.*?;/', '', $css); } else if ('' !== self::$importWarning) { $noCommentCss = preg_replace('@/\\*[\\s\\S]*?\\*/@', '', $css); $lastImportPos = strrpos($noCommentCss, '@import'); $firstBlockPos = strpos($noCommentCss, '{'); if (false !== $lastImportPos && false !== $firstBlockPos && $firstBlockPos < $lastImportPos ) { $css = self::$importWarning . $css; } } return $css; } }   if (false === (@include 'class.JavaScriptPacker.php')) { trigger_error( 'The script "class.JavaScriptPacker.php" is required. Please see: http:' .'//code.google.com/p/minify/source/browse/trunk/min/lib/Minify/Packer.php' ,E_USER_ERROR ); } class Minify_Packer { public static function minify($code, $options = array()) { $packer = new JavascriptPacker($code, 'Normal', true, false); return trim($packer->pack()); } }   class Minify_Source { public $lastModified = null; public $minifier = null; public $minifyOptions = null; public $filepath = null; public $contentType = null; public function __construct($spec) { if (isset($spec['filepath'])) { if (0 === strpos($spec['filepath'], '//')) { $spec['filepath'] = $_SERVER['DOCUMENT_ROOT'] . substr($spec['filepath'], 1); } $segments = explode('.', $spec['filepath']); $ext = strtolower(array_pop($segments)); switch ($ext) { case 'js' : $this->contentType = 'application/x-javascript'; break; case 'css' : $this->contentType = 'text/css'; break; case 'htm' : case 'html' : $this->contentType = 'text/html'; break; } $this->filepath = $spec['filepath']; $this->_id = $spec['filepath']; $this->lastModified = filemtime($spec['filepath']) + round(Minify::$uploaderHoursBehind * 3600); } elseif (isset($spec['id'])) { $this->_id = 'id::' . $spec['id']; if (isset($spec['content'])) { $this->_content = $spec['content']; } else { $this->_getContentFunc = $spec['getContentFunc']; } $this->lastModified = isset($spec['lastModified']) ? $spec['lastModified'] : time(); } if (isset($spec['contentType'])) { $this->contentType = $spec['contentType']; } if (isset($spec['minifier'])) { $this->minifier = $spec['minifier']; } if (isset($spec['minifyOptions'])) { $this->minifyOptions = $spec['minifyOptions']; } } public function getContent() { $content = (null !== $this->filepath) ? file_get_contents($this->filepath) : ((null !== $this->_content) ? $this->_content : call_user_func($this->_getContentFunc, $this->_id) ); return (pack("CCC",0xef,0xbb,0xbf) === substr($content, 0, 3)) ? substr($content, 3) : $content; } public function getId() { return $this->_id; } public static function haveNoMinifyPrefs($sources) { foreach ($sources as $source) { if (null !== $source->minifier || null !== $source->minifyOptions) { return false; } } return true; } public static function getDigest($sources) { foreach ($sources as $source) { $info[] = array( $source->_id, $source->minifier, $source->minifyOptions ); } return md5(serialize($info)); } public static function getContentType($sources) { foreach ($sources as $source) { if ($source->contentType !== null) { return $source->contentType; } } return 'text/plain'; } protected $_content = null; protected $_getContentFunc = null; protected $_id = null; }   class Minify_CSS_UriRewriter { protected static $className = 'Minify_CSS_UriRewriter'; public static $debugText = ''; public static function rewrite($css, $currentDir, $docRoot = null, $symlinks = array()) { self::$_docRoot = self::_realpath( $docRoot ? $docRoot : $_SERVER['DOCUMENT_ROOT'] ); self::$_currentDir = self::_realpath($currentDir); self::$_symlinks = array(); foreach ($symlinks as $link => $target) { $link = ($link === '//') ? self::$_docRoot : str_replace('//', self::$_docRoot . '/', $link); $link = strtr($link, '/', DIRECTORY_SEPARATOR); self::$_symlinks[$link] = self::_realpath($target); } self::$debugText .= "docRoot    : " . self::$_docRoot . "\n" . "currentDir : " . self::$_currentDir . "\n"; if (self::$_symlinks) { self::$debugText .= "symlinks : " . var_export(self::$_symlinks, 1) . "\n"; } self::$debugText .= "\n"; $css = self::_trimUrls($css); $css = preg_replace_callback('/@import\\s+([\'"])(.*?)[\'"]/' ,array(self::$className, '_processUriCB'), $css); $css = preg_replace_callback('/url\\(\\s*([^\\)\\s]+)\\s*\\)/' ,array(self::$className, '_processUriCB'), $css); return $css; } public static function prepend($css, $path) { self::$_prependPath = $path; $css = self::_trimUrls($css); $css = preg_replace_callback('/@import\\s+([\'"])(.*?)[\'"]/' ,array(self::$className, '_processUriCB'), $css); $css = preg_replace_callback('/url\\(\\s*([^\\)\\s]+)\\s*\\)/' ,array(self::$className, '_processUriCB'), $css); self::$_prependPath = null; return $css; } private static $_currentDir = ''; private static $_docRoot = ''; private static $_symlinks = array(); private static $_prependPath = null; private static function _trimUrls($css) { return preg_replace('/
            url\\(      # url(
            \\s*
            ([^\\)]+?)  # 1 = URI (assuming does not contain ")")
            \\s*
            \\)         # )
        /x', 'url($1)', $css); } private static function _processUriCB($m) { $isImport = ($m[0][0] === '@'); if ($isImport) { $quoteChar = $m[1]; $uri = $m[2]; } else { $quoteChar = ($m[1][0] === "'" || $m[1][0] === '"') ? $m[1][0] : ''; $uri = ($quoteChar === '') ? $m[1] : substr($m[1], 1, strlen($m[1]) - 2); } if ('/' !== $uri[0] && false === strpos($uri, '//') && 0 !== strpos($uri, 'data:') ) { $uri = (self::$_prependPath !== null) ? (self::$_prependPath . $uri) : self::rewriteRelative($uri, self::$_currentDir, self::$_docRoot, self::$_symlinks); } return $isImport ? "@import {$quoteChar}{$uri}{$quoteChar}" : "url({$quoteChar}{$uri}{$quoteChar})"; } public static function rewriteRelative($uri, $realCurrentDir, $realDocRoot, $symlinks = array()) { $path = strtr($realCurrentDir, '/', DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . strtr($uri, '/', DIRECTORY_SEPARATOR); self::$debugText .= "file-relative URI  : {$uri}\n" . "path prepended     : {$path}\n"; foreach ($symlinks as $link => $target) { if (0 === strpos($path, $target)) { $path = $link . substr($path, strlen($target)); self::$debugText .= "symlink unresolved : {$path}\n"; break; } } $path = substr($path, strlen($realDocRoot)); self::$debugText .= "docroot stripped   : {$path}\n"; $uri = strtr($path, '/\\', '//'); $uri = str_replace('/./', '/', $uri); do { $uri = preg_replace('@/[^/]+/\\.\\./@', '/', $uri, 1, $changed); } while ($changed); self::$debugText .= "traversals removed : {$uri}\n\n"; return $uri; } protected static function _realpath($path) { $realPath = realpath($path); if ($realPath !== false) { $path = $realPath; } return rtrim($path, '/\\'); } }   function Minify_groupUri($group, $forceAmpersand = false) { $path = $forceAmpersand ? "/g={$group}" : "/?g={$group}"; return _Minify_getBuild($group)->uri( '/' . basename(dirname(__FILE__)) . $path ,$forceAmpersand ); } function Minify_groupsMtime($groups) { $max = 0; foreach ((array)$groups as $group) { $max = max($max, _Minify_getBuild($group)->lastModified); } return $max; } function _Minify_getBuild($group) { static $builds = array(); static $gc = false; if (false === $gc) { $gc = (require dirname(__FILE__) . '/groupsConfig.php'); } if (! isset($builds[$group])) { $builds[$group] = new Minify_Build($gc[$group]); } return $builds[$group]; }   class Minify_YUICompressor { public static $jarFile = null; public static $tempDir = null; public static $javaExecutable = 'java'; public static function minifyJs($js, $options = array()) { return self::_minify('js', $js, $options); } public static function minifyCss($css, $options = array()) { return self::_minify('css', $css, $options); } private static function _minify($type, $content, $options) { self::_prepare(); if (! ($tmpFile = tempnam(self::$tempDir, 'yuic_'))) { throw new Exception('Minify_YUICompressor : could not create temp file.'); } file_put_contents($tmpFile, $content); exec(self::_getCmd($options, $type, $tmpFile), $output); unlink($tmpFile); return implode("\n", $output); } private static function _getCmd($userOptions, $type, $tmpFile) { $o = array_merge( array( 'charset' => '' ,'line-break' => 5000 ,'type' => $type ,'nomunge' => false ,'preserve-semi' => false ,'disable-optimizations' => false ) ,$userOptions ); $cmd = self::$javaExecutable . ' -jar ' . escapeshellarg(self::$jarFile) . " --type {$type}" . (preg_match('/^[a-zA-Z\\-]+$/', $o['charset']) ? " --charset {$o['charset']}" : '') . (is_numeric($o['line-break']) && $o['line-break'] >= 0 ? ' --line-break ' . (int)$o['line-break'] : ''); if ($type === 'js') { foreach (array('nomunge', 'preserve-semi', 'disable-optimizations') as $opt) { $cmd .= $o[$opt] ? " --{$opt}" : ''; } } return $cmd . ' ' . escapeshellarg($tmpFile); } private static function _prepare() { if (! is_file(self::$jarFile) || ! is_dir(self::$tempDir) || ! is_writable(self::$tempDir) ) { throw new Exception('Minify_YUICompressor : $jarFile and $tempDir must be set.'); } } }   class Minify_Controller_Files extends Minify_Controller_Base { public function setupSources($options) { $files = $options['files']; if (is_object($files)) { $files = array($files); } elseif (! is_array($files)) { $files = (array)$files; } unset($options['files']); $sources = array(); foreach ($files as $file) { if ($file instanceof Minify_Source) { $sources[] = $file; continue; } if (0 === strpos($file, '//')) { $file = $_SERVER['DOCUMENT_ROOT'] . substr($file, 1); } $realPath = realpath($file); if (is_file($realPath)) { $sources[] = new Minify_Source(array( 'filepath' => $realPath )); } else { $this->log("The path \"{$file}\" could not be found (or was not a file)"); return $options; } } if ($sources) { $this->sources = $sources; } return $options; } }   class Minify_Controller_Groups extends Minify_Controller_Base { public function setupSources($options) { $groups = $options['groups']; unset($options['groups']); $pi = isset($_SERVER['ORIG_PATH_INFO']) ? substr($_SERVER['ORIG_PATH_INFO'], 1) : (isset($_SERVER['PATH_INFO']) ? substr($_SERVER['PATH_INFO'], 1) : false ); if (false === $pi || ! isset($groups[$pi])) { $this->log("Missing PATH_INFO or no group set for \"$pi\""); return $options; } $sources = array(); $files = $groups[$pi]; if (is_object($files)) { $files = array($files); } elseif (! is_array($files)) { $files = (array)$files; } foreach ($files as $file) { if ($file instanceof Minify_Source) { $sources[] = $file; continue; } if (0 === strpos($file, '//')) { $file = $_SERVER['DOCUMENT_ROOT'] . substr($file, 1); } $realPath = realpath($file); if (is_file($realPath)) { $sources[] = new Minify_Source(array( 'filepath' => $realPath )); } else { $this->log("The path \"{$file}\" could not be found (or was not a file)"); return $options; } } if ($sources) { $this->sources = $sources; } return $options; } }   class Minify_Controller_MinApp extends Minify_Controller_Base { public function setupSources($options) { $cOptions = array_merge( array( 'allowDirs' => '//' ,'groupsOnly' => false ,'groups' => array() ,'maxFiles' => 10 ) ,(isset($options['minApp']) ? $options['minApp'] : array()) ); unset($options['minApp']); $sources = array(); if (isset($_GET['g'])) { if (! isset($cOptions['groups'][$_GET['g']])) { $this->log("A group configuration for \"{$_GET['g']}\" was not set"); return $options; } $files = $cOptions['groups'][$_GET['g']]; if (is_object($files)) { $files = array($files); } elseif (! is_array($files)) { $files = (array)$files; } foreach ($files as $file) { if ($file instanceof Minify_Source) { $sources[] = $file; continue; } if (0 === strpos($file, '//')) { $file = $_SERVER['DOCUMENT_ROOT'] . substr($file, 1); } $file = realpath($file); if (is_file($file)) { $sources[] = new Minify_Source(array( 'filepath' => $file )); } else { $this->log("The path \"{$file}\" could not be found (or was not a file)"); return $options; } } } elseif (! $cOptions['groupsOnly'] && isset($_GET['f'])) { if ( ! preg_match('/^[^,]+\\.(css|js)(?:,[^,]+\\.\\1)*$/', $_GET['f']) || strpos($_GET['f'], '//') !== false || strpos($_GET['f'], '\\') !== false || preg_match('/(?:^|[^\\.])\\.\\//', $_GET['f']) ) { $this->log("GET param 'f' invalid (see MinApp.php line 63)"); return $options; } $files = explode(',', $_GET['f']); if (count($files) > $cOptions['maxFiles'] || $files != array_unique($files)) { $this->log("Too many or duplicate files specified"); return $options; } if (isset($_GET['b'])) { if (preg_match('@^[^/]+(?:/[^/]+)*$@', $_GET['b']) && false === strpos($_GET['b'], '..') && $_GET['b'] !== '.') { $base = "/{$_GET['b']}/"; } else { $this->log("GET param 'b' invalid (see MinApp.php line 84)"); return $options; } } else { $base = '/'; } $allowDirs = array(); foreach ((array)$cOptions['allowDirs'] as $allowDir) { $allowDirs[] = realpath(str_replace('//', $_SERVER['DOCUMENT_ROOT'] . '/', $allowDir)); } foreach ($files as $file) { $path = $_SERVER['DOCUMENT_ROOT'] . $base . $file; $file = realpath($path); if (false === $file) { $this->log("Path \"{$path}\" failed realpath()"); return $options; } elseif (! parent::_fileIsSafe($file, $allowDirs)) { $this->log("Path \"{$path}\" failed Minify_Controller_Base::_fileIsSafe()"); return $options; } else { $sources[] = new Minify_Source(array( 'filepath' => $file )); } } } if ($sources) { $this->sources = $sources; } else { $this->log("No sources to serve"); } return $options; } }   class Minify_Controller_Page extends Minify_Controller_Base { public function setupSources($options) { if (isset($options['file'])) { $sourceSpec = array( 'filepath' => $options['file'] ); } else { $sourceSpec = array( 'content' => $options['content'] ,'id' => $options['id'] ); unset($options['content'], $options['id']); } if (isset($options['minifyAll'])) { $sourceSpec['minifyOptions'] = array( 'cssMinifier' => array('Minify_CSS', 'minify') ,'jsMinifier' => array('JSMin', 'minify') ); $this->_loadCssJsMinifiers = true; unset($options['minifyAll']); } $this->sources[] = new Minify_Source($sourceSpec); $options['contentType'] = Minify::TYPE_HTML; return $options; } protected $_loadCssJsMinifiers = false; public function loadMinifier($minifierCallback) { if ($this->_loadCssJsMinifiers) { } parent::loadMinifier($minifierCallback); } }   class Minify_Controller_Version1 extends Minify_Controller_Base { public function setupSources($options) { self::_setupDefines(); if (MINIFY_USE_CACHE) { $cacheDir = defined('MINIFY_CACHE_DIR') ? MINIFY_CACHE_DIR : ''; Minify::setCache($cacheDir); } $options['badRequestHeader'] = 'HTTP/1.0 404 Not Found'; $options['contentTypeCharset'] = MINIFY_ENCODING; if (! isset($_GET['files']) || ! preg_match('/^[^,]+\\.(css|js)(,[^,]+\\.\\1)*$/', $_GET['files'], $m) || strpos($_GET['files'], '//') !== false || strpos($_GET['files'], '\\') !== false || preg_match('/(?:^|[^\\.])\\.\\//', $_GET['files']) ) { return $options; } $extension = $m[1]; $files = explode(',', $_GET['files']); if (count($files) > MINIFY_MAX_FILES) { return $options; } $prependRelPaths = dirname($_SERVER['SCRIPT_FILENAME']) . DIRECTORY_SEPARATOR; $prependAbsPaths = $_SERVER['DOCUMENT_ROOT']; $sources = array(); $goodFiles = array(); $hasBadSource = false; $allowDirs = isset($options['allowDirs']) ? $options['allowDirs'] : MINIFY_BASE_DIR; foreach ($files as $file) { $file = ($file[0] === '/' ? $prependAbsPaths : $prependRelPaths) . $file; $file = realpath($file); if (parent::_fileIsSafe($file, $allowDirs) && !in_array($file, $goodFiles)) { $goodFiles[] = $file; $srcOptions = array( 'filepath' => $file ); $this->sources[] = new Minify_Source($srcOptions); } else { $hasBadSource = true; break; } } if ($hasBadSource) { $this->sources = array(); } if (! MINIFY_REWRITE_CSS_URLS) { $options['rewriteCssUris'] = false; } return $options; } private static function _setupDefines() { $defaults = array( 'MINIFY_BASE_DIR' => realpath($_SERVER['DOCUMENT_ROOT']) ,'MINIFY_ENCODING' => 'utf-8' ,'MINIFY_MAX_FILES' => 16 ,'MINIFY_REWRITE_CSS_URLS' => true ,'MINIFY_USE_CACHE' => true ); foreach ($defaults as $const => $val) { if (! defined($const)) { define($const, $val); } } } } ?>