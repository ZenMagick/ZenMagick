<?php  class SimpleArguments { private $all = array(); function __construct($arguments) { array_shift($arguments); while (count($arguments) > 0) { list($key, $value) = $this->parseArgument($arguments); $this->assign($key, $value); } } function assign($key, $value) { if ($this->$key === false) { $this->all[$key] = $value; } elseif (! is_array($this->$key)) { $this->all[$key] = array($this->$key, $value); } else { $this->all[$key][] = $value; } } private function parseArgument($arguments) { $argument = array_shift($arguments); if (preg_match('/^-(\w)=(.+)$/', $argument, $matches)) { return array($matches[1], $matches[2]); } elseif (preg_match('/^-(\w)$/', $argument, $matches)) { return array($matches[1], $this->nextNonFlagElseTrue($arguments)); } elseif (preg_match('/^--(\w+)=(.+)$/', $argument, $matches)) { return array($matches[1], $matches[2]); } elseif (preg_match('/^--(\w+)$/', $argument, $matches)) { return array($matches[1], $this->nextNonFlagElseTrue($arguments)); } } private function nextNonFlagElseTrue($arguments) { return $this->valueIsNext($arguments) ? array_shift($arguments) : true; } function valueIsNext($arguments) { return isset($arguments[0]) && ! $this->isFlag($arguments[0]); } function isFlag($argument) { return strncmp($argument, '-', 1) == 0; } function __get($key) { if (isset($this->all[$key])) { return $this->all[$key]; } return false; } function all() { return $this->all; } } class SimpleHelp { private $overview; private $flag_sets = array(); private $explanations = array(); function __construct($overview = '') { $this->overview = $overview; } function explainFlag($flags, $explanation) { $flags = is_array($flags) ? $flags : array($flags); $this->flag_sets[] = $flags; $this->explanations[] = $explanation; } function render() { $tab_stop = $this->longestFlag($this->flag_sets) + 4; $text = $this->overview . "\n"; for ($i = 0; $i < count($this->flag_sets); $i++) { $text .= $this->renderFlagSet($this->flag_sets[$i], $this->explanations[$i], $tab_stop); } return $this->noDuplicateNewLines($text); } private function longestFlag($flag_sets) { $longest = 0; foreach ($flag_sets as $flags) { foreach ($flags as $flag) { $longest = max($longest, strlen($this->renderFlag($flag))); } } return $longest; } private function renderFlagSet($flags, $explanation, $tab_stop) { $flag = array_shift($flags); $text = str_pad($this->renderFlag($flag), $tab_stop, ' ') . $explanation . "\n"; foreach ($flags as $flag) { $text .= '  ' . $this->renderFlag($flag) . "\n"; } return $text; } private function renderFlag($flag) { return (strlen($flag) == 1 ? '-' : '--') . $flag; } private function noDuplicateNewLines($text) { return preg_replace('/(\n+)/', "\n", $text); } }   class SimpleRealm { private $type; private $root; private $username; private $password; function SimpleRealm($type, $url) { $this->type = $type; $this->root = $url->getBasePath(); $this->username = false; $this->password = false; } function stretch($url) { $this->root = $this->getCommonPath($this->root, $url->getPath()); } protected function getCommonPath($first, $second) { $first = explode('/', $first); $second = explode('/', $second); for ($i = 0; $i < min(count($first), count($second)); $i++) { if ($first[$i] != $second[$i]) { return implode('/', array_slice($first, 0, $i)) . '/'; } } return implode('/', $first) . '/'; } function setIdentity($username, $password) { $this->username = $username; $this->password = $password; } function getUsername() { return $this->username; } function getPassword() { return $this->password; } function isWithin($url) { if ($this->isIn($this->root, $url->getBasePath())) { return true; } if ($this->isIn($this->root, $url->getBasePath() . $url->getPage() . '/')) { return true; } return false; } protected function isIn($part, $whole) { return strpos($whole, $part) === 0; } } class SimpleAuthenticator { private $realms; function SimpleAuthenticator() { $this->restartSession(); } function restartSession() { $this->realms = array(); } function addRealm($url, $type, $realm) { $this->realms[$url->getHost()][$realm] = new SimpleRealm($type, $url); } function setIdentityForRealm($host, $realm, $username, $password) { if (isset($this->realms[$host][$realm])) { $this->realms[$host][$realm]->setIdentity($username, $password); } } protected function findRealmFromUrl($url) { if (! isset($this->realms[$url->getHost()])) { return false; } foreach ($this->realms[$url->getHost()] as $name => $realm) { if ($realm->isWithin($url)) { return $realm; } } return false; } function addHeaders($request, $url) { if ($url->getUsername() && $url->getPassword()) { $username = $url->getUsername(); $password = $url->getPassword(); } elseif ($realm = $this->findRealmFromUrl($url)) { $username = $realm->getUsername(); $password = $realm->getPassword(); } else { return; } $this->addBasicHeaders($request, $username, $password); } static function addBasicHeaders($request, $username, $password) { if ($username && $password) { $request->addHeaderLine( 'Authorization: Basic ' . base64_encode("$username:$password")); } } }   if (! SimpleTest::getParsers()) { SimpleTest::setParsers(array(new SimpleTidyPageBuilder(), new SimplePHPPageBuilder())); } if (! defined('DEFAULT_MAX_NESTED_FRAMES')) { define('DEFAULT_MAX_NESTED_FRAMES', 3); } class SimpleBrowserHistory { private $sequence = array(); private $position = -1; protected function isEmpty() { return ($this->position == -1); } protected function atBeginning() { return ($this->position == 0) && ! $this->isEmpty(); } protected function atEnd() { return ($this->position + 1 >= count($this->sequence)) && ! $this->isEmpty(); } function recordEntry($url, $parameters) { $this->dropFuture(); array_push( $this->sequence, array('url' => $url, 'parameters' => $parameters)); $this->position++; } function getUrl() { if ($this->isEmpty()) { return false; } return $this->sequence[$this->position]['url']; } function getParameters() { if ($this->isEmpty()) { return false; } return $this->sequence[$this->position]['parameters']; } function back() { if ($this->isEmpty() || $this->atBeginning()) { return false; } $this->position--; return true; } function forward() { if ($this->isEmpty() || $this->atEnd()) { return false; } $this->position++; return true; } protected function dropFuture() { if ($this->isEmpty()) { return; } while (! $this->atEnd()) { array_pop($this->sequence); } } } class SimpleBrowser { private $user_agent; private $page; private $history; private $ignore_frames; private $maximum_nested_frames; private $parser; function __construct() { $this->user_agent = $this->createUserAgent(); $this->user_agent->useProxy( SimpleTest::getDefaultProxy(), SimpleTest::getDefaultProxyUsername(), SimpleTest::getDefaultProxyPassword()); $this->page = new SimplePage(); $this->history = $this->createHistory(); $this->ignore_frames = false; $this->maximum_nested_frames = DEFAULT_MAX_NESTED_FRAMES; } protected function createUserAgent() { return new SimpleUserAgent(); } protected function createHistory() { return new SimpleBrowserHistory(); } protected function getParser() { if ($this->parser) { return $this->parser; } foreach (SimpleTest::getParsers() as $parser) { if ($parser->can()) { return $parser; } } } public function setParser($parser) { $this->parser = $parser; } function ignoreFrames() { $this->ignore_frames = true; } function useFrames() { $this->ignore_frames = false; } function ignoreCookies() { $this->user_agent->ignoreCookies(); } function useCookies() { $this->user_agent->useCookies(); } protected function parse($response, $depth = 0) { $page = $this->buildPage($response); if ($this->ignore_frames || ! $page->hasFrames() || ($depth > $this->maximum_nested_frames)) { return $page; } $frameset = new SimpleFrameset($page); foreach ($page->getFrameset() as $key => $url) { $frame = $this->fetch($url, new SimpleGetEncoding(), $depth + 1); $frameset->addFrame($frame, $key); } return $frameset; } protected function buildPage($response) { return $this->getParser()->parse($response); } protected function fetch($url, $encoding, $depth = 0) { $response = $this->user_agent->fetchResponse($url, $encoding); if ($response->isError()) { return new SimplePage($response); } return $this->parse($response, $depth); } protected function load($url, $parameters) { $frame = $url->getTarget(); if (! $frame || ! $this->page->hasFrames() || (strtolower($frame) == '_top')) { return $this->loadPage($url, $parameters); } return $this->loadFrame(array($frame), $url, $parameters); } protected function loadPage($url, $parameters) { $this->page = $this->fetch($url, $parameters); $this->history->recordEntry( $this->page->getUrl(), $this->page->getRequestData()); return $this->page->getRaw(); } protected function loadFrame($frames, $url, $parameters) { $page = $this->fetch($url, $parameters); $this->page->setFrame($frames, $page); return $page->getRaw(); } function restart($date = false) { $this->user_agent->restart($date); } function addHeader($header) { $this->user_agent->addHeader($header); } function ageCookies($interval) { $this->user_agent->ageCookies($interval); } function setCookie($name, $value, $host = false, $path = '/', $expiry = false) { $this->user_agent->setCookie($name, $value, $host, $path, $expiry); } function getCookieValue($host, $path, $name) { return $this->user_agent->getCookieValue($host, $path, $name); } function getCurrentCookieValue($name) { return $this->user_agent->getBaseCookieValue($name, $this->page->getUrl()); } function setMaximumRedirects($max) { $this->user_agent->setMaximumRedirects($max); } function setMaximumNestedFrames($max) { $this->maximum_nested_frames = $max; } function setConnectionTimeout($timeout) { $this->user_agent->setConnectionTimeout($timeout); } function useProxy($proxy, $username = false, $password = false) { $this->user_agent->useProxy($proxy, $username, $password); } function head($url, $parameters = false) { if (! is_object($url)) { $url = new SimpleUrl($url); } if ($this->getUrl()) { $url = $url->makeAbsolute($this->getUrl()); } $response = $this->user_agent->fetchResponse($url, new SimpleHeadEncoding($parameters)); $this->page = new SimplePage($response); return ! $response->isError(); } function get($url, $parameters = false) { if (! is_object($url)) { $url = new SimpleUrl($url); } if ($this->getUrl()) { $url = $url->makeAbsolute($this->getUrl()); } return $this->load($url, new SimpleGetEncoding($parameters)); } function post($url, $parameters = false, $content_type = false) { if (! is_object($url)) { $url = new SimpleUrl($url); } if ($this->getUrl()) { $url = $url->makeAbsolute($this->getUrl()); } return $this->load($url, new SimplePostEncoding($parameters, $content_type)); } function put($url, $parameters = false, $content_type = false) { if (! is_object($url)) { $url = new SimpleUrl($url); } return $this->load($url, new SimplePutEncoding($parameters, $content_type)); } function delete($url, $parameters = false) { if (! is_object($url)) { $url = new SimpleUrl($url); } return $this->load($url, new SimpleDeleteEncoding($parameters)); } function retry() { $frames = $this->page->getFrameFocus(); if (count($frames) > 0) { $this->loadFrame( $frames, $this->page->getUrl(), $this->page->getRequestData()); return $this->page->getRaw(); } if ($url = $this->history->getUrl()) { $this->page = $this->fetch($url, $this->history->getParameters()); return $this->page->getRaw(); } return false; } function back() { if (! $this->history->back()) { return false; } $content = $this->retry(); if (! $content) { $this->history->forward(); } return $content; } function forward() { if (! $this->history->forward()) { return false; } $content = $this->retry(); if (! $content) { $this->history->back(); } return $content; } function authenticate($username, $password) { if (! $this->page->getRealm()) { return false; } $url = $this->page->getUrl(); if (! $url) { return false; } $this->user_agent->setIdentity( $url->getHost(), $this->page->getRealm(), $username, $password); return $this->retry(); } function getFrames() { return $this->page->getFrames(); } function getFrameFocus() { return $this->page->getFrameFocus(); } function setFrameFocusByIndex($choice) { return $this->page->setFrameFocusByIndex($choice); } function setFrameFocus($name) { return $this->page->setFrameFocus($name); } function clearFrameFocus() { return $this->page->clearFrameFocus(); } function getTransportError() { return $this->page->getTransportError(); } function getMimeType() { return $this->page->getMimeType(); } function getResponseCode() { return $this->page->getResponseCode(); } function getAuthentication() { return $this->page->getAuthentication(); } function getRealm() { return $this->page->getRealm(); } function getUrl() { $url = $this->page->getUrl(); return $url ? $url->asString() : false; } function getBaseUrl() { $url = $this->page->getBaseUrl(); return $url ? $url->asString() : false; } function getRequest() { return $this->page->getRequest(); } function getHeaders() { return $this->page->getHeaders(); } function getContent() { return $this->page->getRaw(); } function getContentAsText() { return $this->page->getText(); } function getTitle() { return $this->page->getTitle(); } function getUrls() { return $this->page->getUrls(); } function setField($label, $value, $position=false) { return $this->page->setField(new SimpleByLabelOrName($label), $value, $position); } function setFieldByName($name, $value, $position=false) { return $this->page->setField(new SimpleByName($name), $value, $position); } function setFieldById($id, $value) { return $this->page->setField(new SimpleById($id), $value); } function getField($label) { return $this->page->getField(new SimpleByLabelOrName($label)); } function getFieldByName($name) { return $this->page->getField(new SimpleByName($name)); } function getFieldById($id) { return $this->page->getField(new SimpleById($id)); } function clickSubmit($label = 'Submit', $additional = false) { if (! ($form = $this->page->getFormBySubmit(new SimpleByLabel($label)))) { return false; } $success = $this->load( $form->getAction(), $form->submitButton(new SimpleByLabel($label), $additional)); return ($success ? $this->getContent() : $success); } function clickSubmitByName($name, $additional = false) { if (! ($form = $this->page->getFormBySubmit(new SimpleByName($name)))) { return false; } $success = $this->load( $form->getAction(), $form->submitButton(new SimpleByName($name), $additional)); return ($success ? $this->getContent() : $success); } function clickSubmitById($id, $additional = false) { if (! ($form = $this->page->getFormBySubmit(new SimpleById($id)))) { return false; } $success = $this->load( $form->getAction(), $form->submitButton(new SimpleById($id), $additional)); return ($success ? $this->getContent() : $success); } function isSubmit($label) { return (boolean)$this->page->getFormBySubmit(new SimpleByLabel($label)); } function clickImage($label, $x = 1, $y = 1, $additional = false) { if (! ($form = $this->page->getFormByImage(new SimpleByLabel($label)))) { return false; } $success = $this->load( $form->getAction(), $form->submitImage(new SimpleByLabel($label), $x, $y, $additional)); return ($success ? $this->getContent() : $success); } function clickImageByName($name, $x = 1, $y = 1, $additional = false) { if (! ($form = $this->page->getFormByImage(new SimpleByName($name)))) { return false; } $success = $this->load( $form->getAction(), $form->submitImage(new SimpleByName($name), $x, $y, $additional)); return ($success ? $this->getContent() : $success); } function clickImageById($id, $x = 1, $y = 1, $additional = false) { if (! ($form = $this->page->getFormByImage(new SimpleById($id)))) { return false; } $success = $this->load( $form->getAction(), $form->submitImage(new SimpleById($id), $x, $y, $additional)); return ($success ? $this->getContent() : $success); } function isImage($label) { return (boolean)$this->page->getFormByImage(new SimpleByLabel($label)); } function submitFormById($id) { if (! ($form = $this->page->getFormById($id))) { return false; } $success = $this->load( $form->getAction(), $form->submit()); return ($success ? $this->getContent() : $success); } function getLink($label, $index = 0) { $urls = $this->page->getUrlsByLabel($label); if (count($urls) == 0) { return false; } if (count($urls) < $index + 1) { return false; } return $urls[$index]; } function clickLink($label, $index = 0) { $url = $this->getLink($label, $index); if ($url === false) { return false; } $this->load($url, new SimpleGetEncoding()); return $this->getContent(); } function getLinkById($id) { return $this->page->getUrlById($id); } function clickLinkById($id) { if (! ($url = $this->getLinkById($id))) { return false; } $this->load($url, new SimpleGetEncoding()); return $this->getContent(); } function click($label) { $raw = $this->clickSubmit($label); if (! $raw) { $raw = $this->clickLink($label); } if (! $raw) { $raw = $this->clickImage($label); } return $raw; } function isClickable($label) { return $this->isSubmit($label) || ($this->getLink($label) !== false) || $this->isImage($label); } }   class SimpleCollector { protected function removeTrailingSlash($path) { if (substr($path, -1) == DIRECTORY_SEPARATOR) { return substr($path, 0, -1); } elseif (substr($path, -1) == '/') { return substr($path, 0, -1); } else { return $path; } } function collect($test, $path) { $path = $this->removeTrailingSlash($path); if ($handle = opendir($path)) { while (($entry = readdir($handle)) !== false) { if ($this->isHidden($entry)) { continue; } $this->handle($test, $path . DIRECTORY_SEPARATOR . $entry); } closedir($handle); } } protected function handle($test, $file) { if (is_dir($file)) { return; } $test->addFile($file); } protected function isHidden($filename) { return strncmp($filename, '.', 1) == 0; } } class SimplePatternCollector extends SimpleCollector { private $pattern; function __construct($pattern = '/php$/i') { $this->pattern = $pattern; } protected function handle($test, $filename) { if (preg_match($this->pattern, $filename)) { parent::handle($test, $filename); } } }   class SimpleTestCompatibility { static function copy($object) { if (version_compare(phpversion(), '5') >= 0) { eval('$copy = clone $object;'); return $copy; } return $object; } static function isIdentical($first, $second) { if (version_compare(phpversion(), '5') >= 0) { return SimpleTestCompatibility::isIdenticalType($first, $second); } if ($first != $second) { return false; } return ($first === $second); } protected static function isIdenticalType($first, $second) { if (gettype($first) != gettype($second)) { return false; } if (is_object($first) && is_object($second)) { if (get_class($first) != get_class($second)) { return false; } return SimpleTestCompatibility::isArrayOfIdenticalTypes( (array) $first, (array) $second); } if (is_array($first) && is_array($second)) { return SimpleTestCompatibility::isArrayOfIdenticalTypes($first, $second); } if ($first !== $second) { return false; } return true; } protected static function isArrayOfIdenticalTypes($first, $second) { if (array_keys($first) != array_keys($second)) { return false; } foreach (array_keys($first) as $key) { $is_identical = SimpleTestCompatibility::isIdenticalType( $first[$key], $second[$key]); if (! $is_identical) { return false; } } return true; } static function isReference($first, $second) { if (version_compare(phpversion(), '5', '>=') && is_object($first)) { return ($first === $second); } if (is_object($first) && is_object($second)) { $id = uniqid("test"); $first->$id = true; $is_ref = isset($second->$id); unset($first->$id); return $is_ref; } $temp = $first; $first = uniqid("test"); $is_ref = ($first === $second); $first = $temp; return $is_ref; } static function isA($object, $class) { if (version_compare(phpversion(), '5') >= 0) { if (! class_exists($class, false)) { if (function_exists('interface_exists')) { if (! interface_exists($class, false)) { return false; } } } eval("\$is_a = \$object instanceof $class;"); return $is_a; } if (function_exists('is_a')) { return is_a($object, $class); } return ((strtolower($class) == get_class($object)) or (is_subclass_of($object, $class))); } static function setTimeout($handle, $timeout) { if (function_exists('stream_set_timeout')) { stream_set_timeout($handle, $timeout, 0); } elseif (function_exists('socket_set_timeout')) { socket_set_timeout($handle, $timeout, 0); } elseif (function_exists('set_socket_timeout')) { set_socket_timeout($handle, $timeout, 0); } } }   class SimpleCookie { private $host; private $name; private $value; private $path; private $expiry; private $is_secure; function __construct($name, $value = false, $path = false, $expiry = false, $is_secure = false) { $this->host = false; $this->name = $name; $this->value = $value; $this->path = ($path ? $this->fixPath($path) : "/"); $this->expiry = false; if (is_string($expiry)) { $this->expiry = strtotime($expiry); } elseif (is_integer($expiry)) { $this->expiry = $expiry; } $this->is_secure = $is_secure; } function setHost($host) { if ($host = $this->truncateHost($host)) { $this->host = $host; return true; } return false; } function getHost() { return $this->host; } function isValidHost($host) { return ($this->truncateHost($host) === $this->getHost()); } protected function truncateHost($host) { $tlds = SimpleUrl::getAllTopLevelDomains(); if (preg_match('/[a-z\-]+\.(' . $tlds . ')$/i', $host, $matches)) { return $matches[0]; } elseif (preg_match('/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i', $host, $matches)) { return $matches[0]; } return false; } function getName() { return $this->name; } function getValue() { return $this->value; } function getPath() { return $this->path; } function isValidPath($path) { return (strncmp( $this->fixPath($path), $this->getPath(), strlen($this->getPath())) == 0); } function getExpiry() { if (! $this->expiry) { return false; } return gmdate("D, d M Y H:i:s", $this->expiry) . " GMT"; } function isExpired($now) { if (! $this->expiry) { return true; } if (is_string($now)) { $now = strtotime($now); } return ($this->expiry < $now); } function agePrematurely($interval) { if ($this->expiry) { $this->expiry -= $interval; } } function isSecure() { return $this->is_secure; } protected function fixPath($path) { if (substr($path, 0, 1) != '/') { $path = '/' . $path; } if (substr($path, -1, 1) != '/') { $path .= '/'; } return $path; } } class SimpleCookieJar { private $cookies; function __construct() { $this->cookies = array(); } function restartSession($date = false) { $surviving_cookies = array(); for ($i = 0; $i < count($this->cookies); $i++) { if (! $this->cookies[$i]->getValue()) { continue; } if (! $this->cookies[$i]->getExpiry()) { continue; } if ($date && $this->cookies[$i]->isExpired($date)) { continue; } $surviving_cookies[] = $this->cookies[$i]; } $this->cookies = $surviving_cookies; } function agePrematurely($interval) { for ($i = 0; $i < count($this->cookies); $i++) { $this->cookies[$i]->agePrematurely($interval); } } function setCookie($name, $value, $host = false, $path = '/', $expiry = false) { $cookie = new SimpleCookie($name, $value, $path, $expiry); if ($host) { $cookie->setHost($host); } $this->cookies[$this->findFirstMatch($cookie)] = $cookie; } protected function findFirstMatch($cookie) { for ($i = 0; $i < count($this->cookies); $i++) { $is_match = $this->isMatch( $cookie, $this->cookies[$i]->getHost(), $this->cookies[$i]->getPath(), $this->cookies[$i]->getName()); if ($is_match) { return $i; } } return count($this->cookies); } function getCookieValue($host, $path, $name) { $longest_path = ''; foreach ($this->cookies as $cookie) { if ($this->isMatch($cookie, $host, $path, $name)) { if (strlen($cookie->getPath()) > strlen($longest_path)) { $value = $cookie->getValue(); $longest_path = $cookie->getPath(); } } } return (isset($value) ? $value : false); } protected function isMatch($cookie, $host, $path, $name) { if ($cookie->getName() != $name) { return false; } if ($host && $cookie->getHost() && ! $cookie->isValidHost($host)) { return false; } if (! $cookie->isValidPath($path)) { return false; } return true; } function selectAsPairs($url) { $pairs = array(); foreach ($this->cookies as $cookie) { if ($this->isMatch($cookie, $url->getHost(), $url->getPath(), $cookie->getName())) { $pairs[] = $cookie->getName() . '=' . $cookie->getValue(); } } return $pairs; } }   class DetachedTestCase { private $command; private $dry_command; private $size; function __construct($command, $dry_command = false) { $this->command = $command; $this->dry_command = $dry_command ? $dry_command : $command; $this->size = false; } function getLabel() { return $this->command; } function run($reporter) { $shell = new SimpleShell(); $shell->execute($this->command); $parser = $this->createParser($reporter); if (! $parser->parse($shell->getOutput())) { trigger_error('Cannot parse incoming XML from [' . $this->command . ']'); return false; } return true; } function getSize() { if ($this->size === false) { $shell = new SimpleShell(); $shell->execute($this->dry_command); $reporter = new SimpleReporter(); $parser = $this->createParser($reporter); if (! $parser->parse($shell->getOutput())) { trigger_error('Cannot parse incoming XML from [' . $this->dry_command . ']'); return false; } $this->size = $reporter->getTestCaseCount(); } return $this->size; } protected function createParser($reporter) { return new SimpleTestXmlParser($reporter); } }   if (! defined('TYPE_MATTERS')) { define('TYPE_MATTERS', true); } class SimpleDumper { function describeValue($value) { $type = $this->getType($value); switch($type) { case "Null": return "NULL"; case "Boolean": return "Boolean: " . ($value ? "true" : "false"); case "Array": return "Array: " . count($value) . " items"; case "Object": return "Object: of " . get_class($value); case "String": return "String: " . $this->clipString($value, 200); default: return "$type: $value"; } return "Unknown"; } function getType($value) { if (! isset($value)) { return "Null"; } elseif (is_bool($value)) { return "Boolean"; } elseif (is_string($value)) { return "String"; } elseif (is_integer($value)) { return "Integer"; } elseif (is_float($value)) { return "Float"; } elseif (is_array($value)) { return "Array"; } elseif (is_resource($value)) { return "Resource"; } elseif (is_object($value)) { return "Object"; } return "Unknown"; } function describeDifference($first, $second, $identical = false) { if ($identical) { if (! $this->isTypeMatch($first, $second)) { return "with type mismatch as [" . $this->describeValue($first) . "] does not match [" . $this->describeValue($second) . "]"; } } $type = $this->getType($first); if ($type == "Unknown") { return "with unknown type"; } $method = 'describe' . $type . 'Difference'; return $this->$method($first, $second, $identical); } protected function isTypeMatch($first, $second) { return ($this->getType($first) == $this->getType($second)); } function clipString($value, $size, $position = 0) { $length = strlen($value); if ($length <= $size) { return $value; } $position = min($position, $length); $start = ($size/2 > $position ? 0 : $position - $size/2); if ($start + $size > $length) { $start = $length - $size; } $value = substr($value, $start, $size); return ($start > 0 ? "..." : "") . $value . ($start + $size < $length ? "..." : ""); } protected function describeGenericDifference($first, $second) { return "as [" . $this->describeValue($first) . "] does not match [" . $this->describeValue($second) . "]"; } protected function describeNullDifference($first, $second, $identical) { return $this->describeGenericDifference($first, $second); } protected function describeBooleanDifference($first, $second, $identical) { return $this->describeGenericDifference($first, $second); } protected function describeStringDifference($first, $second, $identical) { if (is_object($second) || is_array($second)) { return $this->describeGenericDifference($first, $second); } $position = $this->stringDiffersAt($first, $second); $message = "at character $position"; $message .= " with [" . $this->clipString($first, 200, $position) . "] and [" . $this->clipString($second, 200, $position) . "]"; return $message; } protected function describeIntegerDifference($first, $second, $identical) { if (is_object($second) || is_array($second)) { return $this->describeGenericDifference($first, $second); } return "because [" . $this->describeValue($first) . "] differs from [" . $this->describeValue($second) . "] by " . abs($first - $second); } protected function describeFloatDifference($first, $second, $identical) { if (is_object($second) || is_array($second)) { return $this->describeGenericDifference($first, $second); } return "because [" . $this->describeValue($first) . "] differs from [" . $this->describeValue($second) . "] by " . abs($first - $second); } protected function describeArrayDifference($first, $second, $identical) { if (! is_array($second)) { return $this->describeGenericDifference($first, $second); } if (! $this->isMatchingKeys($first, $second, $identical)) { return "as key list [" . implode(", ", array_keys($first)) . "] does not match key list [" . implode(", ", array_keys($second)) . "]"; } foreach (array_keys($first) as $key) { if ($identical && ($first[$key] === $second[$key])) { continue; } if (! $identical && ($first[$key] == $second[$key])) { continue; } return "with member [$key] " . $this->describeDifference( $first[$key], $second[$key], $identical); } return ""; } protected function isMatchingKeys($first, $second, $identical) { $first_keys = array_keys($first); $second_keys = array_keys($second); if ($identical) { return ($first_keys === $second_keys); } sort($first_keys); sort($second_keys); return ($first_keys == $second_keys); } protected function describeResourceDifference($first, $second, $identical) { return $this->describeGenericDifference($first, $second); } protected function describeObjectDifference($first, $second, $identical) { if (! is_object($second)) { return $this->describeGenericDifference($first, $second); } return $this->describeArrayDifference( $this->getMembers($first), $this->getMembers($second), $identical); } protected function getMembers($object) { $reflection = new ReflectionObject($object); $members = array(); foreach ($reflection->getProperties() as $property) { if (method_exists($property, 'setAccessible')) { $property->setAccessible(true); } try { $members[$property->getName()] = $property->getValue($object); } catch (ReflectionException $e) { $members[$property->getName()] = $this->getPrivatePropertyNoMatterWhat($property->getName(), $object); } } return $members; } private function getPrivatePropertyNoMatterWhat($name, $object) { foreach ((array)$object as $mangled_name => $value) { if ($this->unmangle($mangled_name) == $name) { return $value; } } } function unmangle($mangled) { $parts = preg_split('/[^a-zA-Z0-9_\x7f-\xff]+/', $mangled); return array_pop($parts); } protected function stringDiffersAt($first, $second) { if (! $first || ! $second) { return 0; } if (strlen($first) < strlen($second)) { list($first, $second) = array($second, $first); } $position = 0; $step = strlen($first); while ($step > 1) { $step = (integer)(($step + 1) / 2); if (strncmp($first, $second, $position + $step) == 0) { $position += $step; } } return $position; } function dump($variable) { ob_start(); print_r($variable); $formatted = ob_get_contents(); ob_end_clean(); return $formatted; } }   class SimpleEncodedPair { private $key; private $value; function __construct($key, $value) { $this->key = $key; $this->value = $value; } function asRequest() { return urlencode($this->key) . '=' . urlencode($this->value); } function asMime() { $part = 'Content-Disposition: form-data; '; $part .= "name=\"" . $this->key . "\"\r\n"; $part .= "\r\n" . $this->value; return $part; } function isKey($key) { return $key == $this->key; } function getKey() { return $this->key; } function getValue() { return $this->value; } } class SimpleAttachment { private $key; private $content; private $filename; function __construct($key, $content, $filename) { $this->key = $key; $this->content = $content; $this->filename = $filename; } function asRequest() { return ''; } function asMime() { $part = 'Content-Disposition: form-data; '; $part .= 'name="' . $this->key . '"; '; $part .= 'filename="' . $this->filename . '"'; $part .= "\r\nContent-Type: " . $this->deduceMimeType(); $part .= "\r\n\r\n" . $this->content; return $part; } protected function deduceMimeType() { if ($this->isOnlyAscii($this->content)) { return 'text/plain'; } return 'application/octet-stream'; } protected function isOnlyAscii($ascii) { for ($i = 0, $length = strlen($ascii); $i < $length; $i++) { if (ord($ascii[$i]) > 127) { return false; } } return true; } function isKey($key) { return $key == $this->key; } function getKey() { return $this->key; } function getValue() { return $this->filename; } } class SimpleEncoding { private $request; function __construct($query = false) { if (! $query) { $query = array(); } $this->clear(); $this->merge($query); } function clear() { $this->request = array(); } function add($key, $value) { if ($value === false) { return; } if (is_array($value)) { foreach ($value as $item) { $this->addPair($key, $item); } } else { $this->addPair($key, $value); } } protected function addPair($key, $value) { $this->request[] = new SimpleEncodedPair($key, $value); } function attach($key, $content, $filename) { $this->request[] = new SimpleAttachment($key, $content, $filename); } function merge($query) { if (is_object($query)) { $this->request = array_merge($this->request, $query->getAll()); } elseif (is_array($query)) { foreach ($query as $key => $value) { $this->add($key, $value); } } } function getValue($key) { $values = array(); foreach ($this->request as $pair) { if ($pair->isKey($key)) { $values[] = $pair->getValue(); } } if (count($values) == 0) { return false; } elseif (count($values) == 1) { return $values[0]; } else { return $values; } } function getAll() { return $this->request; } protected function encode() { $statements = array(); foreach ($this->request as $pair) { if ($statement = $pair->asRequest()) { $statements[] = $statement; } } return implode('&', $statements); } } class SimpleGetEncoding extends SimpleEncoding { function __construct($query = false) { parent::__construct($query); } function getMethod() { return 'GET'; } function writeHeadersTo($socket) { } function writeTo($socket) { } function asUrlRequest() { return $this->encode(); } } class SimpleHeadEncoding extends SimpleGetEncoding { function __construct($query = false) { parent::__construct($query); } function getMethod() { return 'HEAD'; } } class SimpleDeleteEncoding extends SimpleGetEncoding { function __construct($query = false) { parent::__construct($query); } function getMethod() { return 'DELETE'; } } class SimpleEntityEncoding extends SimpleEncoding { private $content_type; private $body; function __construct($query = false, $content_type = false) { $this->content_type = $content_type; if (is_string($query)) { $this->body = $query; parent::__construct(); } else { parent::__construct($query); } } function getContentType() { if (!$this->content_type) { return ($this->body) ? 'text/plain' : 'application/x-www-form-urlencoded'; } return $this->content_type; } function writeHeadersTo($socket) { $socket->write("Content-Length: " . (integer)strlen($this->encode()) . "\r\n"); $socket->write("Content-Type: " . $this->getContentType() . "\r\n"); } function writeTo($socket) { $socket->write($this->encode()); } protected function encode() { return ($this->body) ? $this->body : parent::encode(); } } class SimplePostEncoding extends SimpleEntityEncoding { function __construct($query = false, $content_type = false) { if (is_array($query) and $this->hasMoreThanOneLevel($query)) { $query = $this->rewriteArrayWithMultipleLevels($query); } parent::__construct($query, $content_type); } function hasMoreThanOneLevel($query) { foreach ($query as $key => $value) { if (is_array($value)) { return true; } } return false; } function rewriteArrayWithMultipleLevels($query) { $query_ = array(); foreach ($query as $key => $value) { if (is_array($value)) { foreach ($value as $sub_key => $sub_value) { $query_[$key."[".$sub_key."]"] = $sub_value; } } else { $query_[$key] = $value; } } if ($this->hasMoreThanOneLevel($query_)) { $query_ = $this->rewriteArrayWithMultipleLevels($query_); } return $query_; } function getMethod() { return 'POST'; } function asUrlRequest() { return ''; } } class SimplePutEncoding extends SimpleEntityEncoding { function __construct($query = false, $content_type = false) { parent::__construct($query, $content_type); } function getMethod() { return 'PUT'; } } class SimpleMultipartEncoding extends SimplePostEncoding { private $boundary; function __construct($query = false, $boundary = false) { parent::__construct($query); $this->boundary = ($boundary === false ? uniqid('st') : $boundary); } function writeHeadersTo($socket) { $socket->write("Content-Length: " . (integer)strlen($this->encode()) . "\r\n"); $socket->write("Content-Type: multipart/form-data; boundary=" . $this->boundary . "\r\n"); } function writeTo($socket) { $socket->write($this->encode()); } function encode() { $stream = ''; foreach ($this->getAll() as $pair) { $stream .= "--" . $this->boundary . "\r\n"; $stream .= $pair->asMime() . "\r\n"; } $stream .= "--" . $this->boundary . "--\r\n"; return $stream; } }   class SimpleExpectation { protected $dumper = false; private $message; function __construct($message = '%s') { $this->message = $message; } function test($compare) { } function testMessage($compare) { } function overlayMessage($compare, $dumper) { $this->dumper = $dumper; return sprintf($this->message, $this->testMessage($compare)); } protected function getDumper() { if (! $this->dumper) { $dumper = new SimpleDumper(); return $dumper; } return $this->dumper; } static function isExpectation($expectation) { return is_object($expectation) && SimpleTestCompatibility::isA($expectation, 'SimpleExpectation'); } } class AnythingExpectation extends SimpleExpectation { function test($compare) { return true; } function testMessage($compare) { $dumper = $this->getDumper(); return 'Anything always matches [' . $dumper->describeValue($compare) . ']'; } } class FailedExpectation extends SimpleExpectation { function test($compare) { return false; } function testMessage($compare) { $dumper = $this->getDumper(); return 'Failed expectation never matches [' . $dumper->describeValue($compare) . ']'; } } class TrueExpectation extends SimpleExpectation { function test($compare) { return (boolean)$compare; } function testMessage($compare) { $dumper = $this->getDumper(); return 'Expected true, got [' . $dumper->describeValue($compare) . ']'; } } class FalseExpectation extends SimpleExpectation { function test($compare) { return ! (boolean)$compare; } function testMessage($compare) { $dumper = $this->getDumper(); return 'Expected false, got [' . $dumper->describeValue($compare) . ']'; } } class EqualExpectation extends SimpleExpectation { private $value; function __construct($value, $message = '%s') { parent::__construct($message); $this->value = $value; } function test($compare) { return (($this->value == $compare) && ($compare == $this->value)); } function testMessage($compare) { if ($this->test($compare)) { return "Equal expectation [" . $this->dumper->describeValue($this->value) . "]"; } else { return "Equal expectation fails " . $this->dumper->describeDifference($this->value, $compare); } } protected function getValue() { return $this->value; } } class NotEqualExpectation extends EqualExpectation { function __construct($value, $message = '%s') { parent::__construct($value, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { $dumper = $this->getDumper(); if ($this->test($compare)) { return "Not equal expectation passes " . $dumper->describeDifference($this->getValue(), $compare); } else { return "Not equal expectation fails [" . $dumper->describeValue($this->getValue()) . "] matches"; } } } class WithinMarginExpectation extends SimpleExpectation { private $upper; private $lower; function __construct($value, $margin, $message = '%s') { parent::__construct($message); $this->upper = $value + $margin; $this->lower = $value - $margin; } function test($compare) { return (($compare <= $this->upper) && ($compare >= $this->lower)); } function testMessage($compare) { if ($this->test($compare)) { return $this->withinMessage($compare); } else { return $this->outsideMessage($compare); } } protected function withinMessage($compare) { return "Within expectation [" . $this->dumper->describeValue($this->lower) . "] and [" . $this->dumper->describeValue($this->upper) . "]"; } protected function outsideMessage($compare) { if ($compare > $this->upper) { return "Outside expectation " . $this->dumper->describeDifference($compare, $this->upper); } else { return "Outside expectation " . $this->dumper->describeDifference($compare, $this->lower); } } } class OutsideMarginExpectation extends WithinMarginExpectation { function __construct($value, $margin, $message = '%s') { parent::__construct($value, $margin, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { if (! $this->test($compare)) { return $this->withinMessage($compare); } else { return $this->outsideMessage($compare); } } } class ReferenceExpectation { private $value; function __construct($value, $message = '%s') { $this->message = $message; $this->value = $value; } function test($compare) { return SimpleTestCompatibility::isReference($this->value, $compare); } function testMessage($compare) { if ($this->test($compare)) { return "Reference expectation [" . $this->dumper->describeValue($this->value) . "]"; } else { return "Reference expectation fails " . $this->dumper->describeDifference($this->value, $compare); } } function overlayMessage($compare, $dumper) { $this->dumper = $dumper; return sprintf($this->message, $this->testMessage($compare)); } protected function getDumper() { if (! $this->dumper) { $dumper = new SimpleDumper(); return $dumper; } return $this->dumper; } } class IdenticalExpectation extends EqualExpectation { function __construct($value, $message = '%s') { parent::__construct($value, $message); } function test($compare) { return SimpleTestCompatibility::isIdentical($this->getValue(), $compare); } function testMessage($compare) { $dumper = $this->getDumper(); if ($this->test($compare)) { return "Identical expectation [" . $dumper->describeValue($this->getValue()) . "]"; } else { return "Identical expectation [" . $dumper->describeValue($this->getValue()) . "] fails with [" . $dumper->describeValue($compare) . "] " . $dumper->describeDifference($this->getValue(), $compare, TYPE_MATTERS); } } } class NotIdenticalExpectation extends IdenticalExpectation { function __construct($value, $message = '%s') { parent::__construct($value, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { $dumper = $this->getDumper(); if ($this->test($compare)) { return "Not identical expectation passes " . $dumper->describeDifference($this->getValue(), $compare, TYPE_MATTERS); } else { return "Not identical expectation [" . $dumper->describeValue($this->getValue()) . "] matches"; } } } class PatternExpectation extends SimpleExpectation { private $pattern; function __construct($pattern, $message = '%s') { parent::__construct($message); $this->pattern = $pattern; } protected function getPattern() { return $this->pattern; } function test($compare) { return (boolean)preg_match($this->getPattern(), $compare); } function testMessage($compare) { if ($this->test($compare)) { return $this->describePatternMatch($this->getPattern(), $compare); } else { $dumper = $this->getDumper(); return "Pattern [" . $this->getPattern() . "] not detected in [" . $dumper->describeValue($compare) . "]"; } } protected function describePatternMatch($pattern, $subject) { preg_match($pattern, $subject, $matches); $position = strpos($subject, $matches[0]); $dumper = $this->getDumper(); return "Pattern [$pattern] detected at character [$position] in [" . $dumper->describeValue($subject) . "] as [" . $matches[0] . "] in region [" . $dumper->clipString($subject, 100, $position) . "]"; } } class NoPatternExpectation extends PatternExpectation { function __construct($pattern, $message = '%s') { parent::__construct($pattern, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { if ($this->test($compare)) { $dumper = $this->getDumper(); return "Pattern [" . $this->getPattern() . "] not detected in [" . $dumper->describeValue($compare) . "]"; } else { return $this->describePatternMatch($this->getPattern(), $compare); } } } class IsAExpectation extends SimpleExpectation { private $type; function __construct($type, $message = '%s') { parent::__construct($message); $this->type = $type; } protected function getType() { return $this->type; } function test($compare) { if (is_object($compare)) { return SimpleTestCompatibility::isA($compare, $this->type); } else { return (strtolower(gettype($compare)) == $this->canonicalType($this->type)); } } protected function canonicalType($type) { $type = strtolower($type); $map = array( 'bool' => 'boolean', 'float' => 'double', 'real' => 'double', 'int' => 'integer'); if (isset($map[$type])) { $type = $map[$type]; } return $type; } function testMessage($compare) { $dumper = $this->getDumper(); return "Value [" . $dumper->describeValue($compare) . "] should be type [" . $this->type . "]"; } } class NotAExpectation extends IsAExpectation { private $type; function __construct($type, $message = '%s') { parent::__construct($type, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { $dumper = $this->getDumper(); return "Value [" . $dumper->describeValue($compare) . "] should not be type [" . $this->getType() . "]"; } } class MethodExistsExpectation extends SimpleExpectation { private $method; function __construct($method, $message = '%s') { parent::__construct($message); $this->method = $method; } function test($compare) { return (boolean)(is_object($compare) && method_exists($compare, $this->method)); } function testMessage($compare) { $dumper = $this->getDumper(); if (! is_object($compare)) { return 'No method on non-object [' . $dumper->describeValue($compare) . ']'; } $method = $this->method; return "Object [" . $dumper->describeValue($compare) . "] should contain method [$method]"; } } class MemberExpectation extends IdenticalExpectation { private $name; function __construct($name, $expected) { $this->name = $name; parent::__construct($expected); } function test($actual) { if (! is_object($actual)) { return false; } return parent::test($this->getProperty($this->name, $actual)); } function testMessage($actual) { return parent::testMessage($this->getProperty($this->name, $actual)); } private function getProperty($name, $object) { $reflection = new ReflectionObject($object); $property = $reflection->getProperty($name); if (method_exists($property, 'setAccessible')) { $property->setAccessible(true); } try { return $property->getValue($object); } catch (ReflectionException $e) { return $this->getPrivatePropertyNoMatterWhat($name, $object); } } private function getPrivatePropertyNoMatterWhat($name, $object) { foreach ((array)$object as $mangled_name => $value) { if ($this->unmangle($mangled_name) == $name) { return $value; } } } function unmangle($mangled) { $parts = preg_split('/[^a-zA-Z0-9_\x7f-\xff]+/', $mangled); return array_pop($parts); } }   class SimpleForm { private $method; private $action; private $encoding; private $default_target; private $id; private $buttons; private $images; private $widgets; private $radios; private $checkboxes; function __construct($tag, $page) { $this->method = $tag->getAttribute('method'); $this->action = $this->createAction($tag->getAttribute('action'), $page); $this->encoding = $this->setEncodingClass($tag); $this->default_target = false; $this->id = $tag->getAttribute('id'); $this->buttons = array(); $this->images = array(); $this->widgets = array(); $this->radios = array(); $this->checkboxes = array(); } protected function setEncodingClass($tag) { if (strtolower($tag->getAttribute('method')) == 'post') { if (strtolower($tag->getAttribute('enctype')) == 'multipart/form-data') { return 'SimpleMultipartEncoding'; } return 'SimplePostEncoding'; } return 'SimpleGetEncoding'; } function setDefaultTarget($frame) { $this->default_target = $frame; } function getMethod() { return ($this->method ? strtolower($this->method) : 'get'); } protected function createAction($action, $page) { if (($action === '') || ($action === false)) { return $page->expandUrl($page->getUrl()); } return $page->expandUrl(new SimpleUrl($action));; } function getAction() { $url = $this->action; if ($this->default_target && ! $url->getTarget()) { $url->setTarget($this->default_target); } if ($this->getMethod() == 'get') { $url->clearRequest(); } return $url; } protected function encode() { $class = $this->encoding; $encoding = new $class(); for ($i = 0, $count = count($this->widgets); $i < $count; $i++) { $this->widgets[$i]->write($encoding); } return $encoding; } function getId() { return $this->id; } function addWidget($tag) { if (strtolower($tag->getAttribute('type')) == 'submit') { $this->buttons[] = $tag; } elseif (strtolower($tag->getAttribute('type')) == 'image') { $this->images[] = $tag; } elseif ($tag->getName()) { $this->setWidget($tag); } } protected function setWidget($tag) { if (strtolower($tag->getAttribute('type')) == 'radio') { $this->addRadioButton($tag); } elseif (strtolower($tag->getAttribute('type')) == 'checkbox') { $this->addCheckbox($tag); } else { $this->widgets[] = $tag; } } protected function addRadioButton($tag) { if (! isset($this->radios[$tag->getName()])) { $this->widgets[] = new SimpleRadioGroup(); $this->radios[$tag->getName()] = count($this->widgets) - 1; } $this->widgets[$this->radios[$tag->getName()]]->addWidget($tag); } protected function addCheckbox($tag) { if (! isset($this->checkboxes[$tag->getName()])) { $this->widgets[] = $tag; $this->checkboxes[$tag->getName()] = count($this->widgets) - 1; } else { $index = $this->checkboxes[$tag->getName()]; if (! SimpleTestCompatibility::isA($this->widgets[$index], 'SimpleCheckboxGroup')) { $previous = $this->widgets[$index]; $this->widgets[$index] = new SimpleCheckboxGroup(); $this->widgets[$index]->addWidget($previous); } $this->widgets[$index]->addWidget($tag); } } function getValue($selector) { for ($i = 0, $count = count($this->widgets); $i < $count; $i++) { if ($selector->isMatch($this->widgets[$i])) { return $this->widgets[$i]->getValue(); } } foreach ($this->buttons as $button) { if ($selector->isMatch($button)) { return $button->getValue(); } } return null; } function setField($selector, $value, $position=false) { $success = false; $_position = 0; for ($i = 0, $count = count($this->widgets); $i < $count; $i++) { if ($selector->isMatch($this->widgets[$i])) { $_position++; if ($position === false or $_position === (int)$position) { if ($this->widgets[$i]->setValue($value)) { $success = true; } } } } return $success; } function attachLabelBySelector($selector, $label) { for ($i = 0, $count = count($this->widgets); $i < $count; $i++) { if ($selector->isMatch($this->widgets[$i])) { if (method_exists($this->widgets[$i], 'setLabel')) { $this->widgets[$i]->setLabel($label); return; } } } } function hasSubmit($selector) { foreach ($this->buttons as $button) { if ($selector->isMatch($button)) { return true; } } return false; } function hasImage($selector) { foreach ($this->images as $image) { if ($selector->isMatch($image)) { return true; } } return false; } function submitButton($selector, $additional = false) { $additional = $additional ? $additional : array(); foreach ($this->buttons as $button) { if ($selector->isMatch($button)) { $encoding = $this->encode(); $button->write($encoding); if ($additional) { $encoding->merge($additional); } return $encoding; } } return false; } function submitImage($selector, $x, $y, $additional = false) { $additional = $additional ? $additional : array(); foreach ($this->images as $image) { if ($selector->isMatch($image)) { $encoding = $this->encode(); $image->write($encoding, $x, $y); if ($additional) { $encoding->merge($additional); } return $encoding; } } return false; } function submit() { return $this->encode(); } }   class SimpleFrameset { private $frameset; private $frames; private $focus; private $names; function __construct($page) { $this->frameset = $page; $this->frames = array(); $this->focus = false; $this->names = array(); } function addFrame($page, $name = false) { $this->frames[] = $page; if ($name) { $this->names[$name] = count($this->frames) - 1; } } function setFrame($path, $page) { $name = array_shift($path); if (isset($this->names[$name])) { $index = $this->names[$name]; } else { $index = $name - 1; } if (count($path) == 0) { $this->frames[$index] = $page; return; } $this->frames[$index]->setFrame($path, $page); } function getFrameFocus() { if ($this->focus === false) { return array(); } return array_merge( array($this->getPublicNameFromIndex($this->focus)), $this->frames[$this->focus]->getFrameFocus()); } protected function getPublicNameFromIndex($subject) { foreach ($this->names as $name => $index) { if ($subject == $index) { return $name; } } return $subject + 1; } function setFrameFocusByIndex($choice) { if (is_integer($this->focus)) { if ($this->frames[$this->focus]->hasFrames()) { return $this->frames[$this->focus]->setFrameFocusByIndex($choice); } } if (($choice < 1) || ($choice > count($this->frames))) { return false; } $this->focus = $choice - 1; return true; } function setFrameFocus($name) { if (is_integer($this->focus)) { if ($this->frames[$this->focus]->hasFrames()) { return $this->frames[$this->focus]->setFrameFocus($name); } } if (in_array($name, array_keys($this->names))) { $this->focus = $this->names[$name]; return true; } return false; } function clearFrameFocus() { $this->focus = false; $this->clearNestedFramesFocus(); } protected function clearNestedFramesFocus() { for ($i = 0; $i < count($this->frames); $i++) { $this->frames[$i]->clearFrameFocus(); } } function hasFrames() { return true; } function getFrames() { $report = array(); for ($i = 0; $i < count($this->frames); $i++) { $report[$this->getPublicNameFromIndex($i)] = $this->frames[$i]->getFrames(); } return $report; } function getRaw() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getRaw(); } $raw = ''; for ($i = 0; $i < count($this->frames); $i++) { $raw .= $this->frames[$i]->getRaw(); } return $raw; } function getText() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getText(); } $raw = ''; for ($i = 0; $i < count($this->frames); $i++) { $raw .= ' ' . $this->frames[$i]->getText(); } return trim($raw); } function getTransportError() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getTransportError(); } return $this->frameset->getTransportError(); } function getMethod() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getMethod(); } return $this->frameset->getMethod(); } function getUrl() { if (is_integer($this->focus)) { $url = $this->frames[$this->focus]->getUrl(); $url->setTarget($this->getPublicNameFromIndex($this->focus)); } else { $url = $this->frameset->getUrl(); } return $url; } function getBaseUrl() { if (is_integer($this->focus)) { $url = $this->frames[$this->focus]->getBaseUrl(); } else { $url = $this->frameset->getBaseUrl(); } return $url; } function expandUrl($url) { return $this->frameset->expandUrl($url); } function getRequestData() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getRequestData(); } return $this->frameset->getRequestData(); } function getMimeType() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getMimeType(); } return $this->frameset->getMimeType(); } function getResponseCode() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getResponseCode(); } return $this->frameset->getResponseCode(); } function getAuthentication() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getAuthentication(); } return $this->frameset->getAuthentication(); } function getRealm() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getRealm(); } return $this->frameset->getRealm(); } function getRequest() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getRequest(); } return $this->frameset->getRequest(); } function getHeaders() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getHeaders(); } return $this->frameset->getHeaders(); } function getTitle() { return $this->frameset->getTitle(); } function getUrls() { if (is_integer($this->focus)) { return $this->frames[$this->focus]->getUrls(); } $urls = array(); foreach ($this->frames as $frame) { $urls = array_merge($urls, $frame->getUrls()); } return array_values(array_unique($urls)); } function getUrlsByLabel($label) { if (is_integer($this->focus)) { return $this->tagUrlsWithFrame( $this->frames[$this->focus]->getUrlsByLabel($label), $this->focus); } $urls = array(); foreach ($this->frames as $index => $frame) { $urls = array_merge( $urls, $this->tagUrlsWithFrame( $frame->getUrlsByLabel($label), $index)); } return $urls; } function getUrlById($id) { foreach ($this->frames as $index => $frame) { if ($url = $frame->getUrlById($id)) { if (! $url->gettarget()) { $url->setTarget($this->getPublicNameFromIndex($index)); } return $url; } } return false; } protected function tagUrlsWithFrame($urls, $frame) { $tagged = array(); foreach ($urls as $url) { if (! $url->getTarget()) { $url->setTarget($this->getPublicNameFromIndex($frame)); } $tagged[] = $url; } return $tagged; } function getFormBySubmit($selector) { return $this->findForm('getFormBySubmit', $selector); } function getFormByImage($selector) { return $this->findForm('getFormByImage', $selector); } function getFormById($id) { return $this->findForm('getFormById', $id); } protected function findForm($method, $attribute) { if (is_integer($this->focus)) { return $this->findFormInFrame( $this->frames[$this->focus], $this->focus, $method, $attribute); } for ($i = 0; $i < count($this->frames); $i++) { $form = $this->findFormInFrame( $this->frames[$i], $i, $method, $attribute); if ($form) { return $form; } } $null = null; return $null; } protected function findFormInFrame($page, $index, $method, $attribute) { $form = $this->frames[$index]->$method($attribute); if (isset($form)) { $form->setDefaultTarget($this->getPublicNameFromIndex($index)); } return $form; } function setField($selector, $value) { if (is_integer($this->focus)) { $this->frames[$this->focus]->setField($selector, $value); } else { for ($i = 0; $i < count($this->frames); $i++) { $this->frames[$i]->setField($selector, $value); } } } function getField($selector) { for ($i = 0; $i < count($this->frames); $i++) { $value = $this->frames[$i]->getField($selector); if (isset($value)) { return $value; } } return null; } }   if (! defined('SIMPLE_TEST')) { define('SIMPLE_TEST', dirname(__FILE__) . '/'); } class SimpleInvoker { private $test_case; function __construct($test_case) { $this->test_case = $test_case; } function getTestCase() { return $this->test_case; } function before($method) { $this->test_case->before($method); } function invoke($method) { $this->test_case->setUp(); $this->test_case->$method(); $this->test_case->tearDown(); } function after($method) { $this->test_case->after($method); } } class SimpleInvokerDecorator { private $invoker; function __construct($invoker) { $this->invoker = $invoker; } function getTestCase() { return $this->invoker->getTestCase(); } function before($method) { $this->invoker->before($method); } function invoke($method) { $this->invoker->invoke($method); } function after($method) { $this->invoker->after($method); } }   class SimplePage { private $links = array(); private $title = false; private $last_widget; private $label; private $forms = array(); private $frames = array(); private $transport_error; private $raw; private $text = false; private $sent; private $headers; private $method; private $url; private $base = false; private $request_data; function __construct($response = false) { if ($response) { $this->extractResponse($response); } else { $this->noResponse(); } } protected function extractResponse($response) { $this->transport_error = $response->getError(); $this->raw = $response->getContent(); $this->sent = $response->getSent(); $this->headers = $response->getHeaders(); $this->method = $response->getMethod(); $this->url = $response->getUrl(); $this->request_data = $response->getRequestData(); } protected function noResponse() { $this->transport_error = 'No page fetched yet'; $this->raw = false; $this->sent = false; $this->headers = false; $this->method = 'GET'; $this->url = false; $this->request_data = false; } function getRequest() { return $this->sent; } function getRaw() { return $this->raw; } function getText() { if (! $this->text) { $this->text = SimplePage::normalise($this->raw); } return $this->text; } function getHeaders() { if ($this->headers) { return $this->headers->getRaw(); } return false; } function getMethod() { return $this->method; } function getUrl() { return $this->url; } function getBaseUrl() { return $this->base; } function getRequestData() { return $this->request_data; } function getTransportError() { return $this->transport_error; } function getMimeType() { if ($this->headers) { return $this->headers->getMimeType(); } return false; } function getResponseCode() { if ($this->headers) { return $this->headers->getResponseCode(); } return false; } function getAuthentication() { if ($this->headers) { return $this->headers->getAuthentication(); } return false; } function getRealm() { if ($this->headers) { return $this->headers->getRealm(); } return false; } function getFrameFocus() { return array(); } function setFrameFocusByIndex($choice) { return false; } function setFrameFocus($name) { return false; } function clearFrameFocus() { } function setFrames($frames) { $this->frames = $frames; } protected function linkIsAbsolute($url) { $parsed = new SimpleUrl($url); return (boolean)($parsed->getScheme() && $parsed->getHost()); } function addLink($tag) { $this->links[] = $tag; } function setForms($forms) { $this->forms = $forms; } function hasFrames() { return count($this->frames) > 0; } function getFrameset() { if (! $this->hasFrames()) { return false; } $urls = array(); for ($i = 0; $i < count($this->frames); $i++) { $name = $this->frames[$i]->getAttribute('name'); $url = new SimpleUrl($this->frames[$i]->getAttribute('src')); $urls[$name ? $name : $i + 1] = $this->expandUrl($url); } return $urls; } function getFrames() { $url = $this->expandUrl($this->getUrl()); return $url->asString(); } function getUrls() { $all = array(); foreach ($this->links as $link) { $url = $this->getUrlFromLink($link); $all[] = $url->asString(); } return $all; } function getUrlsByLabel($label) { $matches = array(); foreach ($this->links as $link) { if ($link->getText() == $label) { $matches[] = $this->getUrlFromLink($link); } } return $matches; } function getUrlById($id) { foreach ($this->links as $link) { if ($link->getAttribute('id') === (string)$id) { return $this->getUrlFromLink($link); } } return false; } protected function getUrlFromLink($link) { $url = $this->expandUrl($link->getHref()); if ($link->getAttribute('target')) { $url->setTarget($link->getAttribute('target')); } return $url; } function expandUrl($url) { if (! is_object($url)) { $url = new SimpleUrl($url); } $location = $this->getBaseUrl() ? $this->getBaseUrl() : new SimpleUrl(); return $url->makeAbsolute($location->makeAbsolute($this->getUrl())); } function setBase($url) { $this->base = new SimpleUrl($url); } function setTitle($tag) { $this->title = $tag; } function getTitle() { if ($this->title) { return $this->title->getText(); } return false; } function getFormBySubmit($selector) { for ($i = 0; $i < count($this->forms); $i++) { if ($this->forms[$i]->hasSubmit($selector)) { return $this->forms[$i]; } } return null; } function getFormByImage($selector) { for ($i = 0; $i < count($this->forms); $i++) { if ($this->forms[$i]->hasImage($selector)) { return $this->forms[$i]; } } return null; } function getFormById($id) { for ($i = 0; $i < count($this->forms); $i++) { if ($this->forms[$i]->getId() == $id) { return $this->forms[$i]; } } return null; } function setField($selector, $value, $position=false) { $is_set = false; for ($i = 0; $i < count($this->forms); $i++) { if ($this->forms[$i]->setField($selector, $value, $position)) { $is_set = true; } } return $is_set; } function getField($selector) { for ($i = 0; $i < count($this->forms); $i++) { $value = $this->forms[$i]->getValue($selector); if (isset($value)) { return $value; } } return null; } static function normalise($html) { $text = preg_replace('#<!--.*?-->#si', '', $html); $text = preg_replace('#<(script|option|textarea)[^>]*>.*?</\1>#si', '', $text); $text = preg_replace('#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#', ' \2\3\4 ', $text); $text = preg_replace('#<[^>]*>#', '', $text); $text = html_entity_decode($text, ENT_QUOTES); $text = preg_replace('#\s+#', ' ', $text); return trim(trim($text), "\xA0"); } }   foreach (array('LEXER_ENTER', 'LEXER_MATCHED', 'LEXER_UNMATCHED', 'LEXER_EXIT', 'LEXER_SPECIAL') as $i => $constant) { if (! defined($constant)) { define($constant, $i + 1); } } class ParallelRegex { private $patterns; private $labels; private $regex; private $case; function __construct($case) { $this->case = $case; $this->patterns = array(); $this->labels = array(); $this->regex = null; } function addPattern($pattern, $label = true) { $count = count($this->patterns); $this->patterns[$count] = $pattern; $this->labels[$count] = $label; $this->regex = null; } function match($subject, $match) { if (count($this->patterns) == 0) { return false; } if (! preg_match($this->getCompoundedRegex(), $subject, $matches)) { $match = ''; return false; } $match = $matches[0]; for ($i = 1; $i < count($matches); $i++) { if ($matches[$i]) { return $this->labels[$i - 1]; } } return true; } protected function getCompoundedRegex() { if ($this->regex == null) { for ($i = 0, $count = count($this->patterns); $i < $count; $i++) { $this->patterns[$i] = '(' . str_replace( array('/', '(', ')'), array('\/', '\(', '\)'), $this->patterns[$i]) . ')'; } $this->regex = "/" . implode("|", $this->patterns) . "/" . $this->getPerlMatchingFlags(); } return $this->regex; } protected function getPerlMatchingFlags() { return ($this->case ? "msS" : "msSi"); } } class SimpleStateStack { private $stack; function __construct($start) { $this->stack = array($start); } function getCurrent() { return $this->stack[count($this->stack) - 1]; } function enter($state) { array_push($this->stack, $state); } function leave() { if (count($this->stack) == 1) { return false; } array_pop($this->stack); return true; } } class SimpleLexer { private $regexes; private $parser; private $mode; private $mode_handlers; private $case; function __construct($parser, $start = "accept", $case = false) { $this->case = $case; $this->regexes = array(); $this->parser = $parser; $this->mode = new SimpleStateStack($start); $this->mode_handlers = array($start => $start); } function addPattern($pattern, $mode = "accept") { if (! isset($this->regexes[$mode])) { $this->regexes[$mode] = new ParallelRegex($this->case); } $this->regexes[$mode]->addPattern($pattern); if (! isset($this->mode_handlers[$mode])) { $this->mode_handlers[$mode] = $mode; } } function addEntryPattern($pattern, $mode, $new_mode) { if (! isset($this->regexes[$mode])) { $this->regexes[$mode] = new ParallelRegex($this->case); } $this->regexes[$mode]->addPattern($pattern, $new_mode); if (! isset($this->mode_handlers[$new_mode])) { $this->mode_handlers[$new_mode] = $new_mode; } } function addExitPattern($pattern, $mode) { if (! isset($this->regexes[$mode])) { $this->regexes[$mode] = new ParallelRegex($this->case); } $this->regexes[$mode]->addPattern($pattern, "__exit"); if (! isset($this->mode_handlers[$mode])) { $this->mode_handlers[$mode] = $mode; } } function addSpecialPattern($pattern, $mode, $special) { if (! isset($this->regexes[$mode])) { $this->regexes[$mode] = new ParallelRegex($this->case); } $this->regexes[$mode]->addPattern($pattern, "_$special"); if (! isset($this->mode_handlers[$special])) { $this->mode_handlers[$special] = $special; } } function mapHandler($mode, $handler) { $this->mode_handlers[$mode] = $handler; } function parse($raw) { if (! isset($this->parser)) { return false; } $length = strlen($raw); while (is_array($parsed = $this->reduce($raw))) { list($raw, $unmatched, $matched, $mode) = $parsed; if (! $this->dispatchTokens($unmatched, $matched, $mode)) { return false; } if ($raw === '') { return true; } if (strlen($raw) == $length) { return false; } $length = strlen($raw); } if (! $parsed) { return false; } return $this->invokeParser($raw, LEXER_UNMATCHED); } protected function dispatchTokens($unmatched, $matched, $mode = false) { if (! $this->invokeParser($unmatched, LEXER_UNMATCHED)) { return false; } if (is_bool($mode)) { return $this->invokeParser($matched, LEXER_MATCHED); } if ($this->isModeEnd($mode)) { if (! $this->invokeParser($matched, LEXER_EXIT)) { return false; } return $this->mode->leave(); } if ($this->isSpecialMode($mode)) { $this->mode->enter($this->decodeSpecial($mode)); if (! $this->invokeParser($matched, LEXER_SPECIAL)) { return false; } return $this->mode->leave(); } $this->mode->enter($mode); return $this->invokeParser($matched, LEXER_ENTER); } protected function isModeEnd($mode) { return ($mode === "__exit"); } protected function isSpecialMode($mode) { return (strncmp($mode, "_", 1) == 0); } protected function decodeSpecial($mode) { return substr($mode, 1); } protected function invokeParser($content, $is_match) { if (($content === '') || ($content === false)) { return true; } $handler = $this->mode_handlers[$this->mode->getCurrent()]; return $this->parser->$handler($content, $is_match); } protected function reduce($raw) { if ($action = $this->regexes[$this->mode->getCurrent()]->match($raw, $match)) { $unparsed_character_count = strpos($raw, $match); $unparsed = substr($raw, 0, $unparsed_character_count); $raw = substr($raw, $unparsed_character_count + strlen($match)); return array($raw, $unparsed, $match, $action); } return true; } } class SimpleHtmlLexer extends SimpleLexer { function __construct($parser) { parent::__construct($parser, 'text'); $this->mapHandler('text', 'acceptTextToken'); $this->addSkipping(); foreach ($this->getParsedTags() as $tag) { $this->addTag($tag); } $this->addInTagTokens(); } protected function getParsedTags() { return array('a', 'base', 'title', 'form', 'input', 'button', 'textarea', 'select', 'option', 'frameset', 'frame', 'label'); } protected function addSkipping() { $this->mapHandler('css', 'ignore'); $this->addEntryPattern('<style', 'text', 'css'); $this->addExitPattern('</style>', 'css'); $this->mapHandler('js', 'ignore'); $this->addEntryPattern('<script', 'text', 'js'); $this->addExitPattern('</script>', 'js'); $this->mapHandler('comment', 'ignore'); $this->addEntryPattern('<!--', 'text', 'comment'); $this->addExitPattern('-->', 'comment'); } protected function addTag($tag) { $this->addSpecialPattern("</$tag>", 'text', 'acceptEndToken'); $this->addEntryPattern("<$tag", 'text', 'tag'); } protected function addInTagTokens() { $this->mapHandler('tag', 'acceptStartToken'); $this->addSpecialPattern('\s+', 'tag', 'ignore'); $this->addAttributeTokens(); $this->addExitPattern('/>', 'tag'); $this->addExitPattern('>', 'tag'); } protected function addAttributeTokens() { $this->mapHandler('dq_attribute', 'acceptAttributeToken'); $this->addEntryPattern('=\s*"', 'tag', 'dq_attribute'); $this->addPattern("\\\\\"", 'dq_attribute'); $this->addExitPattern('"', 'dq_attribute'); $this->mapHandler('sq_attribute', 'acceptAttributeToken'); $this->addEntryPattern("=\s*'", 'tag', 'sq_attribute'); $this->addPattern("\\\\'", 'sq_attribute'); $this->addExitPattern("'", 'sq_attribute'); $this->mapHandler('uq_attribute', 'acceptAttributeToken'); $this->addSpecialPattern('=\s*[^>\s]*', 'tag', 'uq_attribute'); } } class SimpleHtmlSaxParser { private $lexer; private $listener; private $tag; private $attributes; private $current_attribute; function __construct($listener) { $this->listener = $listener; $this->lexer = $this->createLexer($this); $this->tag = ''; $this->attributes = array(); $this->current_attribute = ''; } function parse($raw) { return $this->lexer->parse($raw); } static function createLexer($parser) { return new SimpleHtmlLexer($parser); } function acceptStartToken($token, $event) { if ($event == LEXER_ENTER) { $this->tag = strtolower(substr($token, 1)); return true; } if ($event == LEXER_EXIT) { $success = $this->listener->startElement( $this->tag, $this->attributes); $this->tag = ''; $this->attributes = array(); return $success; } if ($token != '=') { $this->current_attribute = strtolower(html_entity_decode($token, ENT_QUOTES)); $this->attributes[$this->current_attribute] = ''; } return true; } function acceptEndToken($token, $event) { if (! preg_match('/<\/(.*)>/', $token, $matches)) { return false; } return $this->listener->endElement(strtolower($matches[1])); } function acceptAttributeToken($token, $event) { if ($this->current_attribute) { if ($event == LEXER_UNMATCHED) { $this->attributes[$this->current_attribute] .= html_entity_decode($token, ENT_QUOTES); } if ($event == LEXER_SPECIAL) { $this->attributes[$this->current_attribute] .= preg_replace('/^=\s*/' , '', html_entity_decode($token, ENT_QUOTES)); } } return true; } function acceptEntityToken($token, $event) { } function acceptTextToken($token, $event) { return $this->listener->addContent($token); } function ignore($token, $event) { return true; } } class SimplePhpPageBuilder { private $tags; private $page; private $private_content_tag; private $open_forms = array(); private $complete_forms = array(); private $frameset = false; private $loading_frames = array(); private $frameset_nesting_level = 0; private $left_over_labels = array(); function free() { unset($this->tags); unset($this->page); unset($this->private_content_tags); $this->open_forms = array(); $this->complete_forms = array(); $this->frameset = false; $this->loading_frames = array(); $this->frameset_nesting_level = 0; $this->left_over_labels = array(); } function can() { return true; } function parse($response) { $this->tags = array(); $this->page = $this->createPage($response); $parser = $this->createParser($this); $parser->parse($response->getContent()); $this->acceptPageEnd(); $page = $this->page; $this->free(); return $page; } protected function createPage($response) { return new SimplePage($response); } protected function createParser($listener) { return new SimpleHtmlSaxParser($listener); } function startElement($name, $attributes) { $factory = new SimpleTagBuilder(); $tag = $factory->createTag($name, $attributes); if (! $tag) { return true; } if ($tag->getTagName() == 'label') { $this->acceptLabelStart($tag); $this->openTag($tag); return true; } if ($tag->getTagName() == 'form') { $this->acceptFormStart($tag); return true; } if ($tag->getTagName() == 'frameset') { $this->acceptFramesetStart($tag); return true; } if ($tag->getTagName() == 'frame') { $this->acceptFrame($tag); return true; } if ($tag->isPrivateContent() && ! isset($this->private_content_tag)) { $this->private_content_tag = $tag; } if ($tag->expectEndTag()) { $this->openTag($tag); return true; } $this->acceptTag($tag); return true; } function endElement($name) { if ($name == 'label') { $this->acceptLabelEnd(); return true; } if ($name == 'form') { $this->acceptFormEnd(); return true; } if ($name == 'frameset') { $this->acceptFramesetEnd(); return true; } if ($this->hasNamedTagOnOpenTagStack($name)) { $tag = array_pop($this->tags[$name]); if ($tag->isPrivateContent() && $this->private_content_tag->getTagName() == $name) { unset($this->private_content_tag); } $this->addContentTagToOpenTags($tag); $this->acceptTag($tag); return true; } return true; } protected function hasNamedTagOnOpenTagStack($name) { return isset($this->tags[$name]) && (count($this->tags[$name]) > 0); } function addContent($text) { if (isset($this->private_content_tag)) { $this->private_content_tag->addContent($text); } else { $this->addContentToAllOpenTags($text); } return true; } protected function addContentToAllOpenTags($text) { foreach (array_keys($this->tags) as $name) { for ($i = 0, $count = count($this->tags[$name]); $i < $count; $i++) { $this->tags[$name][$i]->addContent($text); } } } protected function addContentTagToOpenTags($tag) { if ($tag->getTagName() != 'option') { return; } foreach (array_keys($this->tags) as $name) { for ($i = 0, $count = count($this->tags[$name]); $i < $count; $i++) { $this->tags[$name][$i]->addTag($tag); } } } protected function openTag($tag) { $name = $tag->getTagName(); if (! in_array($name, array_keys($this->tags))) { $this->tags[$name] = array(); } $this->tags[$name][] = $tag; } protected function acceptTag($tag) { if ($tag->getTagName() == "a") { $this->page->addLink($tag); } elseif ($tag->getTagName() == "base") { $this->page->setBase($tag->getAttribute('href')); } elseif ($tag->getTagName() == "title") { $this->page->setTitle($tag); } elseif ($this->isFormElement($tag->getTagName())) { for ($i = 0; $i < count($this->open_forms); $i++) { $this->open_forms[$i]->addWidget($tag); } $this->last_widget = $tag; } } protected function acceptLabelStart($tag) { $this->label = $tag; unset($this->last_widget); } protected function acceptLabelEnd() { if (isset($this->label)) { if (isset($this->last_widget)) { $this->last_widget->setLabel($this->label->getText()); unset($this->last_widget); } else { $this->left_over_labels[] = SimpleTestCompatibility::copy($this->label); } unset($this->label); } } protected function isFormElement($name) { return in_array($name, array('input', 'button', 'textarea', 'select')); } protected function acceptFormStart($tag) { $this->open_forms[] = new SimpleForm($tag, $this->page); } protected function acceptFormEnd() { if (count($this->open_forms)) { $this->complete_forms[] = array_pop($this->open_forms); } } protected function acceptFramesetStart($tag) { if (! $this->isLoadingFrames()) { $this->frameset = $tag; } $this->frameset_nesting_level++; } protected function acceptFramesetEnd() { if ($this->isLoadingFrames()) { $this->frameset_nesting_level--; } } protected function acceptFrame($tag) { if ($this->isLoadingFrames()) { if ($tag->getAttribute('src')) { $this->loading_frames[] = $tag; } } } protected function isLoadingFrames() { return $this->frameset and $this->frameset_nesting_level > 0; } protected function acceptPageEnd() { while (count($this->open_forms)) { $this->complete_forms[] = array_pop($this->open_forms); } foreach ($this->left_over_labels as $label) { for ($i = 0, $count = count($this->complete_forms); $i < $count; $i++) { $this->complete_forms[$i]->attachLabelBySelector( new SimpleById($label->getFor()), $label->getText()); } } $this->page->setForms($this->complete_forms); $this->page->setFrames($this->loading_frames); } }   class SimpleReflection { private $interface; function __construct($interface) { $this->interface = $interface; } function classExists() { if (! class_exists($this->interface)) { return false; } $reflection = new ReflectionClass($this->interface); return ! $reflection->isInterface(); } function classExistsSansAutoload() { return class_exists($this->interface, false); } function classOrInterfaceExists() { return $this->classOrInterfaceExistsWithAutoload($this->interface, true); } function classOrInterfaceExistsSansAutoload() { return $this->classOrInterfaceExistsWithAutoload($this->interface, false); } protected function classOrInterfaceExistsWithAutoload($interface, $autoload) { if (function_exists('interface_exists')) { if (interface_exists($this->interface, $autoload)) { return true; } } return class_exists($this->interface, $autoload); } function getMethods() { return array_unique(get_class_methods($this->interface)); } function getInterfaces() { $reflection = new ReflectionClass($this->interface); if ($reflection->isInterface()) { return array($this->interface); } return $this->onlyParents($reflection->getInterfaces()); } function getInterfaceMethods() { $methods = array(); foreach ($this->getInterfaces() as $interface) { $methods = array_merge($methods, get_class_methods($interface)); } return array_unique($methods); } protected function isInterfaceMethod($method) { return in_array($method, $this->getInterfaceMethods()); } function getParent() { $reflection = new ReflectionClass($this->interface); $parent = $reflection->getParentClass(); if ($parent) { return $parent->getName(); } return false; } function isAbstract() { $reflection = new ReflectionClass($this->interface); return $reflection->isAbstract(); } function isInterface() { $reflection = new ReflectionClass($this->interface); return $reflection->isInterface(); } function hasFinal() { $reflection = new ReflectionClass($this->interface); foreach ($reflection->getMethods() as $method) { if ($method->isFinal()) { return true; } } return false; } protected function onlyParents($interfaces) { $parents = array(); $blacklist = array(); foreach ($interfaces as $interface) { foreach($interfaces as $possible_parent) { if ($interface->getName() == $possible_parent->getName()) { continue; } if ($interface->isSubClassOf($possible_parent)) { $blacklist[$possible_parent->getName()] = true; } } if (!isset($blacklist[$interface->getName()])) { $parents[] = $interface->getName(); } } return $parents; } protected function isAbstractMethod($name) { $interface = new ReflectionClass($this->interface); if (! $interface->hasMethod($name)) { return false; } return $interface->getMethod($name)->isAbstract(); } protected function isConstructor($name) { return ($name == '__construct') || ($name == $this->interface); } protected function isAbstractMethodInParents($name) { $interface = new ReflectionClass($this->interface); $parent = $interface->getParentClass(); while($parent) { if (! $parent->hasMethod($name)) { return false; } if ($parent->getMethod($name)->isAbstract()) { return true; } $parent = $parent->getParentClass(); } return false; } protected function isStaticMethod($name) { $interface = new ReflectionClass($this->interface); if (! $interface->hasMethod($name)) { return false; } return $interface->getMethod($name)->isStatic(); } function getSignature($name) { if ($name == '__set') { return 'function __set($key, $value)'; } if ($name == '__call') { return 'function __call($method, $arguments)'; } if (version_compare(phpversion(), '5.1.0', '>=')) { if (in_array($name, array('__get', '__isset', $name == '__unset'))) { return "function {$name}(\$key)"; } } if ($name == '__toString') { return "function $name()"; } try { $interface = new ReflectionClass($this->interface); $interface->getMethod($name); } catch (ReflectionException $e) { return "function $name()"; } return $this->getFullSignature($name); } protected function getFullSignature($name) { $interface = new ReflectionClass($this->interface); $method = $interface->getMethod($name); $reference = $method->returnsReference() ? '&' : ''; $static = $method->isStatic() ? 'static ' : ''; return "{$static}function $reference$name(" . implode(', ', $this->getParameterSignatures($method)) . ")"; } protected function getParameterSignatures($method) { $signatures = array(); foreach ($method->getParameters() as $parameter) { $signature = ''; $type = $parameter->getClass(); if (is_null($type) && version_compare(phpversion(), '5.1.0', '>=') && $parameter->isArray()) { $signature .= 'array '; } elseif (!is_null($type)) { $signature .= $type->getName() . ' '; } if ($parameter->isPassedByReference()) { $signature .= '&'; } $signature .= '$' . $this->suppressSpurious($parameter->getName()); if ($this->isOptional($parameter)) { $signature .= ' = null'; } $signatures[] = $signature; } return $signatures; } protected function suppressSpurious($name) { return str_replace(array('[', ']', ' '), '', $name); } protected function isOptional($parameter) { if (method_exists($parameter, 'isOptional')) { return $parameter->isOptional(); } return false; } }   class RemoteTestCase { private $url; private $dry_url; private $size; function __construct($url, $dry_url = false) { $this->url = $url; $this->dry_url = $dry_url ? $dry_url : $url; $this->size = false; } function getLabel() { return $this->url; } function run($reporter) { $browser = $this->createBrowser(); $xml = $browser->get($this->url); if (! $xml) { trigger_error('Cannot read remote test URL [' . $this->url . ']'); return false; } $parser = $this->createParser($reporter); if (! $parser->parse($xml)) { trigger_error('Cannot parse incoming XML from [' . $this->url . ']'); return false; } return true; } protected function createBrowser() { return new SimpleBrowser(); } protected function createParser($reporter) { return new SimpleTestXmlParser($reporter); } function getSize() { if ($this->size === false) { $browser = $this->createBrowser(); $xml = $browser->get($this->dry_url); if (! $xml) { trigger_error('Cannot read remote test URL [' . $this->dry_url . ']'); return false; } $reporter = new SimpleReporter(); $parser = $this->createParser($reporter); if (! $parser->parse($xml)) { trigger_error('Cannot parse incoming XML from [' . $this->dry_url . ']'); return false; } $this->size = $reporter->getTestCaseCount(); } return $this->size; } }   class SimpleScorer { private $passes; private $fails; private $exceptions; private $is_dry_run; function __construct() { $this->passes = 0; $this->fails = 0; $this->exceptions = 0; $this->is_dry_run = false; } function makeDry($is_dry = true) { $this->is_dry_run = $is_dry; } function shouldInvoke($test_case_name, $method) { return ! $this->is_dry_run; } function createInvoker($invoker) { return $invoker; } function getStatus() { if ($this->exceptions + $this->fails > 0) { return false; } return true; } function paintGroupStart($test_name, $size) { } function paintGroupEnd($test_name) { } function paintCaseStart($test_name) { } function paintCaseEnd($test_name) { } function paintMethodStart($test_name) { } function paintMethodEnd($test_name) { } function paintPass($message) { $this->passes++; } function paintFail($message) { $this->fails++; } function paintError($message) { $this->exceptions++; } function paintException($exception) { $this->exceptions++; } function paintSkip($message) { } function getPassCount() { return $this->passes; } function getFailCount() { return $this->fails; } function getExceptionCount() { return $this->exceptions; } function paintMessage($message) { } function paintFormattedMessage($message) { } function paintSignal($type, $payload) { } } class SimpleReporter extends SimpleScorer { private $test_stack; private $size; private $progress; function __construct() { parent::__construct(); $this->test_stack = array(); $this->size = null; $this->progress = 0; } function getDumper() { return new SimpleDumper(); } function paintGroupStart($test_name, $size) { if (! isset($this->size)) { $this->size = $size; } if (count($this->test_stack) == 0) { $this->paintHeader($test_name); } $this->test_stack[] = $test_name; } function paintGroupEnd($test_name) { array_pop($this->test_stack); if (count($this->test_stack) == 0) { $this->paintFooter($test_name); } } function paintCaseStart($test_name) { if (! isset($this->size)) { $this->size = 1; } if (count($this->test_stack) == 0) { $this->paintHeader($test_name); } $this->test_stack[] = $test_name; } function paintCaseEnd($test_name) { $this->progress++; array_pop($this->test_stack); if (count($this->test_stack) == 0) { $this->paintFooter($test_name); } } function paintMethodStart($test_name) { $this->test_stack[] = $test_name; } function paintMethodEnd($test_name) { array_pop($this->test_stack); } function paintHeader($test_name) { } function paintFooter($test_name) { } function getTestList() { return $this->test_stack; } function getTestCaseCount() { return $this->size; } function getTestCaseProgress() { return $this->progress; } static function inCli() { return php_sapi_name() == 'cli'; } } class SimpleReporterDecorator { protected $reporter; function __construct($reporter) { $this->reporter = $reporter; } function makeDry($is_dry = true) { $this->reporter->makeDry($is_dry); } function getStatus() { return $this->reporter->getStatus(); } function getTestList() { if (method_exists($this->reporter, 'getTestList')) { return $this->reporter->getTestList(); } else { return array(); } } function shouldInvoke($test_case_name, $method) { return $this->reporter->shouldInvoke($test_case_name, $method); } function createInvoker($invoker) { return $this->reporter->createInvoker($invoker); } function getDumper() { return $this->reporter->getDumper(); } function paintGroupStart($test_name, $size) { $this->reporter->paintGroupStart($test_name, $size); } function paintGroupEnd($test_name) { $this->reporter->paintGroupEnd($test_name); } function paintCaseStart($test_name) { $this->reporter->paintCaseStart($test_name); } function paintCaseEnd($test_name) { $this->reporter->paintCaseEnd($test_name); } function paintMethodStart($test_name) { $this->reporter->paintMethodStart($test_name); } function paintMethodEnd($test_name) { $this->reporter->paintMethodEnd($test_name); } function paintPass($message) { $this->reporter->paintPass($message); } function paintFail($message) { $this->reporter->paintFail($message); } function paintError($message) { $this->reporter->paintError($message); } function paintException($exception) { $this->reporter->paintException($exception); } function paintSkip($message) { $this->reporter->paintSkip($message); } function paintMessage($message) { $this->reporter->paintMessage($message); } function paintFormattedMessage($message) { $this->reporter->paintFormattedMessage($message); } function paintSignal($type, $payload) { $this->reporter->paintSignal($type, $payload); } } class MultipleReporter { private $reporters = array(); function attachReporter($reporter) { $this->reporters[] = $reporter; } function makeDry($is_dry = true) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->makeDry($is_dry); } } function getStatus() { for ($i = 0; $i < count($this->reporters); $i++) { if (! $this->reporters[$i]->getStatus()) { return false; } } return true; } function shouldInvoke($test_case_name, $method) { for ($i = 0; $i < count($this->reporters); $i++) { if (! $this->reporters[$i]->shouldInvoke($test_case_name, $method)) { return false; } } return true; } function createInvoker($invoker) { for ($i = 0; $i < count($this->reporters); $i++) { $invoker = $this->reporters[$i]->createInvoker($invoker); } return $invoker; } function getDumper() { return new SimpleDumper(); } function paintGroupStart($test_name, $size) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintGroupStart($test_name, $size); } } function paintGroupEnd($test_name) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintGroupEnd($test_name); } } function paintCaseStart($test_name) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintCaseStart($test_name); } } function paintCaseEnd($test_name) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintCaseEnd($test_name); } } function paintMethodStart($test_name) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintMethodStart($test_name); } } function paintMethodEnd($test_name) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintMethodEnd($test_name); } } function paintPass($message) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintPass($message); } } function paintFail($message) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintFail($message); } } function paintError($message) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintError($message); } } function paintException($exception) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintException($exception); } } function paintSkip($message) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintSkip($message); } } function paintMessage($message) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintMessage($message); } } function paintFormattedMessage($message) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintFormattedMessage($message); } } function paintSignal($type, $payload) { for ($i = 0; $i < count($this->reporters); $i++) { $this->reporters[$i]->paintSignal($type, $payload); } } }   class SimpleByName { private $name; function __construct($name) { $this->name = $name; } function getName() { return $this->name; } function isMatch($widget) { return ($widget->getName() == $this->name); } } class SimpleByLabel { private $label; function __construct($label) { $this->label = $label; } function isMatch($widget) { if (! method_exists($widget, 'isLabel')) { return false; } return $widget->isLabel($this->label); } } class SimpleById { private $id; function __construct($id) { $this->id = $id; } function isMatch($widget) { return $widget->isId($this->id); } } class SimpleByLabelOrName { private $label; function __construct($label) { $this->label = $label; } function isMatch($widget) { if (method_exists($widget, 'isLabel')) { if ($widget->isLabel($this->label)) { return true; } } return ($widget->getName() == $this->label); } }   class SimpleTest { static function getVersion() { $content = file(dirname(__FILE__) . '/VERSION'); return trim($content[0]); } static function ignore($class) { $registry = SimpleTest::getRegistry(); $registry['IgnoreList'][strtolower($class)] = true; } static function ignoreParentsIfIgnored($classes) { $registry = SimpleTest::getRegistry(); foreach ($classes as $class) { if (SimpleTest::isIgnored($class)) { $reflection = new SimpleReflection($class); if ($parent = $reflection->getParent()) { SimpleTest::ignore($parent); } } } } static function prefer($object) { $registry = SimpleTest::getRegistry(); $registry['Preferred'][] = $object; } static function preferred($classes) { if (! is_array($classes)) { $classes = array($classes); } $registry = SimpleTest::getRegistry(); for ($i = count($registry['Preferred']) - 1; $i >= 0; $i--) { foreach ($classes as $class) { if (SimpleTestCompatibility::isA($registry['Preferred'][$i], $class)) { return $registry['Preferred'][$i]; } } } return null; } static function isIgnored($class) { $registry = SimpleTest::getRegistry(); return isset($registry['IgnoreList'][strtolower($class)]); } static function useProxy($proxy, $username = false, $password = false) { $registry = SimpleTest::getRegistry(); $registry['DefaultProxy'] = $proxy; $registry['DefaultProxyUsername'] = $username; $registry['DefaultProxyPassword'] = $password; } static function getDefaultProxy() { $registry = SimpleTest::getRegistry(); return $registry['DefaultProxy']; } static function getDefaultProxyUsername() { $registry = SimpleTest::getRegistry(); return $registry['DefaultProxyUsername']; } static function getDefaultProxyPassword() { $registry = SimpleTest::getRegistry(); return $registry['DefaultProxyPassword']; } static function getParsers() { $registry = SimpleTest::getRegistry(); return $registry['Parsers']; } static function setParsers($parsers) { $registry = SimpleTest::getRegistry(); $registry['Parsers'] = $parsers; } protected static function getRegistry() { static $registry = false; if (! $registry) { $registry = SimpleTest::getDefaults(); } return $registry; } static function getContext() { static $context = false; if (! $context) { $context = new SimpleTestContext(); } return $context; } protected static function getDefaults() { return array( 'Parsers' => false, 'MockBaseClass' => 'SimpleMock', 'IgnoreList' => array(), 'DefaultProxy' => false, 'DefaultProxyUsername' => false, 'DefaultProxyPassword' => false, 'Preferred' => array(new HtmlReporter(), new TextReporter(), new XmlReporter())); } static function setMockBaseClass($mock_base) { $registry = SimpleTest::getRegistry(); $registry['MockBaseClass'] = $mock_base; } static function getMockBaseClass() { $registry = SimpleTest::getRegistry(); return $registry['MockBaseClass']; } } class SimpleTestContext { private $test; private $reporter; private $resources; function clear() { $this->resources = array(); } function setTest($test) { $this->clear(); $this->test = $test; } function getTest() { return $this->test; } function setReporter($reporter) { $this->clear(); $this->reporter = $reporter; } function getReporter() { return $this->reporter; } function get($resource) { if (! isset($this->resources[$resource])) { $this->resources[$resource] = new $resource(); } return $this->resources[$resource]; } } class SimpleStackTrace { private $prefixes; function __construct($prefixes) { $this->prefixes = $prefixes; } function traceMethod($stack = false) { $stack = $stack ? $stack : $this->captureTrace(); foreach ($stack as $frame) { if ($this->frameLiesWithinSimpleTestFolder($frame)) { continue; } if ($this->frameMatchesPrefix($frame)) { return ' at [' . $frame['file'] . ' line ' . $frame['line'] . ']'; } } return ''; } protected function frameLiesWithinSimpleTestFolder($frame) { if (isset($frame['file'])) { $path = substr(SIMPLE_TEST, 0, -1); if (strpos($frame['file'], $path) === 0) { if (dirname($frame['file']) == $path) { return true; } } } return false; } protected function frameMatchesPrefix($frame) { foreach ($this->prefixes as $prefix) { if (strncmp($frame['function'], $prefix, strlen($prefix)) == 0) { return true; } } return false; } protected function captureTrace() { if (function_exists('debug_backtrace')) { return array_reverse(debug_backtrace()); } return array(); } }   class SimpleStickyError { private $error = 'Constructor not chained'; function __construct() { $this->clearError(); } function isError() { return ($this->error != ''); } function getError() { return $this->error; } function setError($error) { $this->error = $error; } function clearError() { $this->setError(''); } } class SimpleFileSocket extends SimpleStickyError { private $handle; private $is_open = false; private $sent = ''; private $block_size; function __construct($file, $block_size = 1024) { parent::__construct(); if (! ($this->handle = $this->openFile($file, $error))) { $file_string = $file->asString(); $this->setError("Cannot open [$file_string] with [$error]"); return; } $this->is_open = true; $this->block_size = $block_size; } function write($message) { return true; } function read() { $raw = @fread($this->handle, $this->block_size); if ($raw === false) { $this->setError('Cannot read from socket'); $this->close(); } return $raw; } function isOpen() { return $this->is_open; } function close() { if (!$this->is_open) return false; $this->is_open = false; return fclose($this->handle); } function getSent() { return $this->sent; } protected function openFile($file, $error) { return @fopen($file->asString(), 'r'); } } class SimpleSocket extends SimpleStickyError { private $handle; private $is_open = false; private $sent = ''; private $lock_size; function __construct($host, $port, $timeout, $block_size = 255) { parent::__construct(); if (! ($this->handle = $this->openSocket($host, $port, $error_number, $error, $timeout))) { $this->setError("Cannot open [$host:$port] with [$error] within [$timeout] seconds"); return; } $this->is_open = true; $this->block_size = $block_size; SimpleTestCompatibility::setTimeout($this->handle, $timeout); } function write($message) { if ($this->isError() || ! $this->isOpen()) { return false; } $count = fwrite($this->handle, $message); if (! $count) { if ($count === false) { $this->setError('Cannot write to socket'); $this->close(); } return false; } fflush($this->handle); $this->sent .= $message; return true; } function read() { if ($this->isError() || ! $this->isOpen()) { return false; } $raw = @fread($this->handle, $this->block_size); if ($raw === false) { $this->setError('Cannot read from socket'); $this->close(); } return $raw; } function isOpen() { return $this->is_open; } function close() { $this->is_open = false; return fclose($this->handle); } function getSent() { return $this->sent; } protected function openSocket($host, $port, $error_number, $error, $timeout) { return @fsockopen($host, $port, $error_number, $error, $timeout); } } class SimpleSecureSocket extends SimpleSocket { function __construct($host, $port, $timeout) { parent::__construct($host, $port, $timeout); } function openSocket($host, $port, $error_number, $error, $timeout) { return parent::openSocket("tls://$host", $port, $error_number, $error, $timeout); } }   class SimpleTagBuilder { function createTag($name, $attributes) { static $map = array( 'a' => 'SimpleAnchorTag', 'title' => 'SimpleTitleTag', 'base' => 'SimpleBaseTag', 'button' => 'SimpleButtonTag', 'textarea' => 'SimpleTextAreaTag', 'option' => 'SimpleOptionTag', 'label' => 'SimpleLabelTag', 'form' => 'SimpleFormTag', 'frame' => 'SimpleFrameTag'); $attributes = $this->keysToLowerCase($attributes); if (array_key_exists($name, $map)) { $tag_class = $map[$name]; return new $tag_class($attributes); } elseif ($name == 'select') { return $this->createSelectionTag($attributes); } elseif ($name == 'input') { return $this->createInputTag($attributes); } return new SimpleTag($name, $attributes); } protected function createSelectionTag($attributes) { if (isset($attributes['multiple'])) { return new MultipleSelectionTag($attributes); } return new SimpleSelectionTag($attributes); } protected function createInputTag($attributes) { if (! isset($attributes['type'])) { return new SimpleTextTag($attributes); } $type = strtolower(trim($attributes['type'])); $map = array( 'submit' => 'SimpleSubmitTag', 'image' => 'SimpleImageSubmitTag', 'checkbox' => 'SimpleCheckboxTag', 'radio' => 'SimpleRadioButtonTag', 'text' => 'SimpleTextTag', 'hidden' => 'SimpleTextTag', 'password' => 'SimpleTextTag', 'file' => 'SimpleUploadTag'); if (array_key_exists($type, $map)) { $tag_class = $map[$type]; return new $tag_class($attributes); } return false; } protected function keysToLowerCase($map) { $lower = array(); foreach ($map as $key => $value) { $lower[strtolower($key)] = $value; } return $lower; } } class SimpleTag { private $name; private $attributes; private $content; function __construct($name, $attributes) { $this->name = strtolower(trim($name)); $this->attributes = $attributes; $this->content = ''; } function expectEndTag() { return true; } function isPrivateContent() { return false; } function addContent($content) { $this->content .= (string)$content; return $this; } function addTag($tag) { } function addTags($tags) { foreach ($tags as $tag) { $this->addTag($tag); } } function getTagName() { return $this->name; } function getChildElements() { return array(); } function getAttribute($label) { $label = strtolower($label); if (! isset($this->attributes[$label])) { return false; } return (string)$this->attributes[$label]; } protected function setAttribute($label, $value) { $this->attributes[strtolower($label)] = $value; } function getContent() { return $this->content; } function getText() { return SimplePage::normalise($this->content); } function isId($id) { return ($this->getAttribute('id') == $id); } } class SimpleBaseTag extends SimpleTag { function __construct($attributes) { parent::__construct('base', $attributes); } function expectEndTag() { return false; } } class SimpleTitleTag extends SimpleTag { function __construct($attributes) { parent::__construct('title', $attributes); } } class SimpleAnchorTag extends SimpleTag { function __construct($attributes) { parent::__construct('a', $attributes); } function getHref() { $url = $this->getAttribute('href'); if (is_bool($url)) { $url = ''; } return $url; } } class SimpleWidget extends SimpleTag { private $value; private $label; private $is_set; function __construct($name, $attributes) { parent::__construct($name, $attributes); $this->value = false; $this->label = false; $this->is_set = false; } function getName() { return $this->getAttribute('name'); } function getDefault() { return $this->getAttribute('value'); } function getValue() { if (! $this->is_set) { return $this->getDefault(); } return $this->value; } function setValue($value) { $this->value = $value; $this->is_set = true; return true; } function resetValue() { $this->is_set = false; } function setLabel($label) { $this->label = trim($label); return $this; } function isLabel($label) { return $this->label == trim($label); } function write($encoding) { if ($this->getName()) { $encoding->add($this->getName(), $this->getValue()); } } } class SimpleTextTag extends SimpleWidget { function __construct($attributes) { parent::__construct('input', $attributes); if ($this->getAttribute('value') === false) { $this->setAttribute('value', ''); } } function expectEndTag() { return false; } function setValue($value) { if ($this->getAttribute('type') == 'hidden') { return false; } return parent::setValue($value); } } class SimpleSubmitTag extends SimpleWidget { function __construct($attributes) { parent::__construct('input', $attributes); if ($this->getAttribute('value') === false) { $this->setAttribute('value', 'Submit'); } } function expectEndTag() { return false; } function setValue($value) { return false; } function getLabel() { return $this->getValue(); } function isLabel($label) { return trim($label) == trim($this->getLabel()); } } class SimpleImageSubmitTag extends SimpleWidget { function __construct($attributes) { parent::__construct('input', $attributes); } function expectEndTag() { return false; } function setValue($value) { return false; } function getLabel() { if ($this->getAttribute('title')) { return $this->getAttribute('title'); } return $this->getAttribute('alt'); } function isLabel($label) { return trim($label) == trim($this->getLabel()); } function write($encoding, $x = 1, $y = 1) { if ($this->getName()) { $encoding->add($this->getName() . '.x', $x); $encoding->add($this->getName() . '.y', $y); } else { $encoding->add('x', $x); $encoding->add('y', $y); } } } class SimpleButtonTag extends SimpleWidget { function __construct($attributes) { parent::__construct('button', $attributes); } function expectEndTag() { return true; } function setValue($value) { return false; } function getLabel() { return $this->getContent(); } function isLabel($label) { return trim($label) == trim($this->getLabel()); } } class SimpleTextAreaTag extends SimpleWidget { function __construct($attributes) { parent::__construct('textarea', $attributes); } function getDefault() { return $this->wrap(html_entity_decode($this->getContent(), ENT_QUOTES)); } function setValue($value) { return parent::setValue($this->wrap($value)); } function wrapIsEnabled() { if ($this->getAttribute('cols')) { $wrap = $this->getAttribute('wrap'); if (($wrap == 'physical') || ($wrap == 'hard')) { return true; } } return false; } protected function wrap($text) { $text = str_replace("\r\r\n", "\r\n", str_replace("\n", "\r\n", $text)); $text = str_replace("\r\n\n", "\r\n", str_replace("\r", "\r\n", $text)); if (strncmp($text, "\r\n", strlen("\r\n")) == 0) { $text = substr($text, strlen("\r\n")); } if ($this->wrapIsEnabled()) { return wordwrap( $text, (integer)$this->getAttribute('cols'), "\r\n"); } return $text; } function isPrivateContent() { return true; } } class SimpleUploadTag extends SimpleWidget { function __construct($attributes) { parent::__construct('input', $attributes); } function expectEndTag() { return false; } function write($encoding) { if (! file_exists($this->getValue())) { return; } $encoding->attach( $this->getName(), implode('', file($this->getValue())), basename($this->getValue())); } } class SimpleSelectionTag extends SimpleWidget { private $options; private $choice; function __construct($attributes) { parent::__construct('select', $attributes); $this->options = array(); $this->choice = false; } function addTag($tag) { if ($tag->getTagName() == 'option') { $this->options[] = $tag; } } function addContent($content) { return $this; } function getDefault() { for ($i = 0, $count = count($this->options); $i < $count; $i++) { if ($this->options[$i]->getAttribute('selected') !== false) { return $this->options[$i]->getDefault(); } } if ($count > 0) { return $this->options[0]->getDefault(); } return ''; } function setValue($value) { for ($i = 0, $count = count($this->options); $i < $count; $i++) { if ($this->options[$i]->isValue($value)) { $this->choice = $i; return true; } } return false; } function getValue() { if ($this->choice === false) { return $this->getDefault(); } return $this->options[$this->choice]->getValue(); } } class MultipleSelectionTag extends SimpleWidget { private $options; private $values; function __construct($attributes) { parent::__construct('select', $attributes); $this->options = array(); $this->values = false; } function addTag($tag) { if ($tag->getTagName() == 'option') { $this->options[] = $tag; } } function addContent($content) { return $this; } function getDefault() { $default = array(); for ($i = 0, $count = count($this->options); $i < $count; $i++) { if ($this->options[$i]->getAttribute('selected') !== false) { $default[] = $this->options[$i]->getDefault(); } } return $default; } function setValue($desired) { $achieved = array(); foreach ($desired as $value) { $success = false; for ($i = 0, $count = count($this->options); $i < $count; $i++) { if ($this->options[$i]->isValue($value)) { $achieved[] = $this->options[$i]->getValue(); $success = true; break; } } if (! $success) { return false; } } $this->values = $achieved; return true; } function getValue() { if ($this->values === false) { return $this->getDefault(); } return $this->values; } } class SimpleOptionTag extends SimpleWidget { function __construct($attributes) { parent::__construct('option', $attributes); } function setValue($value) { return false; } function isValue($compare) { $compare = trim($compare); if (trim($this->getValue()) == $compare) { return true; } return trim(strip_tags($this->getContent())) == $compare; } function getDefault() { if ($this->getAttribute('value') === false) { return strip_tags($this->getContent()); } return $this->getAttribute('value'); } function isPrivateContent() { return true; } } class SimpleRadioButtonTag extends SimpleWidget { function __construct($attributes) { parent::__construct('input', $attributes); if ($this->getAttribute('value') === false) { $this->setAttribute('value', 'on'); } } function expectEndTag() { return false; } function setValue($value) { if ($value === false) { return parent::setValue($value); } if ($value != $this->getAttribute('value')) { return false; } return parent::setValue($value); } function getDefault() { if ($this->getAttribute('checked') !== false) { return $this->getAttribute('value'); } return false; } } class SimpleCheckboxTag extends SimpleWidget { function __construct($attributes) { parent::__construct('input', $attributes); if ($this->getAttribute('value') === false) { $this->setAttribute('value', 'on'); } } function expectEndTag() { return false; } function setValue($value) { if ($value === false) { return parent::setValue($value); } if ($value === true) { return parent::setValue($this->getAttribute('value')); } if ($value != $this->getAttribute('value')) { return false; } return parent::setValue($value); } function getDefault() { if ($this->getAttribute('checked') !== false) { return $this->getAttribute('value'); } return false; } } class SimpleTagGroup { private $widgets = array(); function addWidget($widget) { $this->widgets[] = $widget; } protected function getWidgets() { return $this->widgets; } function getAttribute($label) { return false; } function getName() { if (count($this->widgets) > 0) { return $this->widgets[0]->getName(); } } function isId($id) { for ($i = 0, $count = count($this->widgets); $i < $count; $i++) { if ($this->widgets[$i]->isId($id)) { return true; } } return false; } function isLabel($label) { for ($i = 0, $count = count($this->widgets); $i < $count; $i++) { if ($this->widgets[$i]->isLabel($label)) { return true; } } return false; } function write($encoding) { $encoding->add($this->getName(), $this->getValue()); } } class SimpleCheckboxGroup extends SimpleTagGroup { function getValue() { $values = array(); $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { if ($widgets[$i]->getValue() !== false) { $values[] = $widgets[$i]->getValue(); } } return $this->coerceValues($values); } function getDefault() { $values = array(); $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { if ($widgets[$i]->getDefault() !== false) { $values[] = $widgets[$i]->getDefault(); } } return $this->coerceValues($values); } function setValue($values) { $values = $this->makeArray($values); if (! $this->valuesArePossible($values)) { return false; } $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { $possible = $widgets[$i]->getAttribute('value'); if (in_array($widgets[$i]->getAttribute('value'), $values)) { $widgets[$i]->setValue($possible); } else { $widgets[$i]->setValue(false); } } return true; } protected function valuesArePossible($values) { $matches = array(); $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { $possible = $widgets[$i]->getAttribute('value'); if (in_array($possible, $values)) { $matches[] = $possible; } } return ($values == $matches); } protected function coerceValues($values) { if (count($values) == 0) { return false; } elseif (count($values) == 1) { return $values[0]; } else { return $values; } } protected function makeArray($value) { if ($value === false) { return array(); } if (is_string($value)) { return array($value); } return $value; } } class SimpleRadioGroup extends SimpleTagGroup { function setValue($value) { if (! $this->valueIsPossible($value)) { return false; } $index = false; $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { if (! $widgets[$i]->setValue($value)) { $widgets[$i]->setValue(false); } } return true; } protected function valueIsPossible($value) { $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { if ($widgets[$i]->getAttribute('value') == $value) { return true; } } return false; } function getValue() { $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { if ($widgets[$i]->getValue() !== false) { return $widgets[$i]->getValue(); } } return false; } function getDefault() { $widgets = $this->getWidgets(); for ($i = 0, $count = count($widgets); $i < $count; $i++) { if ($widgets[$i]->getDefault() !== false) { return $widgets[$i]->getDefault(); } } return false; } } class SimpleLabelTag extends SimpleTag { function __construct($attributes) { parent::__construct('label', $attributes); } function getFor() { return $this->getAttribute('for'); } } class SimpleFormTag extends SimpleTag { function __construct($attributes) { parent::__construct('form', $attributes); } } class SimpleFrameTag extends SimpleTag { function __construct($attributes) { parent::__construct('frame', $attributes); } function expectEndTag() { return false; } }   if (! defined('SIMPLE_TEST')) { define('SIMPLE_TEST', dirname(__FILE__) . DIRECTORY_SEPARATOR); } class SimpleTestCase { private $label = false; protected $reporter; private $observers; private $should_skip = false; function __construct($label = false) { if ($label) { $this->label = $label; } } function getLabel() { return $this->label ? $this->label : get_class($this); } function skip() { } function skipIf($should_skip, $message = '%s') { if ($should_skip && ! $this->should_skip) { $this->should_skip = true; $message = sprintf($message, 'Skipping [' . get_class($this) . ']'); $this->reporter->paintSkip($message . $this->getAssertionLine()); } } function shouldSkip() { return $this->should_skip; } function skipUnless($shouldnt_skip, $message = false) { $this->skipIf(! $shouldnt_skip, $message); } function createInvoker() { return new SimpleErrorTrappingInvoker( new SimpleExceptionTrappingInvoker(new SimpleInvoker($this))); } function run($reporter) { $context = SimpleTest::getContext(); $context->setTest($this); $context->setReporter($reporter); $this->reporter = $reporter; $started = false; foreach ($this->getTests() as $method) { if ($reporter->shouldInvoke($this->getLabel(), $method)) { $this->skip(); if ($this->should_skip) { break; } if (! $started) { $reporter->paintCaseStart($this->getLabel()); $started = true; } $invoker = $this->reporter->createInvoker($this->createInvoker()); $invoker->before($method); $invoker->invoke($method); $invoker->after($method); } } if ($started) { $reporter->paintCaseEnd($this->getLabel()); } unset($this->reporter); return $reporter->getStatus(); } function getTests() { $methods = array(); foreach (get_class_methods(get_class($this)) as $method) { if ($this->isTest($method)) { $methods[] = $method; } } return $methods; } protected function isTest($method) { if (strtolower(substr($method, 0, 4)) == 'test') { return ! SimpleTestCompatibility::isA($this, strtolower($method)); } return false; } function before($method) { $this->reporter->paintMethodStart($method); $this->observers = array(); } function setUp() { } function tearDown() { } function after($method) { for ($i = 0; $i < count($this->observers); $i++) { $this->observers[$i]->atTestEnd($method, $this); } $this->reporter->paintMethodEnd($method); } function tell($observer) { $this->observers[] = $observer; } function pass($message = "Pass") { if (! isset($this->reporter)) { trigger_error('Can only make assertions within test methods'); } $this->reporter->paintPass( $message . $this->getAssertionLine()); return true; } function fail($message = "Fail") { if (! isset($this->reporter)) { trigger_error('Can only make assertions within test methods'); } $this->reporter->paintFail( $message . $this->getAssertionLine()); return false; } function error($severity, $message, $file, $line) { if (! isset($this->reporter)) { trigger_error('Can only make assertions within test methods'); } $this->reporter->paintError( "Unexpected PHP error [$message] severity [$severity] in [$file line $line]"); } function exception($exception) { $this->reporter->paintException($exception); } function signal($type, $payload) { if (! isset($this->reporter)) { trigger_error('Can only make assertions within test methods'); } $this->reporter->paintSignal($type, $payload); } function assert($expectation, $compare, $message = '%s') { if ($expectation->test($compare)) { return $this->pass(sprintf( $message, $expectation->overlayMessage($compare, $this->reporter->getDumper()))); } else { return $this->fail(sprintf( $message, $expectation->overlayMessage($compare, $this->reporter->getDumper()))); } } function getAssertionLine() { $trace = new SimpleStackTrace(array('assert', 'expect', 'pass', 'fail', 'skip')); return $trace->traceMethod(); } function dump($variable, $message = false) { $dumper = $this->reporter->getDumper(); $formatted = $dumper->dump($variable); if ($message) { $formatted = $message . "\n" . $formatted; } $this->reporter->paintFormattedMessage($formatted); return $variable; } function getSize() { return 1; } } class SimpleFileLoader { function load($test_file) { $existing_classes = get_declared_classes(); $existing_globals = get_defined_vars(); $new_globals = get_defined_vars(); $this->makeFileVariablesGlobal($existing_globals, $new_globals); $new_classes = array_diff(get_declared_classes(), $existing_classes); if (empty($new_classes)) { $new_classes = $this->scrapeClassesFromFile($test_file); } $classes = $this->selectRunnableTests($new_classes); return $this->createSuiteFromClasses($test_file, $classes); } protected function makeFileVariablesGlobal($existing, $new) { $globals = array_diff(array_keys($new), array_keys($existing)); foreach ($globals as $global) { $GLOBALS[$global] = $new[$global]; } } protected function scrapeClassesFromFile($test_file) { preg_match_all('~^\s*class\s+(\w+)(\s+(extends|implements)\s+\w+)*\s*\{~mi', file_get_contents($test_file), $matches ); return $matches[1]; } function selectRunnableTests($candidates) { $classes = array(); foreach ($candidates as $class) { if (TestSuite::getBaseTestCase($class)) { $reflection = new SimpleReflection($class); if ($reflection->isAbstract()) { SimpleTest::ignore($class); } else { $classes[] = $class; } } } return $classes; } function createSuiteFromClasses($title, $classes) { if (count($classes) == 0) { $suite = new BadTestSuite($title, "No runnable test cases in [$title]"); return $suite; } SimpleTest::ignoreParentsIfIgnored($classes); $suite = new TestSuite($title); foreach ($classes as $class) { if (! SimpleTest::isIgnored($class)) { $suite->add($class); } } return $suite; } } class TestSuite { private $label; private $test_cases; function TestSuite($label = false) { $this->label = $label; $this->test_cases = array(); } function getLabel() { if (! $this->label) { return ($this->getSize() == 1) ? get_class($this->test_cases[0]) : get_class($this); } else { return $this->label; } } function add($test_case) { if (! is_string($test_case)) { $this->test_cases[] = $test_case; } elseif (TestSuite::getBaseTestCase($test_case) == 'testsuite') { $this->test_cases[] = new $test_case(); } else { $this->test_cases[] = $test_case; } } function addFile($test_file) { $extractor = new SimpleFileLoader(); $this->add($extractor->load($test_file)); } function collect($path, $collector) { $collector->collect($this, $path); } function run($reporter) { $reporter->paintGroupStart($this->getLabel(), $this->getSize()); for ($i = 0, $count = count($this->test_cases); $i < $count; $i++) { if (is_string($this->test_cases[$i])) { $class = $this->test_cases[$i]; $test = new $class(); $test->run($reporter); unset($test); } else { $this->test_cases[$i]->run($reporter); } } $reporter->paintGroupEnd($this->getLabel()); return $reporter->getStatus(); } function getSize() { $count = 0; foreach ($this->test_cases as $case) { if (is_string($case)) { if (! SimpleTest::isIgnored($case)) { $count++; } } else { $count += $case->getSize(); } } return $count; } static function getBaseTestCase($class) { while ($class = get_parent_class($class)) { $class = strtolower($class); if ($class == 'simpletestcase' || $class == 'testsuite') { return $class; } } return false; } } class BadTestSuite { private $label; private $error; function BadTestSuite($label, $error) { $this->label = $label; $this->error = $error; } function getLabel() { return $this->label; } function run($reporter) { $reporter->paintGroupStart($this->getLabel(), $this->getSize()); $reporter->paintFail('Bad TestSuite [' . $this->getLabel() . '] with error [' . $this->error . ']'); $reporter->paintGroupEnd($this->getLabel()); return $reporter->getStatus(); } function getSize() { return 0; } }   class SimpleTidyPageBuilder { private $page; private $forms = array(); private $labels = array(); private $widgets_by_id = array(); public function __destruct() { $this->free(); } private function free() { unset($this->page); $this->forms = array(); $this->labels = array(); } function can() { return extension_loaded('tidy'); } function parse($response) { $this->page = new SimplePage($response); $tidied = tidy_parse_string($input = $this->insertGuards($response->getContent()), array('output-xml' => false, 'wrap' => '0', 'indent' => 'no'), 'latin1'); $this->walkTree($tidied->html()); $this->attachLabels($this->widgets_by_id, $this->labels); $this->page->setForms($this->forms); $page = $this->page; $this->free(); return $page; } private function insertGuards($html) { return $this->insertEmptyTagGuards($this->insertTextareaSimpleWhitespaceGuards($html)); } private function stripGuards($html) { return $this->stripTextareaWhitespaceGuards($this->stripEmptyTagGuards($html)); } private function insertEmptyTagGuards($html) { return preg_replace('#<(option|textarea)([^>]*)>(\s*)</(option|textarea)>#is', '<\1\2>___EMPTY___\3</\4>', $html); } private function stripEmptyTagGuards($html) { return preg_replace('#(^|>)(\s*)___EMPTY___(\s*)(</|$)#i', '\2\3', $html); } private function insertTextareaSimpleWhitespaceGuards($html) { return preg_replace_callback('#<textarea([^>]*)>(.*?)</textarea>#is', array($this, 'insertWhitespaceGuards'), $html); } private function insertWhitespaceGuards($matches) { return '<textarea' . $matches[1] . '>' . str_replace(array("\n", "\r", "\t", ' '), array('___NEWLINE___', '___CR___', '___TAB___', '___SPACE___'), $matches[2]) . '</textarea>'; } private function stripTextareaWhitespaceGuards($html) { return str_replace(array('___NEWLINE___', '___CR___', '___TAB___', '___SPACE___'), array("\n", "\r", "\t", ' '), $html); } private function walkTree($node) { if ($node->name == 'a') { $this->page->addLink($this->tags()->createTag($node->name, (array)$node->attribute) ->addContent($this->innerHtml($node))); } elseif ($node->name == 'base' and isset($node->attribute['href'])) { $this->page->setBase($node->attribute['href']); } elseif ($node->name == 'title') { $this->page->setTitle($this->tags()->createTag($node->name, (array)$node->attribute) ->addContent($this->innerHtml($node))); } elseif ($node->name == 'frameset') { $this->page->setFrames($this->collectFrames($node)); } elseif ($node->name == 'form') { $this->forms[] = $this->walkForm($node, $this->createEmptyForm($node)); } elseif ($node->name == 'label') { $this->labels[] = $this->tags()->createTag($node->name, (array)$node->attribute) ->addContent($this->innerHtml($node)); } else { $this->walkChildren($node); } } private function walkChildren($node) { if ($node->hasChildren()) { foreach ($node->child as $child) { $this->walkTree($child); } } } private function createEmptyForm($node) { return new SimpleForm($this->tags()->createTag($node->name, (array)$node->attribute), $this->page); } private function walkForm($node, $form, $enclosing_label = '') { if ($node->name == 'a') { $this->page->addLink($this->tags()->createTag($node->name, (array)$node->attribute) ->addContent($this->innerHtml($node))); } elseif (in_array($node->name, array('input', 'button', 'textarea', 'select'))) { $this->addWidgetToForm($node, $form, $enclosing_label); } elseif ($node->name == 'label') { $this->labels[] = $this->tags()->createTag($node->name, (array)$node->attribute) ->addContent($this->innerHtml($node)); if ($node->hasChildren()) { foreach ($node->child as $child) { $this->walkForm($child, $form, SimplePage::normalise($this->innerHtml($node))); } } } elseif ($node->hasChildren()) { foreach ($node->child as $child) { $this->walkForm($child, $form); } } return $form; } private function hasFor($node) { return isset($node->attribute) and $node->attribute['for']; } private function addWidgetToForm($node, $form, $enclosing_label) { $widget = $this->tags()->createTag($node->name, $this->attributes($node)); if (! $widget) { return; } $widget->setLabel($enclosing_label) ->addContent($this->innerHtml($node)); if ($node->name == 'select') { $widget->addTags($this->collectSelectOptions($node)); } $form->addWidget($widget); $this->indexWidgetById($widget); } private function indexWidgetById($widget) { $id = $widget->getAttribute('id'); if (! $id) { return; } if (! isset($this->widgets_by_id[$id])) { $this->widgets_by_id[$id] = array(); } $this->widgets_by_id[$id][] = $widget; } private function collectSelectOptions($node) { $options = array(); if ($node->name == 'option') { $options[] = $this->tags()->createTag($node->name, $this->attributes($node)) ->addContent($this->innerHtml($node)); } if ($node->hasChildren()) { foreach ($node->child as $child) { $options = array_merge($options, $this->collectSelectOptions($child)); } } return $options; } private function attributes($node) { if (! preg_match('|<[^ ]+\s(.*?)/?>|s', $node->value, $first_tag_contents)) { return array(); } $attributes = array(); preg_match_all('/\S+\s*=\s*\'[^\']*\'|(\S+\s*=\s*"[^"]*")|([^ =]+\s*=\s*[^ "\']+?)|[^ "\']+/', $first_tag_contents[1], $matches); foreach($matches[0] as $unparsed) { $attributes = $this->mergeAttribute($attributes, $unparsed); } return $attributes; } private function mergeAttribute($attributes, $raw) { $parts = explode('=', $raw); list($name, $value) = count($parts) == 1 ? array($parts[0], $parts[0]) : $parts; $attributes[trim($name)] = html_entity_decode($this->dequote(trim($value)), ENT_QUOTES); return $attributes; } private function dequote($quoted) { if (preg_match('/^(\'([^\']*)\'|"([^"]*)")$/', $quoted, $matches)) { return isset($matches[3]) ? $matches[3] : $matches[2]; } return $quoted; } private function collectFrames($node) { $frames = array(); if ($node->name == 'frame') { $frames = array($this->tags()->createTag($node->name, (array)$node->attribute)); } else if ($node->hasChildren()) { $frames = array(); foreach ($node->child as $child) { $frames = array_merge($frames, $this->collectFrames($child)); } } return $frames; } private function innerHtml($node) { $raw = ''; if ($node->hasChildren()) { foreach ($node->child as $child) { $raw .= $child->value; } } return $this->stripGuards($raw); } private function tags() { return new SimpleTagBuilder(); } private function attachLabels($widgets_by_id, $labels) { foreach ($labels as $label) { $for = $label->getFor(); if ($for and isset($widgets_by_id[$for])) { $text = $label->getText(); foreach ($widgets_by_id[$for] as $widget) { $widget->setLabel($text); } } } } }   class SimpleUrl { private $scheme; private $username; private $password; private $host; private $port; public $path; private $request; private $fragment; private $x; private $y; private $target; private $raw = false; function __construct($url = '') { list($x, $y) = $this->chompCoordinates($url); $this->setCoordinates($x, $y); $this->scheme = $this->chompScheme($url); if ($this->scheme === 'file') { $url = str_replace('\\', '/', $url); } list($this->username, $this->password) = $this->chompLogin($url); $this->host = $this->chompHost($url); $this->port = false; if (preg_match('/(.*?):(.*)/', $this->host, $host_parts)) { if ($this->scheme === 'file' && strlen($this->host) === 2) { $url = '/' . $this->host . $url; $this->host = false; } else { $this->host = $host_parts[1]; $this->port = (integer)$host_parts[2]; } } $this->path = $this->chompPath($url); $this->request = $this->parseRequest($this->chompRequest($url)); $this->fragment = (strncmp($url, "#", 1) == 0 ? substr($url, 1) : false); $this->target = false; } protected function chompCoordinates($url) { if (preg_match('/(.*)\?(\d+),(\d+)$/', $url, $matches)) { $url = $matches[1]; return array((integer)$matches[2], (integer)$matches[3]); } return array(false, false); } protected function chompScheme($url) { if (preg_match('#^([^/:]*):(//)(.*)#', $url, $matches)) { $url = $matches[2] . $matches[3]; return $matches[1]; } return false; } protected function chompLogin($url) { $prefix = ''; if (preg_match('#^(//)(.*)#', $url, $matches)) { $prefix = $matches[1]; $url = $matches[2]; } if (preg_match('#^([^/]*)@(.*)#', $url, $matches)) { $url = $prefix . $matches[2]; $parts = explode(":", $matches[1]); return array( urldecode($parts[0]), isset($parts[1]) ? urldecode($parts[1]) : false); } $url = $prefix . $url; return array(false, false); } protected function chompHost($url) { if (preg_match('!^(//)(.*?)(/.*|\?.*|#.*|$)!', $url, $matches)) { $url = $matches[3]; return $matches[2]; } if (preg_match('!(.*?)(\.\./|\./|/|\?|#|$)(.*)!', $url, $matches)) { $tlds = SimpleUrl::getAllTopLevelDomains(); if (preg_match('/[a-z0-9\-]+\.(' . $tlds . ')/i', $matches[1])) { $url = $matches[2] . $matches[3]; return $matches[1]; } elseif (preg_match('/[a-z0-9\-]+\.[a-z0-9\-]+\.[a-z0-9\-]+/i', $matches[1])) { $url = $matches[2] . $matches[3]; return $matches[1]; } } return false; } protected function chompPath($url) { if (preg_match('/(.*?)(\?|#|$)(.*)/', $url, $matches)) { $url = $matches[2] . $matches[3]; return ($matches[1] ? $matches[1] : ''); } return ''; } protected function chompRequest($url) { if (preg_match('/\?(.*?)(#|$)(.*)/', $url, $matches)) { $url = $matches[2] . $matches[3]; return $matches[1]; } return ''; } protected function parseRequest($raw) { $this->raw = $raw; $request = new SimpleGetEncoding(); foreach (explode("&", $raw) as $pair) { if (preg_match('/(.*?)=(.*)/', $pair, $matches)) { $request->add(urldecode($matches[1]), urldecode($matches[2])); } elseif ($pair) { $request->add(urldecode($pair), ''); } } return $request; } function getScheme($default = false) { return $this->scheme ? $this->scheme : $default; } function getUsername() { return $this->username; } function getPassword() { return $this->password; } function getHost($default = false) { return $this->host ? $this->host : $default; } function getTld() { $path_parts = pathinfo($this->getHost()); return (isset($path_parts['extension']) ? $path_parts['extension'] : false); } function getPort() { return $this->port; } function getPath() { if (! $this->path && $this->host) { return '/'; } return $this->path; } function getPage() { if (! preg_match('/([^\/]*?)$/', $this->getPath(), $matches)) { return false; } return $matches[1]; } function getBasePath() { if (! preg_match('/(.*\/)[^\/]*?$/', $this->getPath(), $matches)) { return false; } return $matches[1]; } function getFragment() { return $this->fragment; } function setCoordinates($x = false, $y = false) { if (($x === false) || ($y === false)) { $this->x = $this->y = false; return; } $this->x = (integer)$x; $this->y = (integer)$y; } function getX() { return $this->x; } function getY() { return $this->y; } function getEncodedRequest() { if ($this->raw) { $encoded = $this->raw; } else { $encoded = $this->request->asUrlRequest(); } if ($encoded) { return '?' . preg_replace('/^\?/', '', $encoded); } return ''; } function addRequestParameter($key, $value) { $this->raw = false; $this->request->add($key, $value); } function addRequestParameters($parameters) { $this->raw = false; $this->request->merge($parameters); } function clearRequest() { $this->raw = false; $this->request = new SimpleGetEncoding(); } function getTarget() { return $this->target; } function setTarget($frame) { $this->raw = false; $this->target = $frame; } function asString() { $path = $this->path; $scheme = $identity = $host = $port = $encoded = $fragment = ''; if ($this->username && $this->password) { $identity = $this->username . ':' . $this->password . '@'; } if ($this->getHost()) { $scheme = $this->getScheme() ? $this->getScheme() : 'http'; $scheme .= '://'; $host = $this->getHost(); } elseif ($this->getScheme() === 'file') { $scheme = 'file://'; } if ($this->getPort() && $this->getPort() != 80 ) { $port = ':'.$this->getPort(); } if (substr($this->path, 0, 1) == '/') { $path = $this->normalisePath($this->path); } $encoded = $this->getEncodedRequest(); $fragment = $this->getFragment() ? '#'. $this->getFragment() : ''; $coords = $this->getX() === false ? '' : '?' . $this->getX() . ',' . $this->getY(); return "$scheme$identity$host$port$path$encoded$fragment$coords"; } function makeAbsolute($base) { if (! is_object($base)) { $base = new SimpleUrl($base); } if ($this->getHost()) { $scheme = $this->getScheme(); $host = $this->getHost(); $port = $this->getPort() ? ':' . $this->getPort() : ''; $identity = $this->getIdentity() ? $this->getIdentity() . '@' : ''; if (! $identity) { $identity = $base->getIdentity() ? $base->getIdentity() . '@' : ''; } } else { $scheme = $base->getScheme(); $host = $base->getHost(); $port = $base->getPort() ? ':' . $base->getPort() : ''; $identity = $base->getIdentity() ? $base->getIdentity() . '@' : ''; } $path = $this->normalisePath($this->extractAbsolutePath($base)); $encoded = $this->getEncodedRequest(); $fragment = $this->getFragment() ? '#'. $this->getFragment() : ''; $coords = $this->getX() === false ? '' : '?' . $this->getX() . ',' . $this->getY(); return new SimpleUrl("$scheme://$identity$host$port$path$encoded$fragment$coords"); } protected function extractAbsolutePath($base) { if ($this->getHost()) { return $this->path; } if (! $this->isRelativePath($this->path)) { return $this->path; } if ($this->path) { return $base->getBasePath() . $this->path; } return $base->getPath(); } protected function isRelativePath($path) { return (substr($path, 0, 1) != '/'); } function getIdentity() { if ($this->username && $this->password) { return $this->username . ':' . $this->password; } return false; } function normalisePath($path) { $path = preg_replace('|/\./|', '/', $path); return preg_replace('|/[^/]+/\.\./|', '/', $path); } static function getAllTopLevelDomains() { return 'com|edu|net|org|gov|mil|int|biz|info|name|pro|aero|coop|museum'; } }   if (! defined('DEFAULT_MAX_REDIRECTS')) { define('DEFAULT_MAX_REDIRECTS', 3); } if (! defined('DEFAULT_CONNECTION_TIMEOUT')) { define('DEFAULT_CONNECTION_TIMEOUT', 15); } class SimpleUserAgent { private $cookie_jar; private $cookies_enabled = true; private $authenticator; private $max_redirects = DEFAULT_MAX_REDIRECTS; private $proxy = false; private $proxy_username = false; private $proxy_password = false; private $connection_timeout = DEFAULT_CONNECTION_TIMEOUT; private $additional_headers = array(); function __construct() { $this->cookie_jar = new SimpleCookieJar(); $this->authenticator = new SimpleAuthenticator(); } function restart($date = false) { $this->cookie_jar->restartSession($date); $this->authenticator->restartSession(); } function addHeader($header) { $this->additional_headers[] = $header; } function ageCookies($interval) { $this->cookie_jar->agePrematurely($interval); } function setCookie($name, $value, $host = false, $path = '/', $expiry = false) { $this->cookie_jar->setCookie($name, $value, $host, $path, $expiry); } function getCookieValue($host, $path, $name) { return $this->cookie_jar->getCookieValue($host, $path, $name); } function getBaseCookieValue($name, $base) { if (! $base) { return null; } return $this->getCookieValue($base->getHost(), $base->getPath(), $name); } function ignoreCookies() { $this->cookies_enabled = false; } function useCookies() { $this->cookies_enabled = true; } function setConnectionTimeout($timeout) { $this->connection_timeout = $timeout; } function setMaximumRedirects($max) { $this->max_redirects = $max; } function useProxy($proxy, $username, $password) { if (! $proxy) { $this->proxy = false; return; } if ((strncmp($proxy, 'http://', 7) != 0) && (strncmp($proxy, 'https://', 8) != 0)) { $proxy = 'http://'. $proxy; } $this->proxy = new SimpleUrl($proxy); $this->proxy_username = $username; $this->proxy_password = $password; } protected function isTooManyRedirects($redirects) { return ($redirects > $this->max_redirects); } function setIdentity($host, $realm, $username, $password) { $this->authenticator->setIdentityForRealm($host, $realm, $username, $password); } function fetchResponse($url, $encoding) { if ($encoding->getMethod() != 'POST') { $url->addRequestParameters($encoding); $encoding->clear(); } $response = $this->fetchWhileRedirected($url, $encoding); if ($headers = $response->getHeaders()) { if ($headers->isChallenge()) { $this->authenticator->addRealm( $url, $headers->getAuthentication(), $headers->getRealm()); } } return $response; } protected function fetchWhileRedirected($url, $encoding) { $redirects = 0; do { $response = $this->fetch($url, $encoding); if ($response->isError()) { return $response; } $headers = $response->getHeaders(); $location = new SimpleUrl($headers->getLocation()); $url = $location->makeAbsolute($url); if ($this->cookies_enabled) { $headers->writeCookiesToJar($this->cookie_jar, $url); } if (! $headers->isRedirect()) { break; } $encoding = new SimpleGetEncoding(); } while (! $this->isTooManyRedirects(++$redirects)); return $response; } protected function fetch($url, $encoding) { $request = $this->createRequest($url, $encoding); return $request->fetch($this->connection_timeout); } protected function createRequest($url, $encoding) { $request = $this->createHttpRequest($url, $encoding); $this->addAdditionalHeaders($request); if ($this->cookies_enabled) { $request->readCookiesFromJar($this->cookie_jar, $url); } $this->authenticator->addHeaders($request, $url); return $request; } protected function createHttpRequest($url, $encoding) { return new SimpleHttpRequest($this->createRoute($url), $encoding); } protected function createRoute($url) { if ($this->proxy) { return new SimpleProxyRoute( $url, $this->proxy, $this->proxy_username, $this->proxy_password); } return new SimpleRoute($url); } protected function addAdditionalHeaders($request) { foreach ($this->additional_headers as $header) { $request->addHeaderLine($header); } } }   class SimpleCommandLineParser { private $to_property = array( 'case' => 'case', 'c' => 'case', 'test' => 'test', 't' => 'test', ); private $case = ''; private $test = ''; private $xml = false; private $help = false; private $no_skips = false; function __construct($arguments) { if (! is_array($arguments)) { return; } foreach ($arguments as $i => $argument) { if (preg_match('/^--?(test|case|t|c)=(.+)$/', $argument, $matches)) { $property = $this->to_property[$matches[1]]; $this->$property = $matches[2]; } elseif (preg_match('/^--?(test|case|t|c)$/', $argument, $matches)) { $property = $this->to_property[$matches[1]]; if (isset($arguments[$i + 1])) { $this->$property = $arguments[$i + 1]; } } elseif (preg_match('/^--?(xml|x)$/', $argument)) { $this->xml = true; } elseif (preg_match('/^--?(no-skip|no-skips|s)$/', $argument)) { $this->no_skips = true; } elseif (preg_match('/^--?(help|h)$/', $argument)) { $this->help = true; } } } function getTest() { return $this->test; } function getTestCase() { return $this->case; } function isXml() { return $this->xml; } function noSkips() { return $this->no_skips; } function help() { return $this->help && ! $this->xml; } function getHelpText() { return <<<HELP
SimpleTest command line default reporter (autorun)
Usage: php <test_file> [args...]

    -c <class>      Run only the test-case <class>
    -t <method>     Run only the test method <method>
    -s              Suppress skip messages
    -x              Return test results in XML
    -h              Display this help message

HELP
 ; } } class DefaultReporter extends SimpleReporterDecorator { function __construct() { if (SimpleReporter::inCli()) { $parser = new SimpleCommandLineParser($_SERVER['argv']); $interfaces = $parser->isXml() ? array('XmlReporter') : array('TextReporter'); if ($parser->help()) { echo $parser->getHelpText(); exit(1); } $reporter = new SelectiveReporter( SimpleTest::preferred($interfaces), $parser->getTestCase(), $parser->getTest()); if ($parser->noSkips()) { $reporter = new NoSkipsReporter($reporter); } } else { $reporter = new SelectiveReporter( SimpleTest::preferred('HtmlReporter'), @$_GET['c'], @$_GET['t']); if (@$_GET['skips'] == 'no' || @$_GET['show-skips'] == 'no') { $reporter = new NoSkipsReporter($reporter); } } parent::__construct($reporter); } }   class SimpleErrorTrappingInvoker extends SimpleInvokerDecorator { function __construct($invoker) { parent::__construct($invoker); } function invoke($method) { $queue = $this->createErrorQueue(); set_error_handler('SimpleTestErrorHandler'); parent::invoke($method); restore_error_handler(); $queue->tally(); } protected function createErrorQueue() { $context = SimpleTest::getContext(); $test = $this->getTestCase(); $queue = $context->get('SimpleErrorQueue'); $queue->setTestCase($test); return $queue; } } class SimpleErrorQueue { private $queue; private $expectation_queue; private $test; private $using_expect_style = false; function __construct() { $this->clear(); } function clear() { $this->queue = array(); $this->expectation_queue = array(); } function setTestCase($test) { $this->test = $test; } function expectError($expected, $message) { array_push($this->expectation_queue, array($expected, $message)); } function add($severity, $content, $filename, $line) { $content = str_replace('%', '%%', $content); $this->testLatestError($severity, $content, $filename, $line); } function tally() { while (list($severity, $message, $file, $line) = $this->extract()) { $severity = $this->getSeverityAsString($severity); $this->test->error($severity, $message, $file, $line); } while (list($expected, $message) = $this->extractExpectation()) { $this->test->assert($expected, false, "%s -> Expected error not caught"); } } protected function testLatestError($severity, $content, $filename, $line) { if ($expectation = $this->extractExpectation()) { list($expected, $message) = $expectation; $this->test->assert($expected, $content, sprintf( $message, "%s -> PHP error [$content] severity [" . $this->getSeverityAsString($severity) . "] in [$filename] line [$line]")); } else { $this->test->error($severity, $content, $filename, $line); } } function extract() { if (count($this->queue)) { return array_shift($this->queue); } return false; } protected function extractExpectation() { if (count($this->expectation_queue)) { return array_shift($this->expectation_queue); } return false; } static function getSeverityAsString($severity) { static $map = array( E_STRICT => 'E_STRICT', E_ERROR => 'E_ERROR', E_WARNING => 'E_WARNING', E_PARSE => 'E_PARSE', E_NOTICE => 'E_NOTICE', E_CORE_ERROR => 'E_CORE_ERROR', E_CORE_WARNING => 'E_CORE_WARNING', E_COMPILE_ERROR => 'E_COMPILE_ERROR', E_COMPILE_WARNING => 'E_COMPILE_WARNING', E_USER_ERROR => 'E_USER_ERROR', E_USER_WARNING => 'E_USER_WARNING', E_USER_NOTICE => 'E_USER_NOTICE'); if (defined('E_RECOVERABLE_ERROR')) { $map[E_RECOVERABLE_ERROR] = 'E_RECOVERABLE_ERROR'; } if (defined('E_DEPRECATED')) { $map[E_DEPRECATED] = 'E_DEPRECATED'; } return $map[$severity]; } } function SimpleTestErrorHandler($severity, $message, $filename = null, $line = null, $super_globals = null, $mask = null) { $severity = $severity & error_reporting(); if ($severity) { restore_error_handler(); if (IsNotCausedBySimpleTest($message) && IsNotTimeZoneNag($message)) { if (ini_get('log_errors')) { $label = SimpleErrorQueue::getSeverityAsString($severity); error_log("$label: $message in $filename on line $line"); } $queue = SimpleTest::getContext()->get('SimpleErrorQueue'); $queue->add($severity, $message, $filename, $line); } set_error_handler('SimpleTestErrorHandler'); } return true; } function IsNotCausedBySimpleTest($message) { return ! preg_match('/returned by reference/', $message); } function IsNotTimeZoneNag($message) { return ! preg_match('/not safe to rely .* timezone settings/', $message); }   class SimpleExceptionTrappingInvoker extends SimpleInvokerDecorator { function __construct($invoker) { parent::__construct($invoker); } function invoke($method) { $trap = SimpleTest::getContext()->get('SimpleExceptionTrap'); $trap->clear(); try { $has_thrown = false; parent::invoke($method); } catch (Exception $exception) { $has_thrown = true; if (! $trap->isExpected($this->getTestCase(), $exception)) { $this->getTestCase()->exception($exception); } $trap->clear(); } if ($message = $trap->getOutstanding()) { $this->getTestCase()->fail($message); } if ($has_thrown) { try { parent::getTestCase()->tearDown(); } catch (Exception $e) { } } } } class ExceptionExpectation extends SimpleExpectation { private $expected; function __construct($expected, $message = '%s') { $this->expected = $expected; parent::__construct($message); } function test($compare) { if (is_string($this->expected)) { return ($compare instanceof $this->expected); } if (get_class($compare) != get_class($this->expected)) { return false; } return $compare->getMessage() == $this->expected->getMessage(); } function testMessage($compare) { if (is_string($this->expected)) { return "Exception [" . $this->describeException($compare) . "] should be type [" . $this->expected . "]"; } return "Exception [" . $this->describeException($compare) . "] should match [" . $this->describeException($this->expected) . "]"; } protected function describeException($exception) { return get_class($exception) . ": " . $exception->getMessage(); } } class SimpleExceptionTrap { private $expected; private $ignored; private $message; function __construct() { $this->clear(); } function expectException($expected = false, $message = '%s') { $this->expected = $this->coerceToExpectation($expected); $this->message = $message; } function ignoreException($ignored) { $this->ignored[] = $this->coerceToExpectation($ignored); } function isExpected($test, $exception) { if ($this->expected) { return $test->assert($this->expected, $exception, $this->message); } foreach ($this->ignored as $ignored) { if ($ignored->test($exception)) { return true; } } return false; } private function coerceToExpectation($exception) { if ($exception === false) { return new AnythingExpectation(); } if (! SimpleExpectation::isExpectation($exception)) { return new ExceptionExpectation($exception); } return $exception; } function getOutstanding() { return sprintf($this->message, 'Failed to trap exception'); } function clear() { $this->expected = false; $this->message = false; $this->ignored = array(); } }   class SimpleRoute { private $url; function __construct($url) { $this->url = $url; } function getUrl() { return $this->url; } protected function getRequestLine($method) { return $method . ' ' . $this->url->getPath() . $this->url->getEncodedRequest() . ' HTTP/1.0'; } protected function getHostLine() { $line = 'Host: ' . $this->url->getHost(); if ($this->url->getPort()) { $line .= ':' . $this->url->getPort(); } return $line; } function createConnection($method, $timeout) { $default_port = ('https' == $this->url->getScheme()) ? 443 : 80; $socket = $this->createSocket( $this->url->getScheme() ? $this->url->getScheme() : 'http', $this->url->getHost(), $this->url->getPort() ? $this->url->getPort() : $default_port, $timeout); if (! $socket->isError()) { $socket->write($this->getRequestLine($method) . "\r\n"); $socket->write($this->getHostLine() . "\r\n"); $socket->write("Connection: close\r\n"); } return $socket; } protected function createSocket($scheme, $host, $port, $timeout) { if (in_array($scheme, array('file'))) { return new SimpleFileSocket($this->url); } elseif (in_array($scheme, array('https'))) { return new SimpleSecureSocket($host, $port, $timeout); } else { return new SimpleSocket($host, $port, $timeout); } } } class SimpleProxyRoute extends SimpleRoute { private $proxy; private $username; private $password; function __construct($url, $proxy, $username = false, $password = false) { parent::__construct($url); $this->proxy = $proxy; $this->username = $username; $this->password = $password; } function getRequestLine($method) { $url = $this->getUrl(); $scheme = $url->getScheme() ? $url->getScheme() : 'http'; $port = $url->getPort() ? ':' . $url->getPort() : ''; return $method . ' ' . $scheme . '://' . $url->getHost() . $port . $url->getPath() . $url->getEncodedRequest() . ' HTTP/1.0'; } function getHostLine() { $host = 'Host: ' . $this->proxy->getHost(); $port = $this->proxy->getPort() ? $this->proxy->getPort() : 8080; return "$host:$port"; } function createConnection($method, $timeout) { $socket = $this->createSocket( $this->proxy->getScheme() ? $this->proxy->getScheme() : 'http', $this->proxy->getHost(), $this->proxy->getPort() ? $this->proxy->getPort() : 8080, $timeout); if ($socket->isError()) { return $socket; } $socket->write($this->getRequestLine($method) . "\r\n"); $socket->write($this->getHostLine() . "\r\n"); if ($this->username && $this->password) { $socket->write('Proxy-Authorization: Basic ' . base64_encode($this->username . ':' . $this->password) . "\r\n"); } $socket->write("Connection: close\r\n"); return $socket; } } class SimpleHttpRequest { private $route; private $encoding; private $headers; private $cookies; function __construct($route, $encoding) { $this->route = $route; $this->encoding = $encoding; $this->headers = array(); $this->cookies = array(); } function fetch($timeout) { $socket = $this->route->createConnection($this->encoding->getMethod(), $timeout); if (! $socket->isError()) { $this->dispatchRequest($socket, $this->encoding); } return $this->createResponse($socket); } protected function dispatchRequest($socket, $encoding) { foreach ($this->headers as $header_line) { $socket->write($header_line . "\r\n"); } if (count($this->cookies) > 0) { $socket->write("Cookie: " . implode(";", $this->cookies) . "\r\n"); } $encoding->writeHeadersTo($socket); $socket->write("\r\n"); $encoding->writeTo($socket); } function addHeaderLine($header_line) { $this->headers[] = $header_line; } function readCookiesFromJar($jar, $url) { $this->cookies = $jar->selectAsPairs($url); } protected function createResponse($socket) { $response = new SimpleHttpResponse( $socket, $this->route->getUrl(), $this->encoding); $socket->close(); return $response; } } class SimpleHttpHeaders { private $raw_headers; private $response_code; private $http_version; private $mime_type; private $location; private $cookies; private $authentication; private $realm; function __construct($headers) { $this->raw_headers = $headers; $this->response_code = false; $this->http_version = false; $this->mime_type = ''; $this->location = false; $this->cookies = array(); $this->authentication = false; $this->realm = false; foreach (explode("\r\n", $headers) as $header_line) { $this->parseHeaderLine($header_line); } } function getHttpVersion() { return $this->http_version; } function getRaw() { return $this->raw_headers; } function getResponseCode() { return (integer)$this->response_code; } function getLocation() { return $this->location; } function isRedirect() { return in_array($this->response_code, array(301, 302, 303, 307)) && (boolean)$this->getLocation(); } function isChallenge() { return ($this->response_code == 401) && (boolean)$this->authentication && (boolean)$this->realm; } function getMimeType() { return $this->mime_type; } function getAuthentication() { return $this->authentication; } function getRealm() { return $this->realm; } function writeCookiesToJar($jar, $url) { foreach ($this->cookies as $cookie) { $jar->setCookie( $cookie->getName(), $cookie->getValue(), $url->getHost(), $cookie->getPath(), $cookie->getExpiry()); } } protected function parseHeaderLine($header_line) { if (preg_match('/HTTP\/(\d+\.\d+)\s+(\d+)/i', $header_line, $matches)) { $this->http_version = $matches[1]; $this->response_code = $matches[2]; } if (preg_match('/Content-type:\s*(.*)/i', $header_line, $matches)) { $this->mime_type = trim($matches[1]); } if (preg_match('/Location:\s*(.*)/i', $header_line, $matches)) { $this->location = trim($matches[1]); } if (preg_match('/Set-cookie:(.*)/i', $header_line, $matches)) { $this->cookies[] = $this->parseCookie($matches[1]); } if (preg_match('/WWW-Authenticate:\s+(\S+)\s+realm=\"(.*?)\"/i', $header_line, $matches)) { $this->authentication = $matches[1]; $this->realm = trim($matches[2]); } } protected function parseCookie($cookie_line) { $parts = explode(";", $cookie_line); $cookie = array(); preg_match('/\s*(.*?)\s*=(.*)/', array_shift($parts), $cookie); foreach ($parts as $part) { if (preg_match('/\s*(.*?)\s*=(.*)/', $part, $matches)) { $cookie[$matches[1]] = trim($matches[2]); } } return new SimpleCookie( $cookie[1], trim($cookie[2]), isset($cookie["path"]) ? $cookie["path"] : "", isset($cookie["expires"]) ? $cookie["expires"] : false); } } class SimpleHttpResponse extends SimpleStickyError { private $url; private $encoding; private $sent; private $content; private $headers; function __construct($socket, $url, $encoding) { parent::__construct(); $this->url = $url; $this->encoding = $encoding; $this->sent = $socket->getSent(); $this->content = false; $raw = $this->readAll($socket); if ($socket->isError()) { $this->setError('Error reading socket [' . $socket->getError() . ']'); return; } $this->parse($raw); } protected function parse($raw) { if (! $raw) { $this->setError('Nothing fetched'); $this->headers = new SimpleHttpHeaders(''); } elseif ('file' == $this->url->getScheme()) { $this->headers = new SimpleHttpHeaders(''); $this->content = $raw; } elseif (! strstr($raw, "\r\n\r\n")) { $this->setError('Could not split headers from content'); $this->headers = new SimpleHttpHeaders($raw); } else { list($headers, $this->content) = explode("\r\n\r\n", $raw, 2); $this->headers = new SimpleHttpHeaders($headers); } } function getMethod() { return $this->encoding->getMethod(); } function getUrl() { return $this->url; } function getRequestData() { return $this->encoding; } function getSent() { return $this->sent; } function getContent() { return $this->content; } function getHeaders() { return $this->headers; } function getNewCookies() { return $this->headers->getNewCookies(); } protected function readAll($socket) { $all = ''; while (! $this->isLastPacket($next = $socket->read())) { $all .= $next; } return $all; } protected function isLastPacket($packet) { if (is_string($packet)) { return $packet === ''; } return ! $packet; } }   if (! defined('MOCK_ANYTHING')) { define('MOCK_ANYTHING', '*'); } class ParametersExpectation extends SimpleExpectation { private $expected; function __construct($expected = false, $message = '%s') { parent::__construct($message); $this->expected = $expected; } function test($parameters) { if (! is_array($this->expected)) { return true; } if (count($this->expected) != count($parameters)) { return false; } for ($i = 0; $i < count($this->expected); $i++) { if (! $this->testParameter($parameters[$i], $this->expected[$i])) { return false; } } return true; } protected function testParameter($parameter, $expected) { $comparison = $this->coerceToExpectation($expected); return $comparison->test($parameter); } function testMessage($parameters) { if ($this->test($parameters)) { return "Expectation of " . count($this->expected) . " arguments of [" . $this->renderArguments($this->expected) . "] is correct"; } else { return $this->describeDifference($this->expected, $parameters); } } protected function describeDifference($expected, $parameters) { if (count($expected) != count($parameters)) { return "Expected " . count($expected) . " arguments of [" . $this->renderArguments($expected) . "] but got " . count($parameters) . " arguments of [" . $this->renderArguments($parameters) . "]"; } $messages = array(); for ($i = 0; $i < count($expected); $i++) { $comparison = $this->coerceToExpectation($expected[$i]); if (! $comparison->test($parameters[$i])) { $messages[] = "parameter " . ($i + 1) . " with [" . $comparison->overlayMessage($parameters[$i], $this->getDumper()) . "]"; } } return "Parameter expectation differs at " . implode(" and ", $messages); } protected function coerceToExpectation($expected) { if (SimpleExpectation::isExpectation($expected)) { return $expected; } return new IdenticalExpectation($expected); } protected function renderArguments($args) { $descriptions = array(); if (is_array($args)) { foreach ($args as $arg) { $dumper = new SimpleDumper(); $descriptions[] = $dumper->describeValue($arg); } } return implode(', ', $descriptions); } } class CallCountExpectation extends SimpleExpectation { private $method; private $count; function __construct($method, $count, $message = '%s') { $this->method = $method; $this->count = $count; parent::__construct($message); } function test($compare) { return ($this->count == $compare); } function testMessage($compare) { return 'Expected call count for [' . $this->method . '] was [' . $this->count . '] got [' . $compare . ']'; } } class MinimumCallCountExpectation extends SimpleExpectation { private $method; private $count; function __construct($method, $count, $message = '%s') { $this->method = $method; $this->count = $count; parent::__construct($message); } function test($compare) { return ($this->count <= $compare); } function testMessage($compare) { return 'Minimum call count for [' . $this->method . '] was [' . $this->count . '] got [' . $compare . ']'; } } class MaximumCallCountExpectation extends SimpleExpectation { private $method; private $count; function __construct($method, $count, $message = '%s') { $this->method = $method; $this->count = $count; parent::__construct($message); } function test($compare) { return ($this->count >= $compare); } function testMessage($compare) { return 'Maximum call count for [' . $this->method . '] was [' . $this->count . '] got [' . $compare . ']'; } } class SimpleSignatureMap { private $map; function __construct() { $this->map = array(); } function add($parameters, $action) { $place = count($this->map); $this->map[$place] = array(); $this->map[$place]['params'] = new ParametersExpectation($parameters); $this->map[$place]['content'] = $action; } function findFirstAction($parameters) { $slot = $this->findFirstSlot($parameters); if (isset($slot) && isset($slot['content'])) { return $slot['content']; } $null = null; return $null; } function isMatch($parameters) { return ($this->findFirstSlot($parameters) != null); } function test($test, $parameters, $message) { } function findFirstSlot($parameters) { $count = count($this->map); for ($i = 0; $i < $count; $i++) { if ($this->map[$i]["params"]->test($parameters)) { return $this->map[$i]; } } $null = null; return $null; } } class SimpleCallSchedule { private $wildcard = MOCK_ANYTHING; private $always; private $at; function __construct() { $this->always = array(); $this->at = array(); } function register($method, $args, $action) { $args = $this->replaceWildcards($args); $method = strtolower($method); if (! isset($this->always[$method])) { $this->always[$method] = new SimpleSignatureMap(); } $this->always[$method]->add($args, $action); } function registerAt($step, $method, $args, $action) { $args = $this->replaceWildcards($args); $method = strtolower($method); if (! isset($this->at[$method])) { $this->at[$method] = array(); } if (! isset($this->at[$method][$step])) { $this->at[$method][$step] = new SimpleSignatureMap(); } $this->at[$method][$step]->add($args, $action); } function expectArguments($method, $args, $message) { $args = $this->replaceWildcards($args); $message .= Mock::getExpectationLine(); $this->expected_args[strtolower($method)] = new ParametersExpectation($args, $message); } function respond($step, $method, $args) { $method = strtolower($method); if (isset($this->at[$method][$step])) { if ($this->at[$method][$step]->isMatch($args)) { $action = $this->at[$method][$step]->findFirstAction($args); if (isset($action)) { return $action->act(); } } } if (isset($this->always[$method])) { $action = $this->always[$method]->findFirstAction($args); if (isset($action)) { return $action->act(); } } $null = null; return $null; } protected function replaceWildcards($args) { if ($args === false) { return false; } for ($i = 0; $i < count($args); $i++) { if ($args[$i] === $this->wildcard) { $args[$i] = new AnythingExpectation(); } } return $args; } } class SimpleReturn { private $value; function __construct($value) { $this->value = $value; } function act() { return $this->value; } } class SimpleByReference { private $reference; function __construct($reference) { $this->reference = $reference; } function act() { return $this->reference; } } class SimpleByValue { private $value; function __construct($value) { $this->value = $value; } function act() { $dummy = $this->value; return $dummy; } } class SimpleThrower { private $exception; function __construct($exception) { $this->exception = $exception; } function act() { throw $this->exception; } } class SimpleErrorThrower { private $error; private $severity; function __construct($error, $severity) { $this->error = $error; $this->severity = $severity; } function act() { trigger_error($this->error, $this->severity); $null = null; return $null; } } class SimpleMock { private $actions; private $expectations; private $wildcard = MOCK_ANYTHING; private $is_strict = true; private $call_counts; private $expected_counts; private $max_counts; private $expected_args; private $expected_args_at; function SimpleMock() { $this->actions = new SimpleCallSchedule(); $this->expectations = new SimpleCallSchedule(); $this->call_counts = array(); $this->expected_counts = array(); $this->max_counts = array(); $this->expected_args = array(); $this->expected_args_at = array(); $this->getCurrentTestCase()->tell($this); } function disableExpectationNameChecks() { $this->is_strict = false; } protected function getCurrentTestCase() { return SimpleTest::getContext()->getTest(); } protected function checkArgumentsIsArray($args, $task) { if (! is_array($args)) { trigger_error( "Cannot $task as \$args parameter is not an array", E_USER_ERROR); } } protected function dieOnNoMethod($method, $task) { if ($this->is_strict && ! method_exists($this, $method)) { trigger_error( "Cannot $task as no ${method}() in class " . get_class($this), E_USER_ERROR); } } function replaceWildcards($args) { if ($args === false) { return false; } for ($i = 0; $i < count($args); $i++) { if ($args[$i] === $this->wildcard) { $args[$i] = new AnythingExpectation(); } } return $args; } protected function addCall($method, $args) { if (! isset($this->call_counts[$method])) { $this->call_counts[$method] = 0; } $this->call_counts[$method]++; } function getCallCount($method) { $this->dieOnNoMethod($method, "get call count"); $method = strtolower($method); if (! isset($this->call_counts[$method])) { return 0; } return $this->call_counts[$method]; } function returns($method, $value, $args = false) { $this->dieOnNoMethod($method, "set return"); $this->actions->register($method, $args, new SimpleReturn($value)); } function returnsAt($timing, $method, $value, $args = false) { $this->dieOnNoMethod($method, "set return value sequence"); $this->actions->registerAt($timing, $method, $args, new SimpleReturn($value)); } function returnsByValue($method, $value, $args = false) { $this->dieOnNoMethod($method, "set return value"); $this->actions->register($method, $args, new SimpleByValue($value)); } function setReturnValue($method, $value, $args = false) { $this->returnsByValue($method, $value, $args); } function returnsByValueAt($timing, $method, $value, $args = false) { $this->dieOnNoMethod($method, "set return value sequence"); $this->actions->registerAt($timing, $method, $args, new SimpleByValue($value)); } function setReturnValueAt($timing, $method, $value, $args = false) { $this->returnsByValueAt($timing, $method, $value, $args); } function returnsByReference($method, $reference, $args = false) { $this->dieOnNoMethod($method, "set return reference"); $this->actions->register($method, $args, new SimpleByReference($reference)); } function setReturnReference($method, $reference, $args = false) { $this->returnsByReference($method, $reference, $args); } function returnsByReferenceAt($timing, $method, $reference, $args = false) { $this->dieOnNoMethod($method, "set return reference sequence"); $this->actions->registerAt($timing, $method, $args, new SimpleByReference($reference)); } function setReturnReferenceAt($timing, $method, $reference, $args = false) { $this->returnsByReferenceAt($timing, $method, $reference, $args); } function expect($method, $args, $message = '%s') { $this->dieOnNoMethod($method, 'set expected arguments'); $this->checkArgumentsIsArray($args, 'set expected arguments'); $this->expectations->expectArguments($method, $args, $message); $args = $this->replaceWildcards($args); $message .= Mock::getExpectationLine(); $this->expected_args[strtolower($method)] = new ParametersExpectation($args, $message); } function expectAt($timing, $method, $args, $message = '%s') { $this->dieOnNoMethod($method, 'set expected arguments at time'); $this->checkArgumentsIsArray($args, 'set expected arguments at time'); $args = $this->replaceWildcards($args); if (! isset($this->expected_args_at[$timing])) { $this->expected_args_at[$timing] = array(); } $method = strtolower($method); $message .= Mock::getExpectationLine(); $this->expected_args_at[$timing][$method] = new ParametersExpectation($args, $message); } function expectCallCount($method, $count, $message = '%s') { $this->dieOnNoMethod($method, 'set expected call count'); $message .= Mock::getExpectationLine(); $this->expected_counts[strtolower($method)] = new CallCountExpectation($method, $count, $message); } function expectMaximumCallCount($method, $count, $message = '%s') { $this->dieOnNoMethod($method, 'set maximum call count'); $message .= Mock::getExpectationLine(); $this->max_counts[strtolower($method)] = new MaximumCallCountExpectation($method, $count, $message); } function expectMinimumCallCount($method, $count, $message = '%s') { $this->dieOnNoMethod($method, 'set minimum call count'); $message .= Mock::getExpectationLine(); $this->expected_counts[strtolower($method)] = new MinimumCallCountExpectation($method, $count, $message); } function expectNever($method, $message = '%s') { $this->expectMaximumCallCount($method, 0, $message); } function expectOnce($method, $args = false, $message = '%s') { $this->expectCallCount($method, 1, $message); if ($args !== false) { $this->expect($method, $args, $message); } } function expectAtLeastOnce($method, $args = false, $message = '%s') { $this->expectMinimumCallCount($method, 1, $message); if ($args !== false) { $this->expect($method, $args, $message); } } function throwOn($method, $exception = false, $args = false) { $this->dieOnNoMethod($method, "throw on"); $this->actions->register($method, $args, new SimpleThrower($exception ? $exception : new Exception())); } function throwAt($timing, $method, $exception = false, $args = false) { $this->dieOnNoMethod($method, "throw at"); $this->actions->registerAt($timing, $method, $args, new SimpleThrower($exception ? $exception : new Exception())); } function errorOn($method, $error = 'A mock error', $args = false, $severity = E_USER_ERROR) { $this->dieOnNoMethod($method, "error on"); $this->actions->register($method, $args, new SimpleErrorThrower($error, $severity)); } function errorAt($timing, $method, $error = 'A mock error', $args = false, $severity = E_USER_ERROR) { $this->dieOnNoMethod($method, "error at"); $this->actions->registerAt($timing, $method, $args, new SimpleErrorThrower($error, $severity)); } function atTestEnd($test_method, $test) { foreach ($this->expected_counts as $method => $expectation) { $test->assert($expectation, $this->getCallCount($method)); } foreach ($this->max_counts as $method => $expectation) { if ($expectation->test($this->getCallCount($method))) { $test->assert($expectation, $this->getCallCount($method)); } } } function invoke($method, $args) { $method = strtolower($method); $step = $this->getCallCount($method); $this->addCall($method, $args); $this->checkExpectations($method, $args, $step); $was = $this->disableEStrict(); try { $result = $this->emulateCall($method, $args, $step); } catch (Exception $e) { $this->restoreEStrict($was); throw $e; } $this->restoreEStrict($was); return $result; } protected function emulateCall($method, $args, $step) { return $this->actions->respond($step, $method, $args); } protected function checkExpectations($method, $args, $timing) { $test = $this->getCurrentTestCase(); if (isset($this->max_counts[$method])) { if (! $this->max_counts[$method]->test($timing + 1)) { $test->assert($this->max_counts[$method], $timing + 1); } } if (isset($this->expected_args_at[$timing][$method])) { $test->assert( $this->expected_args_at[$timing][$method], $args, "Mock method [$method] at [$timing] -> %s"); } elseif (isset($this->expected_args[$method])) { $test->assert( $this->expected_args[$method], $args, "Mock method [$method] -> %s"); } } private function disableEStrict() { $was = error_reporting(); error_reporting($was & ~E_STRICT); return $was; } private function restoreEStrict($was) { error_reporting($was); } } class Mock { function __construct() { trigger_error('Mock factory methods are static.'); } static function generate($class, $mock_class = false, $methods = false) { $generator = new MockGenerator($class, $mock_class); return @$generator->generateSubclass($methods); } static function generatePartial($class, $mock_class, $methods) { $generator = new MockGenerator($class, $mock_class); return @$generator->generatePartial($methods); } static function getExpectationLine() { $trace = new SimpleStackTrace(array('expect')); return $trace->traceMethod(); } } class MockGenerator { private $class; private $mock_class; private $mock_base; private $reflection; function __construct($class, $mock_class) { $this->class = $class; $this->mock_class = $mock_class; if (! $this->mock_class) { $this->mock_class = 'Mock' . $this->class; } $this->mock_base = SimpleTest::getMockBaseClass(); $this->reflection = new SimpleReflection($this->class); } function generate($methods) { if (! $this->reflection->classOrInterfaceExists()) { return false; } $mock_reflection = new SimpleReflection($this->mock_class); if ($mock_reflection->classExistsSansAutoload()) { return false; } $code = $this->createClassCode($methods ? $methods : array()); return eval("$code return \$code;"); } function generateSubclass($methods) { if (! $this->reflection->classOrInterfaceExists()) { return false; } $mock_reflection = new SimpleReflection($this->mock_class); if ($mock_reflection->classExistsSansAutoload()) { return false; } if ($this->reflection->isInterface() || $this->reflection->hasFinal()) { $code = $this->createClassCode($methods ? $methods : array()); return eval("$code return \$code;"); } else { $code = $this->createSubclassCode($methods ? $methods : array()); return eval("$code return \$code;"); } } function generatePartial($methods) { if (! $this->reflection->classExists($this->class)) { return false; } $mock_reflection = new SimpleReflection($this->mock_class); if ($mock_reflection->classExistsSansAutoload()) { trigger_error('Partial mock class [' . $this->mock_class . '] already exists'); return false; } $code = $this->extendClassCode($methods); return eval("$code return \$code;"); } protected function createClassCode($methods) { $implements = ''; $interfaces = $this->reflection->getInterfaces(); if (function_exists('spl_classes')) { $interfaces = array_diff($interfaces, array('Traversable')); } if (count($interfaces) > 0) { $implements = 'implements ' . implode(', ', $interfaces); } $code = "class " . $this->mock_class . " extends " . $this->mock_base . " $implements {\n"; $code .= "    function " . $this->mock_class . "() {\n"; $code .= "        \$this->" . $this->mock_base . "();\n"; $code .= "    }\n"; if (in_array('__construct', $this->reflection->getMethods())) { $code .= "    function __construct() {\n"; $code .= "        \$this->" . $this->mock_base . "();\n"; $code .= "    }\n"; } $code .= $this->createHandlerCode($methods); $code .= "}\n"; return $code; } protected function createSubclassCode($methods) { $code = "class " . $this->mock_class . " extends " . $this->class . " {\n"; $code .= "    public \$mock;\n"; $code .= $this->addMethodList(array_merge($methods, $this->reflection->getMethods())); $code .= "\n"; $code .= "    function " . $this->mock_class . "() {\n"; $code .= "        \$this->mock = new " . $this->mock_base . "();\n"; $code .= "        \$this->mock->disableExpectationNameChecks();\n"; $code .= "    }\n"; $code .= $this->chainMockReturns(); $code .= $this->chainMockExpectations(); $code .= $this->chainThrowMethods(); $code .= $this->overrideMethods($this->reflection->getMethods()); $code .= $this->createNewMethodCode($methods); $code .= "}\n"; return $code; } protected function extendClassCode($methods) { $code = "class " . $this->mock_class . " extends " . $this->class . " {\n"; $code .= "    protected \$mock;\n"; $code .= $this->addMethodList($methods); $code .= "\n"; $code .= "    function " . $this->mock_class . "() {\n"; $code .= "        \$this->mock = new " . $this->mock_base . "();\n"; $code .= "        \$this->mock->disableExpectationNameChecks();\n"; $code .= "    }\n"; $code .= $this->chainMockReturns(); $code .= $this->chainMockExpectations(); $code .= $this->chainThrowMethods(); $code .= $this->overrideMethods($methods); $code .= "}\n"; return $code; } protected function createHandlerCode($methods) { $code = ''; $methods = array_merge($methods, $this->reflection->getMethods()); foreach ($methods as $method) { if ($this->isConstructor($method)) { continue; } $mock_reflection = new SimpleReflection($this->mock_base); if (in_array($method, $mock_reflection->getMethods())) { continue; } $code .= "    " . $this->reflection->getSignature($method) . " {\n"; $code .= "        \$args = func_get_args();\n"; $code .= "        \$result = \$this->invoke(\"$method\", \$args);\n"; $code .= "        return \$result;\n"; $code .= "    }\n"; } return $code; } protected function createNewMethodCode($methods) { $code = ''; foreach ($methods as $method) { if ($this->isConstructor($method)) { continue; } $mock_reflection = new SimpleReflection($this->mock_base); if (in_array($method, $mock_reflection->getMethods())) { continue; } $code .= "    " . $this->reflection->getSignature($method) . " {\n"; $code .= "        \$args = func_get_args();\n"; $code .= "        \$result = \$this->mock->invoke(\"$method\", \$args);\n"; $code .= "        return \$result;\n"; $code .= "    }\n"; } return $code; } protected function isConstructor($method) { return in_array( strtolower($method), array('__construct', '__destruct')); } protected function addMethodList($methods) { return "    protected \$mocked_methods = array('" . implode("', '", array_map('strtolower', $methods)) . "');\n"; } protected function bailOutIfNotMocked($alias) { $code = "        if (! in_array(strtolower($alias), \$this->mocked_methods)) {\n"; $code .= "            trigger_error(\"Method [$alias] is not mocked\");\n"; $code .= "            \$null = null;\n"; $code .= "            return \$null;\n"; $code .= "        }\n"; return $code; } protected function chainMockReturns() { $code = "    function returns(\$method, \$value, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->returns(\$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function returnsAt(\$timing, \$method, \$value, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->returnsAt(\$timing, \$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function returnsByValue(\$method, \$value, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnValue(\$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function returnsByValueAt(\$timing, \$method, \$value, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnValueAt(\$timing, \$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function returnsByReference(\$method, &\$ref, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnReference(\$method, \$ref, \$args);\n"; $code .= "    }\n"; $code .= "    function returnsByReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnReferenceAt(\$timing, \$method, \$ref, \$args);\n"; $code .= "    }\n"; $code .= "    function setReturnValue(\$method, \$value, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnValue(\$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function setReturnValueAt(\$timing, \$method, \$value, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnValueAt(\$timing, \$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function setReturnReference(\$method, &\$ref, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnReference(\$method, \$ref, \$args);\n"; $code .= "    }\n"; $code .= "    function setReturnReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->setReturnReferenceAt(\$timing, \$method, \$ref, \$args);\n"; $code .= "    }\n"; return $code; } protected function chainMockExpectations() { $code = "    function expect(\$method, \$args = false, \$msg = '%s') {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expect(\$method, \$args, \$msg);\n"; $code .= "    }\n"; $code .= "    function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expectAt(\$timing, \$method, \$args, \$msg);\n"; $code .= "    }\n"; $code .= "    function expectCallCount(\$method, \$count) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expectCallCount(\$method, \$count, \$msg = '%s');\n"; $code .= "    }\n"; $code .= "    function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n"; $code .= "    }\n"; $code .= "    function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n"; $code .= "    }\n"; $code .= "    function expectNever(\$method) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expectNever(\$method);\n"; $code .= "    }\n"; $code .= "    function expectOnce(\$method, \$args = false, \$msg = '%s') {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expectOnce(\$method, \$args, \$msg);\n"; $code .= "    }\n"; $code .= "    function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->expectAtLeastOnce(\$method, \$args, \$msg);\n"; $code .= "    }\n"; return $code; } protected function chainThrowMethods() { $code = "    function throwOn(\$method, \$exception = false, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->throwOn(\$method, \$exception, \$args);\n"; $code .= "    }\n"; $code .= "    function throwAt(\$timing, \$method, \$exception = false, \$args = false) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->throwAt(\$timing, \$method, \$exception, \$args);\n"; $code .= "    }\n"; $code .= "    function errorOn(\$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->errorOn(\$method, \$error, \$args, \$severity);\n"; $code .= "    }\n"; $code .= "    function errorAt(\$timing, \$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n"; $code .= $this->bailOutIfNotMocked("\$method"); $code .= "        \$this->mock->errorAt(\$timing, \$method, \$error, \$args, \$severity);\n"; $code .= "    }\n"; return $code; } protected function overrideMethods($methods) { $code = ""; foreach ($methods as $method) { if ($this->isConstructor($method)) { continue; } $code .= "    " . $this->reflection->getSignature($method) . " {\n"; $code .= "        \$args = func_get_args();\n"; $code .= "        \$result = \$this->mock->invoke(\"$method\", \$args);\n"; $code .= "        return \$result;\n"; $code .= "    }\n"; } return $code; } }   abstract class SimpleResult { public $time; public $breadcrumb; public $message; function __construct($breadcrumb, $message) { list($this->time, $this->breadcrumb, $this->message) = array(time(), $breadcrumb, $message); } } class SimpleResultOfPass extends SimpleResult { } class SimpleResultOfFail extends SimpleResult { } class SimpleResultOfException extends SimpleResult { } class Recorder extends SimpleReporterDecorator { public $results = array(); function paintPass($message) { parent::paintPass($message); $this->results[] = new SimpleResultOfPass(parent::getTestList(), $message); } function paintFail($message) { parent::paintFail($message); $this->results[] = new SimpleResultOfFail(parent::getTestList(), $message); } function paintException($message) { parent::paintException($message); $this->results[] = new SimpleResultOfException(parent::getTestList(), $message); } }   class HtmlReporter extends SimpleReporter { private $character_set; function __construct($character_set = 'ISO-8859-1') { parent::__construct(); $this->character_set = $character_set; } function paintHeader($test_name) { $this->sendNoCacheHeaders(); print "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">"; print "<html>\n<head>\n<title>$test_name</title>\n"; print "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=" . $this->character_set . "\">\n"; print "<style type=\"text/css\">\n"; print $this->getCss() . "\n"; print "</style>\n"; print "</head>\n<body>\n"; print "<h1>$test_name</h1>\n"; flush(); } static function sendNoCacheHeaders() { if (! headers_sent()) { header("Expires: Mon, 26 Jul 1997 05:00:00 GMT"); header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT"); header("Cache-Control: no-store, no-cache, must-revalidate"); header("Cache-Control: post-check=0, pre-check=0", false); header("Pragma: no-cache"); } } protected function getCss() { return ".fail { background-color: inherit; color: red; }" . ".pass { background-color: inherit; color: green; }" . " pre { background-color: lightgray; color: inherit; }"; } function paintFooter($test_name) { $colour = ($this->getFailCount() + $this->getExceptionCount() > 0 ? "red" : "green"); print "<div style=\""; print "padding: 8px; margin-top: 1em; background-color: $colour; color: white;"; print "\">"; print $this->getTestCaseProgress() . "/" . $this->getTestCaseCount(); print " test cases complete:\n"; print "<strong>" . $this->getPassCount() . "</strong> passes, "; print "<strong>" . $this->getFailCount() . "</strong> fails and "; print "<strong>" . $this->getExceptionCount() . "</strong> exceptions."; print "</div>\n"; print "</body>\n</html>\n"; } function paintFail($message) { parent::paintFail($message); print "<span class=\"fail\">Fail</span>: "; $breadcrumb = $this->getTestList(); array_shift($breadcrumb); print implode(" -&gt; ", $breadcrumb); print " -&gt; " . $this->htmlEntities($message) . "<br />\n"; } function paintError($message) { parent::paintError($message); print "<span class=\"fail\">Exception</span>: "; $breadcrumb = $this->getTestList(); array_shift($breadcrumb); print implode(" -&gt; ", $breadcrumb); print " -&gt; <strong>" . $this->htmlEntities($message) . "</strong><br />\n"; } function paintException($exception) { parent::paintException($exception); print "<span class=\"fail\">Exception</span>: "; $breadcrumb = $this->getTestList(); array_shift($breadcrumb); print implode(" -&gt; ", $breadcrumb); $message = 'Unexpected exception of type [' . get_class($exception) . '] with message ['. $exception->getMessage() . '] in ['. $exception->getFile() . ' line ' . $exception->getLine() . ']'; print " -&gt; <strong>" . $this->htmlEntities($message) . "</strong><br />\n"; } function paintSkip($message) { parent::paintSkip($message); print "<span class=\"pass\">Skipped</span>: "; $breadcrumb = $this->getTestList(); array_shift($breadcrumb); print implode(" -&gt; ", $breadcrumb); print " -&gt; " . $this->htmlEntities($message) . "<br />\n"; } function paintFormattedMessage($message) { print '<pre>' . $this->htmlEntities($message) . '</pre>'; } protected function htmlEntities($message) { return htmlentities($message, ENT_COMPAT, $this->character_set); } } class TextReporter extends SimpleReporter { function __construct() { parent::__construct(); } function paintHeader($test_name) { if (! SimpleReporter::inCli()) { header('Content-type: text/plain'); } print "$test_name\n"; flush(); } function paintFooter($test_name) { if ($this->getFailCount() + $this->getExceptionCount() == 0) { print "OK\n"; } else { print "FAILURES!!!\n"; } print "Test cases run: " . $this->getTestCaseProgress() . "/" . $this->getTestCaseCount() . ", Passes: " . $this->getPassCount() . ", Failures: " . $this->getFailCount() . ", Exceptions: " . $this->getExceptionCount() . "\n"; } function paintFail($message) { parent::paintFail($message); print $this->getFailCount() . ") $message\n"; $breadcrumb = $this->getTestList(); array_shift($breadcrumb); print "\tin " . implode("\n\tin ", array_reverse($breadcrumb)); print "\n"; } function paintError($message) { parent::paintError($message); print "Exception " . $this->getExceptionCount() . "!\n$message\n"; $breadcrumb = $this->getTestList(); array_shift($breadcrumb); print "\tin " . implode("\n\tin ", array_reverse($breadcrumb)); print "\n"; } function paintException($exception) { parent::paintException($exception); $message = 'Unexpected exception of type [' . get_class($exception) . '] with message ['. $exception->getMessage() . '] in ['. $exception->getFile() . ' line ' . $exception->getLine() . ']'; print "Exception " . $this->getExceptionCount() . "!\n$message\n"; $breadcrumb = $this->getTestList(); array_shift($breadcrumb); print "\tin " . implode("\n\tin ", array_reverse($breadcrumb)); print "\n"; } function paintSkip($message) { parent::paintSkip($message); print "Skip: $message\n"; } function paintFormattedMessage($message) { print "$message\n"; flush(); } } class SelectiveReporter extends SimpleReporterDecorator { private $just_this_case = false; private $just_this_test = false; private $on; function __construct($reporter, $just_this_case = false, $just_this_test = false) { if (isset($just_this_case) && $just_this_case) { $this->just_this_case = strtolower($just_this_case); $this->off(); } else { $this->on(); } if (isset($just_this_test) && $just_this_test) { $this->just_this_test = strtolower($just_this_test); } parent::__construct($reporter); } protected function matchesTestCase($test_case) { return $this->just_this_case == strtolower($test_case); } protected function shouldRunTest($test_case, $method) { if ($this->isOn() || $this->matchesTestCase($test_case)) { if ($this->just_this_test) { return $this->just_this_test == strtolower($method); } else { return true; } } return false; } protected function on() { $this->on = true; } protected function off() { $this->on = false; } protected function isOn() { return $this->on; } function shouldInvoke($test_case, $method) { if ($this->shouldRunTest($test_case, $method)) { return $this->reporter->shouldInvoke($test_case, $method); } return false; } function paintGroupStart($test_case, $size) { if ($this->just_this_case && $this->matchesTestCase($test_case)) { $this->on(); } $this->reporter->paintGroupStart($test_case, $size); } function paintGroupEnd($test_case) { $this->reporter->paintGroupEnd($test_case); if ($this->just_this_case && $this->matchesTestCase($test_case)) { $this->off(); } } } class NoSkipsReporter extends SimpleReporterDecorator { function paintSkip($message) { } }   class SimpleShell { private $output; function __construct() { $this->output = false; } function execute($command) { $this->output = false; exec($command, $this->output, $ret); return $ret; } function getOutput() { return implode("\n", $this->output); } function getOutputAsList() { return $this->output; } } class ShellTestCase extends SimpleTestCase { private $current_shell; private $last_status; private $last_command; function __construct($label = false) { parent::__construct($label); $this->current_shell = $this->createShell(); $this->last_status = false; $this->last_command = ''; } function execute($command) { $shell = $this->getShell(); $this->last_status = $shell->execute($command); $this->last_command = $command; return ($this->last_status === 0); } function dumpOutput() { $this->dump($this->getOutput()); } function getOutput() { $shell = $this->getShell(); return $shell->getOutput(); } function getOutputAsList() { $shell = $this->getShell(); return $shell->getOutputAsList(); } function assertTrue($result, $message = false) { return $this->assert(new TrueExpectation(), $result, $message); } function assertFalse($result, $message = '%s') { return $this->assert(new FalseExpectation(), $result, $message); } function assertEqual($first, $second, $message = "%s") { return $this->assert( new EqualExpectation($first), $second, $message); } function assertNotEqual($first, $second, $message = "%s") { return $this->assert( new NotEqualExpectation($first), $second, $message); } function assertExitCode($status, $message = "%s") { $message = sprintf($message, "Expected status code of [$status] from [" . $this->last_command . "], but got [" . $this->last_status . "]"); return $this->assertTrue($status === $this->last_status, $message); } function assertOutput($expected, $message = "%s") { $shell = $this->getShell(); return $this->assert( new EqualExpectation($expected), $shell->getOutput(), $message); } function assertOutputPattern($pattern, $message = "%s") { $shell = $this->getShell(); return $this->assert( new PatternExpectation($pattern), $shell->getOutput(), $message); } function assertNoOutputPattern($pattern, $message = "%s") { $shell = $this->getShell(); return $this->assert( new NoPatternExpectation($pattern), $shell->getOutput(), $message); } function assertFileExists($path, $message = "%s") { $message = sprintf($message, "File [$path] should exist"); return $this->assertTrue(file_exists($path), $message); } function assertFileNotExists($path, $message = "%s") { $message = sprintf($message, "File [$path] should not exist"); return $this->assertFalse(file_exists($path), $message); } function assertFilePattern($pattern, $path, $message = "%s") { return $this->assert( new PatternExpectation($pattern), implode('', file($path)), $message); } function assertNoFilePattern($pattern, $path, $message = "%s") { return $this->assert( new NoPatternExpectation($pattern), implode('', file($path)), $message); } protected function getShell() { return $this->current_shell; } protected function createShell() { return new SimpleShell(); } }   class UnitTestCase extends SimpleTestCase { function __construct($label = false) { if (! $label) { $label = get_class($this); } parent::__construct($label); } function assertTrue($result, $message = '%s') { return $this->assert(new TrueExpectation(), $result, $message); } function assertFalse($result, $message = '%s') { return $this->assert(new FalseExpectation(), $result, $message); } function assertNull($value, $message = '%s') { $dumper = new SimpleDumper(); $message = sprintf( $message, '[' . $dumper->describeValue($value) . '] should be null'); return $this->assertTrue(! isset($value), $message); } function assertNotNull($value, $message = '%s') { $dumper = new SimpleDumper(); $message = sprintf( $message, '[' . $dumper->describeValue($value) . '] should not be null'); return $this->assertTrue(isset($value), $message); } function assertIsA($object, $type, $message = '%s') { return $this->assert( new IsAExpectation($type), $object, $message); } function assertNotA($object, $type, $message = '%s') { return $this->assert( new NotAExpectation($type), $object, $message); } function assertEqual($first, $second, $message = '%s') { return $this->assert( new EqualExpectation($first), $second, $message); } function assertNotEqual($first, $second, $message = '%s') { return $this->assert( new NotEqualExpectation($first), $second, $message); } function assertWithinMargin($first, $second, $margin, $message = '%s') { return $this->assert( new WithinMarginExpectation($first, $margin), $second, $message); } function assertOutsideMargin($first, $second, $margin, $message = '%s') { return $this->assert( new OutsideMarginExpectation($first, $margin), $second, $message); } function assertIdentical($first, $second, $message = '%s') { return $this->assert( new IdenticalExpectation($first), $second, $message); } function assertNotIdentical($first, $second, $message = '%s') { return $this->assert( new NotIdenticalExpectation($first), $second, $message); } function assertReference($first, $second, $message = '%s') { $dumper = new SimpleDumper(); $message = sprintf( $message, '[' . $dumper->describeValue($first) . '] and [' . $dumper->describeValue($second) . '] should reference the same object'); return $this->assertTrue( SimpleTestCompatibility::isReference($first, $second), $message); } function assertSame($first, $second, $message = '%s') { $dumper = new SimpleDumper(); $message = sprintf( $message, '[' . $dumper->describeValue($first) . '] and [' . $dumper->describeValue($second) . '] should reference the same object'); return $this->assertTrue($first === $second, $message); } function assertClone($first, $second, $message = '%s') { $dumper = new SimpleDumper(); $message = sprintf( $message, '[' . $dumper->describeValue($first) . '] and [' . $dumper->describeValue($second) . '] should not be the same object'); $identical = new IdenticalExpectation($first); return $this->assertTrue( $identical->test($second) && ! ($first === $second), $message); } function assertCopy($first, $second, $message = "%s") { $dumper = new SimpleDumper(); $message = sprintf( $message, "[" . $dumper->describeValue($first) . "] and [" . $dumper->describeValue($second) . "] should not be the same object"); return $this->assertFalse( SimpleTestCompatibility::isReference($first, $second), $message); } function assertPattern($pattern, $subject, $message = '%s') { return $this->assert( new PatternExpectation($pattern), $subject, $message); } function assertNoPattern($pattern, $subject, $message = '%s') { return $this->assert( new NoPatternExpectation($pattern), $subject, $message); } function expectError($expected = false, $message = '%s') { $queue = SimpleTest::getContext()->get('SimpleErrorQueue'); $queue->expectError($this->coerceExpectation($expected), $message); } function expectException($expected = false, $message = '%s') { $queue = SimpleTest::getContext()->get('SimpleExceptionTrap'); $line = $this->getAssertionLine(); $queue->expectException($expected, $message . $line); } function ignoreException($ignored = false) { SimpleTest::getContext()->get('SimpleExceptionTrap')->ignoreException($ignored); } protected function coerceExpectation($expected) { if ($expected == false) { return new TrueExpectation(); } if (SimpleTestCompatibility::isA($expected, 'SimpleExpectation')) { return $expected; } return new EqualExpectation( is_string($expected) ? str_replace('%', '%%', $expected) : $expected); } }   class FieldExpectation extends SimpleExpectation { private $value; function __construct($value, $message = '%s') { parent::__construct($message); if (is_array($value)) { sort($value); } $this->value = $value; } function test($compare) { if ($this->value === false) { return ($compare === false); } if ($this->isSingle($this->value)) { return $this->testSingle($compare); } if (is_array($this->value)) { return $this->testMultiple($compare); } return false; } protected function isSingle($value) { return is_string($value) || is_integer($value) || is_float($value); } protected function testSingle($compare) { if (is_array($compare) && count($compare) == 1) { $compare = $compare[0]; } if (! $this->isSingle($compare)) { return false; } return ($this->value == $compare); } protected function testMultiple($compare) { if (is_string($compare)) { $compare = array($compare); } if (! is_array($compare)) { return false; } sort($compare); return ($this->value === $compare); } function testMessage($compare) { $dumper = $this->getDumper(); if (is_array($compare)) { sort($compare); } if ($this->test($compare)) { return "Field expectation [" . $dumper->describeValue($this->value) . "]"; } else { return "Field expectation [" . $dumper->describeValue($this->value) . "] fails with [" . $dumper->describeValue($compare) . "] " . $dumper->describeDifference($this->value, $compare); } } } class HttpHeaderExpectation extends SimpleExpectation { private $expected_header; private $expected_value; function __construct($header, $value = false, $message = '%s') { parent::__construct($message); $this->expected_header = $this->normaliseHeader($header); $this->expected_value = $value; } protected function getExpectation() { return $this->expected_value; } protected function normaliseHeader($header) { return strtolower(trim($header)); } function test($compare) { return is_string($this->findHeader($compare)); } protected function findHeader($compare) { $lines = explode("\r\n", $compare); foreach ($lines as $line) { if ($this->testHeaderLine($line)) { return $line; } } return false; } protected function testHeaderLine($line) { if (count($parsed = explode(':', $line, 2)) < 2) { return false; } list($header, $value) = $parsed; if ($this->normaliseHeader($header) != $this->expected_header) { return false; } return $this->testHeaderValue($value, $this->expected_value); } protected function testHeaderValue($value, $expected) { if ($expected === false) { return true; } if (SimpleExpectation::isExpectation($expected)) { return $expected->test(trim($value)); } return (trim($value) == trim($expected)); } function testMessage($compare) { if (SimpleExpectation::isExpectation($this->expected_value)) { $message = $this->expected_value->overlayMessage($compare, $this->getDumper()); } else { $message = $this->expected_header . ($this->expected_value ? ': ' . $this->expected_value : ''); } if (is_string($line = $this->findHeader($compare))) { return "Searching for header [$message] found [$line]"; } else { return "Failed to find header [$message]"; } } } class NoHttpHeaderExpectation extends HttpHeaderExpectation { private $expected_header; private $expected_value; function __construct($unwanted, $message = '%s') { parent::__construct($unwanted, false, $message); } function test($compare) { return ($this->findHeader($compare) === false); } function testMessage($compare) { $expectation = $this->getExpectation(); if (is_string($line = $this->findHeader($compare))) { return "Found unwanted header [$expectation] with [$line]"; } else { return "Did not find unwanted header [$expectation]"; } } } class TextExpectation extends SimpleExpectation { private $substring; function __construct($substring, $message = '%s') { parent::__construct($message); $this->substring = $substring; } protected function getSubstring() { return $this->substring; } function test($compare) { return (strpos($compare, $this->substring) !== false); } function testMessage($compare) { if ($this->test($compare)) { return $this->describeTextMatch($this->getSubstring(), $compare); } else { $dumper = $this->getDumper(); return "Text [" . $this->getSubstring() . "] not detected in [" . $dumper->describeValue($compare) . "]"; } } protected function describeTextMatch($substring, $subject) { $position = strpos($subject, $substring); $dumper = $this->getDumper(); return "Text [$substring] detected at character [$position] in [" . $dumper->describeValue($subject) . "] in region [" . $dumper->clipString($subject, 100, $position) . "]"; } } class NoTextExpectation extends TextExpectation { function __construct($substring, $message = '%s') { parent::__construct($substring, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { if ($this->test($compare)) { $dumper = $this->getDumper(); return "Text [" . $this->getSubstring() . "] not detected in [" . $dumper->describeValue($compare) . "]"; } else { return $this->describeTextMatch($this->getSubstring(), $compare); } } } class WebTestCase extends SimpleTestCase { private $browser; private $ignore_errors = false; function __construct($label = false) { parent::__construct($label); } function before($method) { parent::before($method); $this->setBrowser($this->createBrowser()); } function after($method) { $this->unsetBrowser(); parent::after($method); } function getBrowser() { return $this->browser; } function setBrowser($browser) { return $this->browser = $browser; } function setParser($parser) { $this->browser->setParser($parser); } function unsetBrowser() { unset($this->browser); } function createBrowser() { return new SimpleBrowser(); } function getTransportError() { return $this->browser->getTransportError(); } function getUrl() { return $this->browser->getUrl(); } function showRequest() { $this->dump($this->browser->getRequest()); } function showHeaders() { $this->dump($this->browser->getHeaders()); } function showSource() { $this->dump($this->browser->getContent()); } function showText() { $this->dump(wordwrap($this->browser->getContentAsText(), 80)); } function restart($date = false) { if ($date === false) { $date = time(); } $this->browser->restart($date); } function ageCookies($interval) { $this->browser->ageCookies($interval); } function ignoreFrames() { $this->browser->ignoreFrames(); } function ignoreCookies() { $this->browser->ignoreCookies(); } function ignoreErrors() { $this->ignore_errors = true; } protected function failOnError($result) { if (! $this->ignore_errors) { if ($error = $this->browser->getTransportError()) { $this->fail($error); } } $this->ignore_errors = false; return $result; } function addHeader($header) { $this->browser->addHeader($header); } function setMaximumRedirects($max) { if (! $this->browser) { trigger_error( 'Can only set maximum redirects in a test method, setUp() or tearDown()'); } $this->browser->setMaximumRedirects($max); } function setConnectionTimeout($timeout) { $this->browser->setConnectionTimeout($timeout); } function useProxy($proxy, $username = false, $password = false) { $this->browser->useProxy($proxy, $username, $password); } function get($url, $parameters = false) { return $this->failOnError($this->browser->get($url, $parameters)); } function post($url, $parameters = false, $content_type = false) { return $this->failOnError($this->browser->post($url, $parameters, $content_type)); } function put($url, $body = false, $content_type = false) { return $this->failOnError($this->browser->put($url, $body, $content_type)); } function delete($url, $parameters = false) { return $this->failOnError($this->browser->delete($url, $parameters)); } function head($url, $parameters = false) { return $this->failOnError($this->browser->head($url, $parameters)); } function retry() { return $this->failOnError($this->browser->retry()); } function back() { return $this->failOnError($this->browser->back()); } function forward() { return $this->failOnError($this->browser->forward()); } function authenticate($username, $password) { return $this->failOnError( $this->browser->authenticate($username, $password)); } function getCookie($name) { return $this->browser->getCurrentCookieValue($name); } function setCookie($name, $value, $host = false, $path = '/', $expiry = false) { $this->browser->setCookie($name, $value, $host, $path, $expiry); } function getFrameFocus() { return $this->browser->getFrameFocus(); } function setFrameFocusByIndex($choice) { return $this->browser->setFrameFocusByIndex($choice); } function setFrameFocus($name) { return $this->browser->setFrameFocus($name); } function clearFrameFocus() { return $this->browser->clearFrameFocus(); } function click($label) { return $this->failOnError($this->browser->click($label)); } function assertClickable($label, $message = '%s') { return $this->assertTrue( $this->browser->isClickable($label), sprintf($message, "Click target [$label] should exist")); } function clickSubmit($label = 'Submit', $additional = false) { return $this->failOnError( $this->browser->clickSubmit($label, $additional)); } function clickSubmitByName($name, $additional = false) { return $this->failOnError( $this->browser->clickSubmitByName($name, $additional)); } function clickSubmitById($id, $additional = false) { return $this->failOnError( $this->browser->clickSubmitById($id, $additional)); } function assertSubmit($label, $message = '%s') { return $this->assertTrue( $this->browser->isSubmit($label), sprintf($message, "Submit button [$label] should exist")); } function clickImage($label, $x = 1, $y = 1, $additional = false) { return $this->failOnError( $this->browser->clickImage($label, $x, $y, $additional)); } function clickImageByName($name, $x = 1, $y = 1, $additional = false) { return $this->failOnError( $this->browser->clickImageByName($name, $x, $y, $additional)); } function clickImageById($id, $x = 1, $y = 1, $additional = false) { return $this->failOnError( $this->browser->clickImageById($id, $x, $y, $additional)); } function assertImage($label, $message = '%s') { return $this->assertTrue( $this->browser->isImage($label), sprintf($message, "Image with text [$label] should exist")); } function submitFormById($id) { return $this->failOnError($this->browser->submitFormById($id)); } function clickLink($label, $index = 0) { return $this->failOnError($this->browser->clickLink($label, $index)); } function clickLinkById($id) { return $this->failOnError($this->browser->clickLinkById($id)); } function assertLink($label, $expected = true, $message = '%s') { $url = $this->browser->getLink($label); if ($expected === true || ($expected !== true && $url === false)) { return $this->assertTrue($url !== false, sprintf($message, "Link [$label] should exist")); } if (! SimpleExpectation::isExpectation($expected)) { $expected = new IdenticalExpectation($expected); } return $this->assert($expected, $url->asString(), sprintf($message, "Link [$label] should match")); } function assertNoLink($label, $message = '%s') { return $this->assertTrue( $this->browser->getLink($label) === false, sprintf($message, "Link [$label] should not exist")); } function assertLinkById($id, $expected = true, $message = '%s') { $url = $this->browser->getLinkById($id); if ($expected === true) { return $this->assertTrue($url !== false, sprintf($message, "Link ID [$id] should exist")); } if (! SimpleExpectation::isExpectation($expected)) { $expected = new IdenticalExpectation($expected); } return $this->assert($expected, $url->asString(), sprintf($message, "Link ID [$id] should match")); } function assertNoLinkById($id, $message = '%s') { return $this->assertTrue( $this->browser->getLinkById($id) === false, sprintf($message, "Link ID [$id] should not exist")); } function setField($label, $value, $position=false) { return $this->browser->setField($label, $value, $position); } function setFieldByName($name, $value, $position=false) { return $this->browser->setFieldByName($name, $value, $position); } function setFieldById($id, $value) { return $this->browser->setFieldById($id, $value); } function assertField($label, $expected = true, $message = '%s') { $value = $this->browser->getField($label); return $this->assertFieldValue($label, $value, $expected, $message); } function assertFieldByName($name, $expected = true, $message = '%s') { $value = $this->browser->getFieldByName($name); return $this->assertFieldValue($name, $value, $expected, $message); } function assertFieldById($id, $expected = true, $message = '%s') { $value = $this->browser->getFieldById($id); return $this->assertFieldValue($id, $value, $expected, $message); } protected function assertFieldValue($identifier, $value, $expected, $message) { if ($expected === true) { return $this->assertTrue( isset($value), sprintf($message, "Field [$identifier] should exist")); } if (! SimpleExpectation::isExpectation($expected)) { $identifier = str_replace('%', '%%', $identifier); $expected = new FieldExpectation( $expected, "Field [$identifier] should match with [%s]"); } return $this->assert($expected, $value, $message); } function assertResponse($responses, $message = '%s') { $responses = (is_array($responses) ? $responses : array($responses)); $code = $this->browser->getResponseCode(); $message = sprintf($message, "Expecting response in [" . implode(", ", $responses) . "] got [$code]"); return $this->assertTrue(in_array($code, $responses), $message); } function assertMime($types, $message = '%s') { $types = (is_array($types) ? $types : array($types)); $type = $this->browser->getMimeType(); $message = sprintf($message, "Expecting mime type in [" . implode(", ", $types) . "] got [$type]"); return $this->assertTrue(in_array($type, $types), $message); } function assertAuthentication($authentication = false, $message = '%s') { if (! $authentication) { $message = sprintf($message, "Expected any authentication type, got [" . $this->browser->getAuthentication() . "]"); return $this->assertTrue( $this->browser->getAuthentication(), $message); } else { $message = sprintf($message, "Expected authentication [$authentication] got [" . $this->browser->getAuthentication() . "]"); return $this->assertTrue( strtolower($this->browser->getAuthentication()) == strtolower($authentication), $message); } } function assertNoAuthentication($message = '%s') { $message = sprintf($message, "Expected no authentication type, got [" . $this->browser->getAuthentication() . "]"); return $this->assertFalse($this->browser->getAuthentication(), $message); } function assertRealm($realm, $message = '%s') { if (! SimpleExpectation::isExpectation($realm)) { $realm = new EqualExpectation($realm); } return $this->assert( $realm, $this->browser->getRealm(), "Expected realm -> $message"); } function assertHeader($header, $value = false, $message = '%s') { return $this->assert( new HttpHeaderExpectation($header, $value), $this->browser->getHeaders(), $message); } function assertNoHeader($header, $message = '%s') { return $this->assert( new NoHttpHeaderExpectation($header), $this->browser->getHeaders(), $message); } function assertTitle($title = false, $message = '%s') { if (! SimpleExpectation::isExpectation($title)) { $title = new EqualExpectation($title); } return $this->assert($title, $this->browser->getTitle(), $message); } function assertText($text, $message = '%s') { return $this->assert( new TextExpectation($text), $this->browser->getContentAsText(), $message); } function assertNoText($text, $message = '%s') { return $this->assert( new NoTextExpectation($text), $this->browser->getContentAsText(), $message); } function assertPattern($pattern, $message = '%s') { return $this->assert( new PatternExpectation($pattern), $this->browser->getContent(), $message); } function assertNoPattern($pattern, $message = '%s') { return $this->assert( new NoPatternExpectation($pattern), $this->browser->getContent(), $message); } function assertCookie($name, $expected = false, $message = '%s') { $value = $this->getCookie($name); if (! $expected) { return $this->assertTrue( $value, sprintf($message, "Expecting cookie [$name]")); } if (! SimpleExpectation::isExpectation($expected)) { $expected = new EqualExpectation($expected); } return $this->assert($expected, $value, "Expecting cookie [$name] -> $message"); } function assertNoCookie($name, $message = '%s') { return $this->assertTrue( $this->getCookie($name) === null or $this->getCookie($name) === false, sprintf($message, "Not expecting cookie [$name]")); } function assertTrue($result, $message = false) { return $this->assert(new TrueExpectation(), $result, $message); } function assertFalse($result, $message = '%s') { return $this->assert(new FalseExpectation(), $result, $message); } function assertEqual($first, $second, $message = '%s') { return $this->assert( new EqualExpectation($first), $second, $message); } function assertNotEqual($first, $second, $message = '%s') { return $this->assert( new NotEqualExpectation($first), $second, $message); } function getAssertionLine() { $trace = new SimpleStackTrace(array('assert', 'click', 'pass', 'fail')); return $trace->traceMethod(); } }   class XmlReporter extends SimpleReporter { private $indent; private $namespace; function __construct($namespace = false, $indent = '  ') { parent::__construct(); $this->namespace = ($namespace ? $namespace . ':' : ''); $this->indent = $indent; } protected function getIndent($offset = 0) { return str_repeat( $this->indent, count($this->getTestList()) + $offset); } function toParsedXml($text) { return str_replace( array('&', '<', '>', '"', '\''), array('&amp;', '&lt;', '&gt;', '&quot;', '&apos;'), $text); } function paintGroupStart($test_name, $size) { parent::paintGroupStart($test_name, $size); print $this->getIndent(); print "<" . $this->namespace . "group size=\"$size\">\n"; print $this->getIndent(1); print "<" . $this->namespace . "name>" . $this->toParsedXml($test_name) . "</" . $this->namespace . "name>\n"; } function paintGroupEnd($test_name) { print $this->getIndent(); print "</" . $this->namespace . "group>\n"; parent::paintGroupEnd($test_name); } function paintCaseStart($test_name) { parent::paintCaseStart($test_name); print $this->getIndent(); print "<" . $this->namespace . "case>\n"; print $this->getIndent(1); print "<" . $this->namespace . "name>" . $this->toParsedXml($test_name) . "</" . $this->namespace . "name>\n"; } function paintCaseEnd($test_name) { print $this->getIndent(); print "</" . $this->namespace . "case>\n"; parent::paintCaseEnd($test_name); } function paintMethodStart($test_name) { parent::paintMethodStart($test_name); print $this->getIndent(); print "<" . $this->namespace . "test>\n"; print $this->getIndent(1); print "<" . $this->namespace . "name>" . $this->toParsedXml($test_name) . "</" . $this->namespace . "name>\n"; } function paintMethodEnd($test_name) { print $this->getIndent(); print "</" . $this->namespace . "test>\n"; parent::paintMethodEnd($test_name); } function paintPass($message) { parent::paintPass($message); print $this->getIndent(1); print "<" . $this->namespace . "pass>"; print $this->toParsedXml($message); print "</" . $this->namespace . "pass>\n"; } function paintFail($message) { parent::paintFail($message); print $this->getIndent(1); print "<" . $this->namespace . "fail>"; print $this->toParsedXml($message); print "</" . $this->namespace . "fail>\n"; } function paintError($message) { parent::paintError($message); print $this->getIndent(1); print "<" . $this->namespace . "exception>"; print $this->toParsedXml($message); print "</" . $this->namespace . "exception>\n"; } function paintException($exception) { parent::paintException($exception); print $this->getIndent(1); print "<" . $this->namespace . "exception>"; $message = 'Unexpected exception of type [' . get_class($exception) . '] with message ['. $exception->getMessage() . '] in ['. $exception->getFile() . ' line ' . $exception->getLine() . ']'; print $this->toParsedXml($message); print "</" . $this->namespace . "exception>\n"; } function paintSkip($message) { parent::paintSkip($message); print $this->getIndent(1); print "<" . $this->namespace . "skip>"; print $this->toParsedXml($message); print "</" . $this->namespace . "skip>\n"; } function paintMessage($message) { parent::paintMessage($message); print $this->getIndent(1); print "<" . $this->namespace . "message>"; print $this->toParsedXml($message); print "</" . $this->namespace . "message>\n"; } function paintFormattedMessage($message) { parent::paintFormattedMessage($message); print $this->getIndent(1); print "<" . $this->namespace . "formatted>"; print "<![CDATA[$message]]>"; print "</" . $this->namespace . "formatted>\n"; } function paintSignal($type, $payload) { parent::paintSignal($type, $payload); print $this->getIndent(1); print "<" . $this->namespace . "signal type=\"$type\">"; print "<![CDATA[" . serialize($payload) . "]]>"; print "</" . $this->namespace . "signal>\n"; } function paintHeader($test_name) { if (! SimpleReporter::inCli()) { header('Content-type: text/xml'); } print "<?xml version=\"1.0\""; if ($this->namespace) { print " xmlns:" . $this->namespace . "=\"www.lastcraft.com/SimpleTest/Beta3/Report\""; } print "?>\n"; print "<" . $this->namespace . "run>\n"; } function paintFooter($test_name) { print "</" . $this->namespace . "run>\n"; } } class NestingXmlTag { private $name; private $attributes; function NestingXmlTag($attributes) { $this->name = false; $this->attributes = $attributes; } function setName($name) { $this->name = $name; } function getName() { return $this->name; } protected function getAttributes() { return $this->attributes; } } class NestingMethodTag extends NestingXmlTag { function NestingMethodTag($attributes) { $this->NestingXmlTag($attributes); } function paintStart($listener) { $listener->paintMethodStart($this->getName()); } function paintEnd($listener) { $listener->paintMethodEnd($this->getName()); } } class NestingCaseTag extends NestingXmlTag { function NestingCaseTag($attributes) { $this->NestingXmlTag($attributes); } function paintStart($listener) { $listener->paintCaseStart($this->getName()); } function paintEnd($listener) { $listener->paintCaseEnd($this->getName()); } } class NestingGroupTag extends NestingXmlTag { function NestingGroupTag($attributes) { $this->NestingXmlTag($attributes); } function paintStart($listener) { $listener->paintGroupStart($this->getName(), $this->getSize()); } function paintEnd($listener) { $listener->paintGroupEnd($this->getName()); } function getSize() { $attributes = $this->getAttributes(); if (isset($attributes['SIZE'])) { return (integer)$attributes['SIZE']; } return 0; } } class SimpleTestXmlParser { private $listener; private $expat; private $tag_stack; private $in_content_tag; private $content; private $attributes; function SimpleTestXmlParser($listener) { $this->listener = $listener; $this->expat = $this->createParser(); $this->tag_stack = array(); $this->in_content_tag = false; $this->content = ''; $this->attributes = array(); } function parse($chunk) { if (! xml_parse($this->expat, $chunk)) { trigger_error('XML parse error with ' . xml_error_string(xml_get_error_code($this->expat))); return false; } return true; } protected function createParser() { $expat = xml_parser_create(); xml_set_object($expat, $this); xml_set_element_handler($expat, 'startElement', 'endElement'); xml_set_character_data_handler($expat, 'addContent'); xml_set_default_handler($expat, 'defaultContent'); return $expat; } protected function pushNestingTag($nested) { array_unshift($this->tag_stack, $nested); } protected function getCurrentNestingTag() { return $this->tag_stack[0]; } protected function popNestingTag() { return array_shift($this->tag_stack); } protected function isLeaf($tag) { return in_array($tag, array( 'NAME', 'PASS', 'FAIL', 'EXCEPTION', 'SKIP', 'MESSAGE', 'FORMATTED', 'SIGNAL')); } protected function startElement($expat, $tag, $attributes) { $this->attributes = $attributes; if ($tag == 'GROUP') { $this->pushNestingTag(new NestingGroupTag($attributes)); } elseif ($tag == 'CASE') { $this->pushNestingTag(new NestingCaseTag($attributes)); } elseif ($tag == 'TEST') { $this->pushNestingTag(new NestingMethodTag($attributes)); } elseif ($this->isLeaf($tag)) { $this->in_content_tag = true; $this->content = ''; } } protected function endElement($expat, $tag) { $this->in_content_tag = false; if (in_array($tag, array('GROUP', 'CASE', 'TEST'))) { $nesting_tag = $this->popNestingTag(); $nesting_tag->paintEnd($this->listener); } elseif ($tag == 'NAME') { $nesting_tag = $this->getCurrentNestingTag(); $nesting_tag->setName($this->content); $nesting_tag->paintStart($this->listener); } elseif ($tag == 'PASS') { $this->listener->paintPass($this->content); } elseif ($tag == 'FAIL') { $this->listener->paintFail($this->content); } elseif ($tag == 'EXCEPTION') { $this->listener->paintError($this->content); } elseif ($tag == 'SKIP') { $this->listener->paintSkip($this->content); } elseif ($tag == 'SIGNAL') { $this->listener->paintSignal( $this->attributes['TYPE'], unserialize($this->content)); } elseif ($tag == 'MESSAGE') { $this->listener->paintMessage($this->content); } elseif ($tag == 'FORMATTED') { $this->listener->paintFormattedMessage($this->content); } } protected function addContent($expat, $text) { if ($this->in_content_tag) { $this->content .= $text; } return true; } protected function defaultContent($expat, $default) { } } ?>