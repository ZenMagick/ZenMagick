<?php  interface CallableStatement extends PreparedStatement { public function registerOutParameter($paramIndex, $sqlType, $maxLength = null); public function getArray($paramIndex); public function getBoolean($paramIndex); public function getBlob($paramIndex); public function getClob($paramIndex); public function getDate($column, $format = '%x'); public function getFloat($paramIndex); public function getInt($paramIndex); public function getString($paramIndex); public function getTime($column, $format = '%X'); public function getTimestamp($column, $format = 'Y-m-d H:i:s'); }   class ColumnInfo { public $name; public $type; public $nativeType; public $size; public $precision; public $scale; public $isNullable; public $defaultValue; public $isAutoIncrement; public $table; protected $vendorSpecificInfo = array(); function __construct(TableInfo $table, $name, $type = null, $nativeType = null, $size = null, $precision=null, $scale = null, $is_nullable = null, $default = null, $is_auto_increment = null, $vendorInfo = array()) { $this->table = $table; $this->name = $name; $this->type = $type; $this->nativeType = $nativeType; $this->size = $size; $this->precision = $precision; $this->scale = $scale; $this->isNullable = $is_nullable; $this->defaultValue = $default; $this->isAutoIncrement = $is_auto_increment; $this->vendorSpecificInfo = $vendorInfo; } function __sleep() { return array('name', 'type', 'nativeType', 'size', 'precision', 'isNullable', 'defaultValue'); } public function getName() { return $this->name; } public function getType() { return $this->type; } public function getNativeType() { return $this->nativeType; } public function getSize() { return $this->size; } public function getPrecision() { return $this->precision; } public function getScale() { return $this->scale; } public function getDefaultValue() { return $this->defaultValue; } public function isNullable() { return $this->isNullable; } public function isAutoIncrement() { return $this->isAutoIncrement === true; } public function getVendorSpecificInfo() { return $this->vendorSpecificInfo; } public function toString() { return $this->name; } public function getTable() { return $this->table; } }   interface Connection { public function connect($dsn, $flags = false); public function getResource(); public function getFlags(); public function getDSN(); public function getDatabaseInfo(); public function getIdGenerator(); public function prepareStatement($sql); public function createStatement(); public function applyLimit(&$sql, $offset, $limit); public function executeQuery($sql, $fetchmode = null); public function executeUpdate($sql); public function prepareCall($sql); public function close(); public function isConnected(); public function getAutoCommit(); public function setAutoCommit($bit); public function begin(); public function commit(); public function rollback(); public function getUpdateCount(); }   abstract class ConnectionCommon { protected $transactionOpcount = 0; protected $nestedTransactionSavepoints = array(); protected $dblink; protected $dsn; protected $flags = 0; public function __sleep() { return array('dsn', 'flags'); } public function __wakeup() { $this->connect($this->dsn, $this->flags); } public function getResource() { return $this->dblink; } public function getDSN() { return $this->dsn; } public function getFlags() { return $this->flags; } public function prepareCall($sql) { throw new SQLException("Current driver does not support stored procedures using CallableStatement."); } public function supportsNestedTrans() { return false; } public function begin() { if ($this->transactionOpcount === 0 || $this->supportsNestedTrans()) { $this->beginTrans(); } elseif ($this->supportsSavepoints()) { $savepointIdentifier = "creole_savepoint_".count($this->nestedTransactionSavepoints); $this->nestedTransactionSavepoints[] = $savepointIdentifier; $this->setSavepoint( $savepointIdentifier ); } $this->transactionOpcount++; } public function commit() { if ($this->transactionOpcount > 0) { if ($this->transactionOpcount == 1 || $this->supportsNestedTrans()) { $this->commitTrans(); } elseif ($this->supportsSavepoints()) { $savepointIdentifier = array_pop( $this->nestedTransactionSavepoints ); $this->releaseSavepoint( $savepointIdentifier ); } $this->transactionOpcount--; } } public function rollback() { if ($this->transactionOpcount > 0) { if ($this->transactionOpcount == 1 || $this->supportsNestedTrans()) { $this->rollbackTrans(); } elseif ($this->supportsSavepoints()) { $savepointIdentifier = array_pop( $this->nestedTransactionSavepoints ); $this->rollbackToSavepoint( $savepointIdentifier ); } $this->transactionOpcount--; } } protected function supportsSavepoints() { return false; } protected function setSavepoint( $identifier ) { throw new SQLException('This database driver doesn\'t support savepoints'); } protected function releaseSavepoint( $identifier ) { throw new SQLException('This database driver doesn\'t support savepoints'); } protected function rollbackToSavepoint( $identifier ) { throw new SQLException('This database driver doesn\'t support savepoints'); } public function setAutoCommit($bit) { if ($this->transactionOpcount > 0) { trigger_error("Changing autocommit in mid-transaction; committing " . $this->transactionOpcount . " uncommitted statements.", E_USER_WARNING); } if (!$bit) { $this->begin(); } else { $this->commit(); } } public function getAutoCommit() { return ($this->transactionOpcount == 0); } protected function beginTrans() { } protected function commitTrans() { } protected function rollbackTrans() { } public function isConnected() { return !empty($this->dblink); } }   @ini_set('track_errors', true); class Creole { const PERSISTENT = 1; const NO_ASSOC_LOWER = 16; const COMPAT_ASSOC_LOWER = 32; const COMPAT_RTRIM_STRING = 64; const COMPAT_ALL = 96; const MYSQL_CLIENT_MULTI_STATEMENTS = 65536; const MYSQL_CLIENT_MULTI_RESULTS = 131072; private static $driverMap = array( 'mysql' => 'creole.drivers.mysql.MySQLConnection', 'mysqli' => 'creole.drivers.mysqli.MySQLiConnection', 'pgsql' => 'creole.drivers.pgsql.PgSQLConnection', 'sqlite' => 'creole.drivers.sqlite.SQLiteConnection', 'oracle' => 'creole.drivers.oracle.OCI8Connection', 'mssql' => 'creole.drivers.mssql.MSSQLConnection', 'odbc' => 'creole.drivers.odbc.ODBCConnection', 'pdosqlite' => 'creole.drivers.pdosqlite.PdoSQLiteConnection', 'pdosqlite2' => 'creole.drivers.pdosqlite.PdoSQLiteConnection', 'sqlite3' => 'creole.drivers.pdosqlite.PdoSQLiteConnection', ); private static $connectionMap = array(); public static function registerDriver($phptype, $dotpath) { self::$driverMap[$phptype] = $dotpath; } public static function deregisterDriver($phptype) { unset(self::$driverMap[$phptype]); } public static function getDriver($phptype) { if (isset(self::$driverMap[$phptype])) { return self::$driverMap[$phptype]; } else { return null; } } public static function getConnection($dsn, $flags = 0) { if (is_array($dsn)) { $dsninfo = $dsn; } else { $dsninfo = self::parseDSN($dsn); } if ( isset ( $dsninfo['persistent'] ) && ! empty ( $dsninfo['persistent'] ) ) $flags |= Creole::PERSISTENT; if ( isset ( $dsninfo['compat_assoc_lower'] ) && ! empty ( $dsninfo['compat_assoc_lower'] ) ) $flags |= Creole::COMPAT_ASSOC_LOWER; if ( isset ( $dsninfo['compat_rtrim_string'] ) && ! empty ( $dsninfo['compat_rtrim_string'] ) ) $flags |= Creole::COMPAT_RTRIM_STRING; if ( isset ( $dsninfo['compat_all'] ) && ! empty ( $dsninfo['compat_all'] ) ) $flags |= Creole::COMPAT_ALL; if ($flags & Creole::NO_ASSOC_LOWER) { trigger_error("The Creole::NO_ASSOC_LOWER flag has been deprecated, and is now the default behavior. Use Creole::COMPAT_ASSOC_LOWER to lowercase resulset keys.", E_USER_WARNING); } ksort($dsninfo); $connectionMapKey = crc32(serialize($dsninfo + array('compat_flags' => ($flags & Creole::COMPAT_ALL)))); if(isset(self::$connectionMap[$connectionMapKey])) { if( isset(self::$connectionMap[$connectionMapKey][1]) ) { $con = self::$connectionMap[$connectionMapKey][1]; } else { $con = self::$connectionMap[$connectionMapKey][0]; } if ($con->isConnected()) return $con; } if (isset(self::$driverMap['*'])) { $type = '*'; } else { $type = $dsninfo['phptype']; if (!isset(self::$driverMap[$type])) { throw new SQLException("No driver has been registered to handle connection type: $type"); } } $clazz = self::import(self::$driverMap[$type]); $obj = new $clazz(); if (!($obj instanceof Connection)) { throw new SQLException("Class does not implement creole.Connection interface: $clazz"); } try { $obj->connect($dsninfo, $flags); } catch(SQLException $sqle) { $sqle->setUserInfo($dsninfo); throw $sqle; } $persistent = ($flags & Creole::PERSISTENT) === Creole::PERSISTENT; return self::$connectionMap[$connectionMapKey][(int)$persistent] = $obj; } public static function parseDSN($dsn) { if (is_array($dsn)) { return $dsn; } $parsed = array( 'phptype' => null, 'username' => null, 'password' => null, 'protocol' => null, 'hostspec' => null, 'port' => null, 'socket' => null, 'database' => null ); $preg_query = "!^(([a-z0-9]+)(\(([^()]+)\))?)(://((((([^@/:]+)(:([^@/]+))?)@)?((([a-z]+)\((([^?():]+)(:([^()?]+))?)\))|((([^/?:]+)(:([^/?]+))?))))/?)?([^?]+)?(\?(.+))?)?$!i"; $info = array(); if (preg_match($preg_query,$dsn,$info)) { $parsed['phptype'] = @$info[2]; if (isset($info[5])) { if (strlen($info[10]) > 0) { $parsed['username'] = @$info[10]; } if (strlen($info[12]) > 0) { $parsed['password'] = @$info[12]; } if (strlen($info[15]) > 0) { $parsed['protocol'] = @$info[15]; if ($parsed["protocol"] === "unix") { $parsed['socket'] = @$info[16]; } else { $parsed["hostspec"] = @$info[17]; if (strlen($info[19]) > 0) { $parsed["port"] = @$info[19]; } } } elseif (strlen($info[20]) > 0) { $parsed["hostspec"] = @$info[22]; if ((isset($info[24]) && (strlen($info[24]) > 0))) { $parsed["port"] = @$info[24]; } } if ((isset($info[25])) && (strlen($info[25]) > 0)) { $parsed["database"] = @$info[25]; } if ((isset($info[27])) && (strlen($info[27]) >0)) { $opts = explode('&', $info[27]); foreach ($opts as $opt) { list($key, $value) = explode('=', $opt); if (!isset($parsed[$key])) { $parsed[$key] = urldecode($value); } } } } } return $parsed; } public static function import($class) { $pos = strrpos($class, '.'); if ($pos !== false) { $classname = substr($class, $pos + 1); } else { $classname = $class; } if (!class_exists($classname, false)) { $path = strtr($class, '.', DIRECTORY_SEPARATOR) . '.php'; $ret = @include_once($path); if ($ret === false) { throw new SQLException("Unable to load driver class: " . $class); } if (!class_exists($classname)) { throw new SQLException("Unable to find loaded class: $classname (Hint: make sure classname matches filename)"); } } return $classname; } }   abstract class CreoleTypes { const BOOLEAN = 1; const BIGINT = 2; const SMALLINT = 3; const TINYINT = 4; const INTEGER = 5; const CHAR = 6; const VARCHAR = 7; const TEXT = 17; const FLOAT = 8; const DOUBLE = 9; const DATE = 10; const TIME = 11; const TIMESTAMP = 12; const VARBINARY = 13; const NUMERIC = 14; const BLOB = 15; const CLOB = 16; const LONGVARCHAR = 17; const DECIMAL = 18; const REAL = 19; const BINARY = 20; const LONGVARBINARY = 21; const YEAR = 22; const ARR = 23; const OTHER = -1; protected static $affixMap = array( self::BOOLEAN => 'Boolean', self::BIGINT => 'String', self::CHAR => 'String', self::DATE => 'Date', self::DOUBLE => 'String', self::FLOAT => 'String', self::INTEGER => 'Int', self::SMALLINT => 'Int', self::TINYINT => 'Int', self::TIME => 'Time', self::TIMESTAMP => 'Timestamp', self::VARCHAR => 'String', self::VARBINARY => 'Blob', self::NUMERIC => 'String', self::BLOB => 'Blob', self::CLOB => 'Clob', self::LONGVARCHAR => 'String', self::DECIMAL => 'String', self::REAL => 'String', self::BINARY => 'Blob', self::LONGVARBINARY => 'Blob', self::YEAR => 'Int', self::ARR => 'Array', self::OTHER => '', ); protected static $creoleTypeMap = array( self::BOOLEAN => 'BOOLEAN', self::BIGINT => 'BIGINT', self::SMALLINT => 'SMALLINT', self::TINYINT => 'TINYINT', self::INTEGER => 'INTEGER', self::NUMERIC => 'NUMERIC', self::DECIMAL => 'DECIMAL', self::REAL => 'REAL', self::FLOAT => 'FLOAT', self::DOUBLE => 'DOUBLE', self::CHAR => 'CHAR', self::VARCHAR => 'VARCHAR', self::TEXT => 'TEXT', self::TIME => 'TIME', self::TIMESTAMP => 'TIMESTAMP', self::DATE => 'DATE', self::YEAR => 'YEAR', self::VARBINARY => 'VARBINARY', self::BLOB => 'BLOB', self::CLOB => 'CLOB', self::LONGVARCHAR => 'LONGVARCHAR', self::BINARY => 'BINARY', self::LONGVARBINARY => 'LONGVARBINARY', self::ARR => 'ARR', self::OTHER => 'OTHER', ); static function getType($nativeType) { throw new SQLException('CreoleTypes::getType() should not be called directly'); } static function getNativeType($creoleType) { throw new SQLException('CreoleTypes::getNativeType() should not be called directly'); } public static function getAffix($creoleType) { if (!isset(self::$affixMap[$creoleType])) { $e = new SQLException("Unable to return 'affix' for unknown CreoleType: " . $creoleType); throw $e; } return self::$affixMap[$creoleType]; } public static function getCreoleName($creoleType) { if (!isset(self::$creoleTypeMap[$creoleType])) { return null; } return self::$creoleTypeMap[$creoleType]; } public static function getCreoleCode($creoleTypeName) { $type = array_search($creoleTypeName, self::$creoleTypeMap); if ($type === false) { return null; } return $type; } }   abstract class DatabaseInfo { protected $tables = array(); protected $sequences = array(); protected $tablesLoaded = false; protected $seqsLoaded = false; private $vendorSpecificInfo = array(); protected $conn; protected $dbname; protected $dblink; public function __construct(Connection $conn, $vendorInfo = array()) { $this->conn = $conn; $this->dblink = $conn->getResource(); $dsn = $conn->getDSN(); $this->dbname = $dsn['database']; $this->vendorSpecificInfo = $vendorInfo; } public function getName() { return $this->dbname; } function __sleep() { return array('tables','sequences','conn'); } function __wakeup() { $this->dbname = $conn->database; $this->dblink = $conn->connection; foreach($this->tables as $tbl) { $tbl->database = $this; $tbl->dbname = $this->dbname; $tbl->dblink = $this->dblink; $tbl->schema = $this->schema; } } public function getConnection() { return $this->conn; } public function getTable($name) { if(!$this->tablesLoaded) $this->initTables(); if (!isset($this->tables[strtoupper($name)])) { throw new SQLException("Database `".$this->dbname."` has no table `".$name."`"); } return $this->tables[ strtoupper($name) ]; } public function hasTable($name) { if(!$this->tablesLoaded) $this->initTables(); return isset($this->tables[strtoupper($name)]); } public function getTables() { if(!$this->tablesLoaded) $this->initTables(); return array_values($this->tables); } public function addTable(TableInfo $table) { $this->tables[strtoupper($table->getName())] = $table; } abstract protected function initTables(); abstract protected function initSequences(); public function isSequence($key) { if(!$this->seqsLoaded) $this->initSequences(); return isset($this->sequences[ strtoupper($key) ]); } public function getSequences() { if(!$this->seqsLoaded) $this->initSequences(); return array_values($this->sequences); } public function getVendorSpecificInfo() { return $this->vendorSpecificInfo; } }   class DataSetException extends Exception {}   class ForeignKeyInfo { private $name; private $references = array(); protected $vendorSpecificInfo = array(); const NONE = ""; const NOACTION = "NO ACTION"; const CASCADE = "CASCADE"; const RESTRICT = "RESTRICT"; const SETDEFAULT = "SET DEFAULT"; const SETNULL = "SET NULL"; function __construct($name, $vendorInfo = array()) { $this->name = $name; $this->vendorSpecificInfo = $vendorInfo; } public function getName() { return $this->name; } public function addReference(ColumnInfo $local, ColumnInfo $foreign, $onDelete = self::NONE, $onUpdate = self::NONE) { $this->references[] = array($local, $foreign, $onDelete, $onUpdate); } public function getReferences() { return $this->references; } public function getVendorSpecificInfo() { return $this->vendorSpecificInfo; } public function toString() { return $this->name; } }   interface IdGenerator { const SEQUENCE = 1; const AUTOINCREMENT = 2; public function isBeforeInsert(); public function isAfterInsert(); public function getIdMethod(); public function getId($keyInfo = null); }   class IndexInfo { private $name; private $columns = array(); private $isUnique = false; private $vendorSpecificInfo = array(); function __construct($name, $isUnique = false, $vendorInfo = array()) { $this->name = $name; $this->isUnique = $isUnique; $this->vendorSpecificInfo = $vendorInfo; } public function isUnique() { return $this->isUnique; } public function getName() { return $this->name; } public function getVendorSpecificInfo() { return $this->vendorSpecificInfo; } public function addColumn($column) { $this->columns[] = $column; } public function getColumns() { return $this->columns; } public function toString() { return $this->name; } }   class KeyDef { private $cols; private $size; public function __construct() { $this->cols = func_get_args(); $this->size = count($this->cols); } public function addAttrib($name) { $this->cols[] = $name; $this->size++; return $this; } public function containsAttrib($name) { return in_array($name, $this->cols, true); } public function getAttrib($pos) { if ($pos === 0) $pos = 1; return @$this->cols[$pos - 1]; } public function size() { return $this->size; } }   abstract class Lob { protected $data; protected $outFile; protected $inFile; private $modified = null; public function __construct($data = null) { if ($data !== null) { $this->setContents($data); } } public function getContents() { if ($this->data === null && $this->isFromFile()) { $this->readFromFile(); } return $this->data; } public function setContents($data) { $this->data = $data; if ($this->modified === null) { $this->modified = false; } elseif ($this->modified === false) { $this->modified = true; } } abstract public function dump(); public function setInputFile($filePath) { $this->inFile = $filePath; } public function getInputFile() { return $this->inFile; } public function setOutputFile($filePath) { $this->outFile = $filePath; } public function getOutputFile() { return $this->outFile; } public function isFromFile() { return ($this->inFile !== null); } public function readFromFile($file = null) { if ($file !== null) { $this->setInputFile($file); } if (!$this->inFile) { throw Exception('No file specified for read.'); } $data = @file_get_contents($this->inFile); if ($data === false) { throw new Exception('Unable to read from file: '.$this->inFile); } $this->setContents($data); } public function writeToFile($file = null) { if ($file !== null) { $this->setOutputFile($file); } if (!$this->outFile) { throw new Exception('No file specified for write'); } if ($this->data === null) { throw new Exception('No data to write to file'); } if (false === @file_put_contents($this->outFile, $this->data)) { throw new Exception('Unable to write to file: '.$this->outFile); } } public function __toString() { return $this->getContents(); } public function setModified($b) { $this->modified = $b; } public function isModified() { return (boolean) $this->modified; } }   class PdoPreparedStatementCommon extends PreparedStatementCommon implements PreparedStatement { private $pdo_stmt = null; private $bind_values = array(); public function __construct(Connection $conn, $sql) { $this->conn = $conn; $this->sql = $sql; } public function saveBindValue( $index, $value, $type = null ) { $this->bind_values[] = array( $index, $value, $type ); } public function replaceParams() { $sql = $this->sql; if ($this->limit > 0 || $this->offset > 0) { $this->conn->applyLimit($sql, $this->offset, $this->limit); } try { $this->pdo_stmt = $this->conn->getResource()->prepare( $sql ); } catch( PDOException $e ) { throw new SQLException("Unable to prepare statement", $e->getMessage(), $sql); } foreach( $this->bind_values as &$parameter ) { if( $parameter[2] != null ) { $this->pdo_stmt->bindValue( $parameter[0], $parameter[1], $parameter[2] ); } else { $this->pdo_stmt->bindValue( $parameter[0], $parameter[1] ); } } } public function executeQuery($p1 = null, $fetchmode = null, $rs_class = null) { if( empty( $rs_class ) ) { throw new SQLException('PdoPreparedStatementCommon::executeQuery: $rs_class can not be empty'); } $params = null; if ($fetchmode !== null) { $params = $p1; } elseif ($p1 !== null) { if (is_array($p1)) $params = $p1; else $fetchmode = $p1; } foreach ( (array) $params as $i=>$param ) { $this->set ( $i + 1, $param ); unset ( $i, $param ); } unset ( $params ); $this->updateCount = null; $this->replaceParams(); unset( $this->resultSet ); if( $this->conn->openResultSet() ) { $this->conn->handleOpenResultSet( ); } $this->pdo_stmt->execute(); $this->resultSet = new $rs_class($this->conn, $this->pdo_stmt, $fetchmode); return $this->resultSet; } public function executeUpdate($params = null) { if($this->resultSet) $this->resultSet->close(); $this->resultSet = null; $this->replaceParams(); if( $this->conn->openResultSet() ) { $this->conn->handleOpenResultSet( ); } try { if( empty( $params ) ) { $this->pdo_stmt->execute(); } else { $this->pdo_stmt->execute($params); } $this->updateCount = $this->pdo_stmt->rowCount(); } catch( PDOException $e ) { throw new SQLException("Unable to execute prepared statement", $e->getMessage()); } return $this->updateCount; } protected function escape($str) { return $this->conn->quote($str); } function setBlob($paramIndex, $blob) { if ($blob === null) { $this->setNull($paramIndex); } else { if (is_object($blob)) { $blob = $blob->__toString(); } $this->saveBindValue( $paramIndex, $blob, PDO::PARAM_LOB ); } } function setBoolean($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { $this->saveBindValue( $paramIndex, $value, PDO::PARAM_BOOL ); } } function setClob($paramIndex, $clob) { if ($clob === null) { $this->setNull($paramIndex); } else { if (is_object($clob)) { $clob = $clob->__toString(); } $this->saveBindValue( $paramIndex, $clob, PDO::PARAM_LOB ); } } function setDecimal($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { $this->saveBindValue( $paramIndex, (float) $value ); } } function setDouble($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { $this->saveBindValue( $paramIndex, (double) $value ); } } function setFloat($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { $this->saveBindValue( $paramIndex, (float) $value ); } } function setInt($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { $this->saveBindValue( $paramIndex, $value, PDO::PARAM_INT ); } } function setNull($paramIndex) { $this->saveBindValue( $paramIndex, null, PDO::PARAM_NULL ); } function setString($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { if ( is_object ( $value ) ) { $value = $value->__toString(); } $this->saveBindValue( $paramIndex, $value, PDO::PARAM_STR ); } } }   class PdoSQLitePreparedStatement extends PdoPreparedStatementCommon { public function executeQuery($p1 = null, $fetchmode = null) { return parent::executeQuery( $p1, $fetchmode, 'PdoSQLiteResultSet'); } }   class PdoSQLiteResultSetIterator implements Iterator { private $result; private $pos = 0; private $fetchmode; private $row_count; public function __construct(SQLiteResultSet $rs) { $this->result = $rs->getResource(); $this->fetchmode = $rs->getFetchmode(); $this->row_count = $rs->getRecordCount(); } function rewind() { sqlite_rewind($this->result); } function valid() { return ( $this->pos < $this->row_count ); } function key() { return $this->pos; } function current() { return sqlite_fetch_array($this->result, $this->fetchmode); } function next() { $this->pos++; } }   class PgSQLResultSetIterator implements SeekableIterator, Countable { private $result; private $pos = 0; private $fetchmode; private $row_count; private $rs; public function __construct(PgSQLResultSet $rs) { $this->result = $rs->getResource(); $this->fetchmode = $rs->getFetchmode(); $this->row_count = $rs->getRecordCount(); $this->rs = $rs; } function rewind() { $this->pos = 0; } function valid() { return ( $this->pos < $this->row_count ); } function key() { return $this->pos; } function current() { return pg_fetch_array($this->result, $this->pos, $this->fetchmode); } function next() { $this->pos++; } function seek ( $index ) { if ( ! is_int ( $index ) ) { throw new InvalidArgumentException ( 'Invalid arguement to seek' ); } if ( $index < 0 || $index > $this->row_count ) { throw new OutOfBoundsException ( 'Invalid seek position' ); } $this->pos = $index; } function count ( ) { return $this->row_count; } }   interface PreparedStatement { public function getConnection(); public function getResource(); public function close(); public function getResultSet(); public function getMoreResults(); public function getUpdateCount(); public function setLimit($v); public function getLimit(); public function setOffset($v); public function getOffset(); public function executeQuery(); public function executeUpdate($params = null); public function set($paramIndex, $value); public function setArray($paramIndex, $value); public function setBoolean($paramIndex, $value); public function setBlob($paramIndex, $blob); public function setClob($paramIndex, $clob); public function setDate($paramIndex, $value); public function setFloat($paramIndex, $value); public function setInt($paramIndex, $value); public function setNull($paramIndex); public function setString($paramIndex, $value); public function setTime($paramIndex, $value); public function setTimestamp($paramIndex, $value); }   abstract class PreparedStatementCommon { protected $conn; protected $limit = 0; protected $offset = 0; protected $sql; protected $sql_cache; protected $sql_cache_valid = false; protected $positions; protected $positionsCount; protected $boundInVars = array(); protected $resultSet; protected $updateCount; public function __construct(Connection $conn, $sql) { $this->conn = $conn; $this->sql = $sql; $this->positions = $this->parseQuery ( $sql ); $this->positionsCount = count ( $this->positions ); } protected function parseQuery ( $sql ) { $positions = array(); if ( preg_match_all ( '([\?]|[\']|[\"]|[\\\])', $sql, $matches, PREG_OFFSET_CAPTURE ) !== 0 ) { $matches = $matches['0']; $open = NULL; for ( $i = 0, $j = count ( $matches ); $i < $j; $i++ ) { switch ( $matches[$i]['0'] ) { case $open: $open = NULL; break; case '"': case "'": $open = $matches[$i]['0']; break; case '\\': $next_match = $matches[$i+1]['0']; if ( $next_match === '"' || $next_match === "'" ) { $i++; } unset ( $next_match ); break; default: if ( $open === NULL ) { $positions[] = $matches[$i]['1']; } } unset ( $matches[$i] ); } unset ( $open, $matches, $i, $j ); } return $positions; } public function setLimit($v) { $this->limit = (int) $v; } public function getLimit() { return $this->limit; } public function setOffset($v) { $this->offset = (int) $v; } public function getOffset() { return $this->offset; } public function getResultSet() { return $this->resultSet; } public function getUpdateCount() { return $this->updateCount; } public function getMoreResults() { if ($this->resultSet) $this->resultSet->close(); $this->resultSet = null; return false; } public function getConnection() { return $this->conn; } public function getResource() { return null; } public function close() { } protected function replaceParams() { if ( $this->sql_cache_valid === true ) { return $this->sql_cache; } $sql = ''; $last_position = 0; for ($position = 0; $position < $this->positionsCount; $position++) { if (!isset($this->boundInVars[$position + 1])) { throw new SQLException('Replace params: undefined query param: ' . ($position + 1)); } $param_value = $this->boundInVars[$position + 1]; $str_param_value = ''; if( is_float( $param_value ) ) { $str_param_value .= $param_value; $str_param_value = str_replace(',', '.', $str_param_value); } else { $str_param_value .= $param_value; } $current_position = $this->positions[$position]; $sql .= substr($this->sql, $last_position, $current_position - $last_position); $sql .= $str_param_value; $last_position = $current_position + 1; } $sql .= substr($this->sql, $last_position); if ( strlen ( $sql ) > 2048 ) { $this->sql_cache = $sql; $this->sql_cache_valid = true; return $this->sql_cache; } else { return $sql; } } public function executeQuery($p1 = null, $fetchmode = null) { $params = null; if ($fetchmode !== null) { $params = $p1; } elseif ($p1 !== null) { if (is_array($p1)) $params = $p1; else $fetchmode = $p1; } foreach ( (array) $params as $i=>$param ) { $this->set ( $i + 1, $param ); unset ( $i, $param ); } unset ( $params ); $this->updateCount = null; $sql = $this->replaceParams(); if ($this->limit > 0 || $this->offset > 0) { $this->conn->applyLimit($sql, $this->offset, $this->limit); } $this->resultSet = $this->conn->executeQuery($sql, $fetchmode); return $this->resultSet; } public function executeUpdate($params = null) { foreach ( (array) $params as $i=>$param ) { $this->set ( $i + 1, $param ); unset ( $i, $param ); } unset ( $params ); if($this->resultSet) $this->resultSet->close(); $this->resultSet = null; $sql = $this->replaceParams(); $this->updateCount = $this->conn->executeUpdate($sql); return $this->updateCount; } abstract protected function escape($str); function set($paramIndex, $value) { $type = gettype($value); if ($type == "object") { if (is_a($value, 'Blob')) { $this->setBlob($paramIndex, $value); } elseif (is_a($value, 'Clob')) { $this->setClob($paramIndex, $value); } elseif (is_a($value, 'Date')) { $this->setTimestamp($paramIndex, $value); } else { throw new SQLException("Unsupported object type passed to set(): " . get_class($value)); } } else { switch ( $type ) { case 'integer': $type = 'int'; break; case 'double': $type = 'float'; break; } $setter = 'set' . ucfirst($type); if ( method_exists ( $this, $setter ) ) { $this->$setter($paramIndex, $value); } else { throw new SQLException ( "Unsupported datatype passed to set(): " . $type ); } } } function setArray($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { $value = serialize( $value ); $this->setString( $paramIndex, $value ); } } function setBoolean($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { $this->boundInVars[$paramIndex] = (int) $value; } } function setBlob($paramIndex, $blob) { $this->sql_cache_valid = false; if ($blob === null) { $this->setNull($paramIndex); } else { if (is_object($blob)) { $this->boundInVars[$paramIndex] = "'" . $this->escape($blob->__toString()) . "'"; } else { $this->boundInVars[$paramIndex] = "'" . $this->escape($blob) . "'"; } } } function setClob($paramIndex, $clob) { $this->sql_cache_valid = false; if ($clob === null) { $this->setNull($paramIndex); } else { if (is_object($clob)) { $this->boundInVars[$paramIndex] = "'" . $this->escape($clob->__toString()) . "'"; } else { $this->boundInVars[$paramIndex] = "'" . $this->escape($clob) . "'"; } } } function setDate($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date("Y-m-d", $value); elseif (is_object($value)) $value = date("Y-m-d", $value->getTime()); $this->setString( $paramIndex, $value ); } } function setDecimal($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { $this->boundInVars[$paramIndex] = (float) $value; } } function setDouble($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { $this->boundInVars[$paramIndex] = (double) $value; } } function setFloat($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { $this->boundInVars[$paramIndex] = (float) $value; } } function setInt($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { $this->boundInVars[$paramIndex] = (int) $value; } } function setInteger($paramIndex, $value) { $this->sql_cache_valid = false; $this->setInt($paramIndex, $value); } function setNull($paramIndex) { $this->sql_cache_valid = false; $this->boundInVars[$paramIndex] = 'NULL'; } function setString($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { if ( is_object ( $value ) ) { $this->boundInVars[$paramIndex] = "'" . $this->escape($value->__toString()) . "'"; } else { $this->boundInVars[$paramIndex] = "'" . $this->escape((string)$value) . "'"; } } } function setTime($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { if ( is_numeric ( $value ) ) { $value = date ('H:i:s', $value ); } elseif ( is_object ( $value ) ) { $value = date ('H:i:s', $value->getTime ( ) ); } $this->setString( $paramIndex, $value ); } } function setTimestamp($paramIndex, $value) { $this->sql_cache_valid = false; if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date('Y-m-d H:i:s', $value); elseif (is_object($value)) $value = date('Y-m-d H:i:s', $value->getTime()); $this->setString( $paramIndex, $value ); } } }   class PrimaryKeyInfo { private $name; private $columns = array(); private $vendorSpecificInfo = array(); function __construct($name, $vendorInfo = array()) { $this->name = $name; $this->vendorSpecificInfo = $vendorInfo; } public function getName() { return $this->name; } public function addColumn($column) { $this->columns[] = $column; } public function getColumns() { return $this->columns; } public function getVendorSpecificInfo() { return $this->vendorSpecificInfo; } public function toString() { return $this->name; } }   class Record { const ZOMBIE = -1; const UNKNOWN = 0; const INSERT = 1; const UPDATE = 2; const DELETE = 3; const BEFOREINSERT = 4; const AFTERINSERT = 5; const BEFOREUPDATE = 6; const AFTERUPDATE = 7; const BEFOREDELETE = 8; const AFTERDELETE = 9; private $values = array(); private $dirtyCols = array(); private $ds; private $saveType = 0; function __construct(DataSet $ds, $addRecord = false) { $this->setParentDataSet($ds); if (!$addRecord) { $this->createValues($this->ds->resultSet()); } } private function initializeRecord() { $this->values = array(); $this->dirtyCols = array(); $this->setSaveType(Record::UNKNOWN); } private function createValues(ResultSet $rs) { $this->values = $rs->getRow(); } public function delete(Connection $conn = null) { $this->setSaveType(DELETE); $this->save($conn); } public function save(Connection $conn = null) { $returnValue = false; if ($this->ds instanceof QueryDataSet) { throw new DataSetException("You cannot save a QueryDataSet. Please use a TableDataSet instead."); } if (!$this->needsToBeSaved()) { return $returnValue; } switch($this->saveType) { case Record::INSERT: $returnValue = $this->doInsert($conn); break; case Record::UPDATE: $returnValue = $this->doUpdate($conn); break; case Record::DELETE: $returnValue = $this->doDelete($conn); break; default: throw new DataSetException("Invalid or no-action saveType for Record."); } return (boolean) $returnValue; } private function doDelete(Connection $conn = null) { if ($conn === null) { $conn = $this->ds->connection(); } $table = $this->ds->tableInfo(); $stmt = null; try { $stmt = $conn->prepareStatement($this->getDeleteSql()); $ps = 1; $kd = $this->ds->keydef(); for ($i = 1, $kdsize = $kd->size(); $i <= $kdsize; $i++) { $col = $kd->getAttrib($i); $val = $this->getValue($col); $setter = 'set' . CreoleTypes::getAffix( $table->getColumn($col)->getType() ); $stmt->$setter($ps++, $val); } $ret = $stmt->executeUpdate(); $this->setSaveType(Record::ZOMBIE); $stmt->close(); if ($ret > 1) { throw new SQLException("There were " . $ret . " rows deleted with this records key value."); } return $ret; } catch (SQLException $e) { if ($stmt) $stmt->close(); throw $e; } } private function doUpdate(Connection $conn = null) { if ($conn === null) { $conn = $this->ds->connection(); } $table = $this->ds->tableInfo(); $stmt = null; try { $stmt = $conn->prepareStatement($this->getUpdateSql()); $ps = 1; foreach($this->dirtyColumns() as $col) { $setter = 'set' . CreoleTypes::getAffix( $table->getColumn($col)->getType() ); $stmt->$setter($ps++, $this->getValue($col)); } $kd = $this->ds->keydef(); for ($i = 1, $kdsize = $kd->size(); $i <= $kdsize; $i++) { $attrib = $kd->getAttrib($i); $setter = 'set' . CreoleTypes::getAffix( $table->getColumn($attrib)->getType() ); $stmt->$setter($ps++, $this->getValue($attrib)); } $ret = $stmt->executeUpdate(); if ($this->ds->refreshOnSave()) { $this->refresh(); } else { $this->markRecordClean(); } $this->setSaveType(Record::AFTERUPDATE); if ($ret > 1) { throw new SQLException ("There were " . $ret . " rows updated with this records key value."); } return $ret; } catch (SQLException $e) { if ($stmt) $stmt->close(); throw $e; } } private function doInsert(Connection $conn = null) { $stmt = null; try { $stmt = $conn->prepareStatement($this->getInsertSql()); $ps = 1; foreach($this->dirtyColumns() as $col) { $val = $this->getValue($col); $setter = 'set' . CreoleTypes::getAffix( $table->getColumn($col)->getType() ); $stmt->$setter($ps++, $val); } $ret = $stmt->executeUpdate(); if ($this->ds->refreshOnSave()) { $this->refresh(); } else { $this->markRecordClean(); } $this->setSaveType(Record::AFTERINSERT); if ($ret > 1) { throw new SQLException ("There were " . $ret . " rows inserted with this records key value."); } return $ret; } catch (SQLException $e) { if ($stmt) $stmt->close(); throw $e; } } private function getUpdateSql() { $kd = $this->ds->keydef(); if ($kd === null || $kd->size() === 0) { throw new DataSetException("You must specify KeyDef attributes for this TableDataSet in order to create a Record for update."); } elseif ($this->recordIsClean()) { throw new DataSetException ("You must Record->setValue() on a column before doing an update."); } $set_sql = ""; $where_sql = ""; $comma = false; foreach($this->dirtyColumns() as $col) { if (!$comma) { $set_sql .= $col . " = ?"; $comma = true; } else { $set_sql .= ", " . $col . " = ?"; } } $comma = false; for ($i = 1, $kdsize = $kd->size(); $i <= $kdsize; $i++) { $attrib = $kd->getAttrib($i); if (! $this->valueIsClean ($attrib)) { throw new DataSetException ("The value for column '" . $attrib . "' is a key value and cannot be updated."); } if (!$comma) { $where_sql .= $attrib . " = ?"; $comma = true; } else { $where_sql .= " AND " . $attrib . " = ?"; } } return "UPDATE " . $this->ds->tableName() . " SET " . $set_sql . " WHERE " . $where_sql; } private function getDeleteSql() { $kd = $this->ds->keydef(); if ($kd === null || $kd->size() === 0) { throw new DataSetException("You must specify KeyDef attributes for this TableDataSet in order to delete a Record."); } $where_sql = ""; $comma = false; for ($i = 1, $kdsize = $kd->size(); $i <= $kdsize; $i++) { if (!$comma) { $where_sql .= $kd->getAttrib($i) . " = ?"; $comma = true; } else { $where_sql .= " AND " . $kd->getAttrib($i) . " = ?"; } } return "DELETE FROM " . $this->ds->tableName() . " WHERE " . $where_sql; } private function getInsertSql() { $fields_sql = ""; $values_sql = ""; $comma = false; foreach($this->dirtyColumns() as $col) { if (!$comma) { $fields_sql .= $col; $values_sql .= "?"; $comma = true; } else { $fields_sql .= ", " . $col; $values_sql .= ", ?"; } } return "INSERT INTO " . $this->ds->tableName() . " ( " . $fields_sql . " ) VALUES ( " . $values_sql . " )"; } public function getValue($col) { if (!isset($this->values[$col])) { throw new DataSetException("Undefined column in Record: " . $col); } return $this->values[$col]; } public function columns() { return array_keys($this->values); } private function dirtyColumns() { return array_keys($this->dirtyCols); } public function size() { return count($this->values); } public function toBeSavedWithInsert() { return ($this->saveType === Record::INSERT); } public function toBeSavedWithUpdate() { return ($this->saveType === Record::UPDATE); } public function toBeSavedWithDelete() { return ($this->saveType === Record::DELETE); } public function markRecordClean() { $this->dirtyCols = array(); } public function markForInsert() { if ($this->ds instanceof QueryDataSet) { throw new DataSetException ("You cannot mark a record in a QueryDataSet for insert"); } $this->setSaveType(Record::INSERT); } public function markForUpdate() { if ($this->ds instanceof QueryDataSet) { throw new DataSetException ("You cannot mark a record in a QueryDataSet for update"); } $this->setSaveType(Record::UPDATE); } public function markToBeDeleted() { if ($this->ds instanceof QueryDataSet) { throw new DataSetException ("You cannot mark a record in a QueryDataSet for deletion"); } $this->setSaveType(Record::DELETE); } public function unmarkToBeDeleted() { if ($this->saveType === Record::ZOMBIE) { throw new DataSetException ("This record has already been deleted!"); } $this->setSaveType(UNKNOWN); } public function markValueClean($col) { unset($this->dirtyCols[$col]); } public function markValueDirty($col) { $this->dirtyCols[$col] = true; } public function setSaveType($type) { $this->saveType = $type; } public function getSaveType() { return $this->saveType; } public function setValue ($col, $value) { $this->values[$col] = $value; $this->markValueDirty($col); return $this; } public function isAZombie() { return ($this->saveType === Record::ZOMBIE); } public function needsToBeSaved() { return (!$this->isAZombie() || !$this->recordIsClean() || $this->toBeSavedWithUpdate() || $this->toBeSavedWithDelete() || $this->toBeSavedWithInsert()); } public function valueIsClean($column) { if (!isset($this->values[$column])) { throw new DataSetException("Undefined column: ".$column); } return !isset($this->dirtyCols[$column]); } public function recordIsClean() { return empty($this->dirtyCols); } public function refresh(Connection $conn = null) { if ($conn === null) { $conn = $this->ds->connection(); } if ($this->toBeSavedWithDelete()) { return; } elseif ($this->toBeSavedWithInsert()) { throw new DataSetException("There is no way to refresh a record which has been created with addRecord()."); } elseif ($this->ds instanceof QueryDataSet) { throw new DataSetException ("You can only perform a refresh on Records created with a TableDataSet."); } $stmt = null; try { $stmt = $conn->prepareStatement ($this->getRefreshSql()); $ps = 1; $kd = $this->ds->keydef(); for ($i = 1, $kdsize = $kd->size(); $i <= $kdsize; $i++) { $val = $this->getValue($kd->getAttrib($i)); if ($val == null) { throw new DataSetException ("You cannot execute an update with a null value for a KeyDef."); } $setter = 'set' . CreoleTypes::getAffix( $table->getColumn($col)->getType() ); $stmt->$setter($ps++, $val); } $rs = $stmt->executeQuery(); $rs->next(); $this->initializeRecord(); $this->createValues($rs); } catch (SQLException $e) { if ($stmt) $stmt->close(); throw $e; } } public function getRefreshSql() { if ($this->ds->keydef() === null || $this->ds->keydef()->size() === 0) { throw new DataSetException("You can only perform a getRefreshQueryString on a TableDataSet that was created with a KeyDef."); } elseif ($this->ds instanceof QueryDataSet) { throw new DataSetException("You can only perform a getRefreshQueryString on Records created with a TableDataSet."); } $sql1 = ""; $sql2 = ""; $comma = false; foreach($this->columns() as $col) { if (!$comma) { $attribs_sql .= $col; $comma = true; } else { $attribs_sql .= ", " . $col; } } $comma = false; for ($i = 1, $kdsize = $kd->size(); $i <= $kdsize; $i++) { $attrib = $kd->getAttrib($i); if (!$this->valueIsClean($attrib)) { throw new DataSetException ( "You cannot do a refresh from the database if the value " . "for a KeyDef column has been changed with a Record.setValue()."); } if (!$comma) { $where_sql .= $attrib . " = ?"; $comma = true; } else { $where_sql .= " AND " . $attrib . " = ?"; } } return "SELECT " . $attribs_sql . " FROM " . $this->ds->tableName() . " WHERE " . $where_sql; } public function dataset() { return $this->ds; } public function setParentDataSet(DataSet $ds) { $this->ds = $ds; } public function __toString() { $sb = "{"; foreach($this->columns() as $col) { $sb .= "'" . $this->getValue($col) . "',"; } $sb = substr($sb, 0, -1); $sb .= "}"; return $sb; } }   interface ResultSet extends IteratorAggregate { const FETCHMODE_ASSOC = 1; const FETCHMODE_NUM = 2; public function getResource(); public function setFetchmode($mode); public function getFetchmode(); public function isLowerAssocCase(); public function next(); public function previous(); public function relative($offset); public function absolute($pos); public function seek($rownum); public function first(); public function last(); public function beforeFirst(); public function afterLast(); public function isAfterLast(); public function isBeforeFirst(); public function getCursorPos(); public function getRow(); public function getRecordCount(); public function close(); public function get($column); public function getArray($column); public function getBoolean($column); public function getBlob($column); public function getClob($column); public function getDate($column, $format = '%x'); public function getFloat($column); public function getInt($column); public function getString($column); public function getTime($column, $format = '%X'); public function getTimestamp($column, $format = 'Y-m-d H:i:s'); }   class ResultSetIterator implements Iterator { private $rs; public function __construct(ResultSet $rs) { $this->rs = $rs; } function rewind() { if (!$this->rs->isBeforeFirst()) { $this->rs->seek(0); } } function valid() { return $this->rs->next(); } function key() { return $this->rs->getCursorPos(); } function current() { return $this->rs->getRow(); } function next() { } }   class SQLException extends Exception { protected $userInfo; protected $nativeError; public function __construct($msg, $native = null, $userinfo = null) { parent::__construct($msg); if ($native !== null) { $this->setNativeError($native); } if ($userinfo !== null) { $this->setUserInfo($userinfo); } } public function setUserInfo($info) { $this->userInfo = $info; $this->message .= " [User Info: " .$this->userInfo . "]"; } public function getUserInfo() { return $this->userInfo; } public function setNativeError($msg) { $this->nativeError = $msg; $this->message .= " [Native Error: " .$this->nativeError . "]"; } public function getNativeError() { return $this->nativeError; } public function toString() { return $this->getMessage(); } }   class SQLiteResultSetIterator implements Iterator { private $result; private $pos = 0; private $fetchmode; private $row_count; public function __construct(SQLiteResultSet $rs) { $this->result = $rs->getResource(); $this->fetchmode = $rs->getFetchmode(); $this->row_count = $rs->getRecordCount(); } function rewind() { sqlite_rewind($this->result); } function valid() { return ( $this->pos < $this->row_count ); } function key() { return $this->pos; } function current() { return sqlite_fetch_array($this->result, $this->fetchmode); } function next() { $this->pos++; } }   class SQLStatementExtractor { protected static $delimiter = ';'; protected static $in_quote = false; protected static $bc_nest = 0; protected static $iBegEndNest = 0; public static function extractFile($filename) { $buffer = file_get_contents($filename); if ($buffer === false) { throw new Exception("Unable to read file: " . $filename); } return self::extractStatements(self::getLines($buffer)); } public static function extract($buffer) { return self::extractStatements(self::getLines($buffer)); } protected static function extractStatements($lines) { $statements = array(); $sql = ""; foreach($lines as $line) { $line = trim($line); if (self::startsWith("//", $line) || self::startsWith("--", $line) || self::startsWith("#", $line)) { continue; } if (strlen($line) > 4 && strtoupper(substr($line,0, 4)) == "REM ") { continue; } $bc_start_num = count(explode('/*', $line)) - 1; $bc_end_num = count(explode('*/', $line)) - 1; self::$bc_nest = self::$bc_nest + ($bc_start_num - $bc_end_num); $bc_first = strpos($line, '/*'); $bc_last = strrpos($line, '*/'); if( preg_match('/BEGIN$/', strtoupper($line)) ) { self::$iBegEndNest++; } if( preg_match('/^END;/', strtoupper($line)) ) { self::$iBegEndNest--; } $comment_position = strpos($line, "--"); if( self::$bc_nest > 0 || ($bc_first < $comment_position && $bc_last > $comment_position ) ) { $comment_position = false; } if ( $comment_position !== false) { $comment = self::substring($line, $comment_position); $line = self::substring($line, 0, $comment_position - 1); } else { $comment = ''; } $sql .= " " . $line; $sql = trim($sql); $quote_count = preg_match_all("#^'|[^\\\\]'#", $line, $matches); $es_count = count(explode("''", $line)) - 1; $quote_count = $quote_count - $es_count; $odd_quotes = $quote_count % 2 == 0 ? false : true; if ( self::$in_quote == true && $odd_quotes == false ) { continue; } elseif ( self::$in_quote == true && $odd_quotes == true ) { self::$in_quote = false; } elseif ( self::$in_quote == false && $odd_quotes == true ) { self::$in_quote = true; } if (self::$iBegEndNest == 0 && self::endsWith(self::$delimiter, $sql)) { $statements[] = self::substring($sql, 0, strlen($sql)-1 - strlen(self::$delimiter)); if( $comment != '' ) { $statements[] = $comment; } $sql = ""; } } return $statements; } protected static function startsWith($check, $string) { if ($check === "" || $check === $string) { return true; } else { return (strpos($string, $check) === 0) ? true : false; } } protected static function endsWith($check, $string) { if ($check === "" || $check === $string) { return true; } else { return (strpos(strrev($string), strrev($check)) === 0) ? true : false; } } protected static function substring($string, $startpos, $endpos = -1) { $len = strlen($string); $endpos = (int) (($endpos === -1) ? $len-1 : $endpos); if ($startpos > $len-1 || $startpos < 0) { trigger_error("substring(), Startindex out of bounds must be 0<n<$len", E_USER_ERROR); } if ($endpos > $len-1 || $endpos < $startpos) { trigger_error("substring(), Endindex out of bounds must be $startpos<n<".($len-1), E_USER_ERROR); } if ($startpos === $endpos) { return (string) $string{$startpos}; } else { $len = $endpos-$startpos; } return substr($string, $startpos, $len+1); } protected static function getLines($buffer) { $lines = preg_split("/\r?\n|\r/", $buffer); return $lines; } }   interface Statement { public function setLimit($v); public function getLimit(); public function setOffset($v); public function getOffset(); public function close(); public function execute($sql, $fetchmode = null); public function getResultSet(); public function getUpdateCount(); public function executeQuery($sql, $fetchmode = null); public function executeUpdate($sql); public function getMoreResults(); public function getConnection(); }   abstract class StatementCommon { protected $conn; protected $resultSet; protected $updateCount; protected $warnings = array(); protected $resultClass; protected $stmt; protected $limit = 0; protected $offset = 0; function __construct(Connection $conn) { $this->conn = $conn; } public function setLimit($v) { $this->limit = (int) $v; } public function getLimit() { return $this->limit; } public function setOffset($v) { $this->offset = (int) $v; } public function getOffset() { return $this->offset; } public function close() { } public function execute($sql, $fetchmode = null) { if (!$this->isSelect($sql)) { $this->updateCount = $this->executeUpdate($sql); return false; } else { $this->resultSet = $this->executeQuery($sql, $fetchmode); if ($this->resultSet->getRecordCount() === 0) { return false; } return true; } } public function getResultSet() { return $this->resultSet; } public function getUpdateCount() { return $this->updateCount; } protected function isSelect($sql) { $sql = trim($sql); return (stripos($sql, 'select') === 0 && stripos($sql, 'select into ') !== 0); } public function executeQuery($sql, $fetchmode = null) { $this->updateCount = null; if ($this->limit > 0 || $this->offset > 0) { $this->conn->applyLimit($sql, $this->offset, $this->limit); } $this->resultSet = $this->conn->executeQuery($sql, $fetchmode); return $this->resultSet; } public function executeUpdate($sql) { if ($this->resultSet) $this->resultSet->close(); $this->resultSet = null; $this->updateCount = $this->conn->executeUpdate($sql); return $this->updateCount; } public function getMoreResults() { if ($this->resultSet) $this->resultSet->close(); $this->resultSet = null; return false; } public function getConnection() { return $this->conn; } }   abstract class TableInfo { protected $name; protected $columns = array(); protected $foreignKeys = array(); protected $indexes = array(); protected $primaryKey; protected $pkLoaded = false; protected $fksLoaded = false; protected $indexesLoaded = false; protected $colsLoaded = false; protected $vendorLoaded = false; protected $vendorSpecificInfo = array(); protected $conn; protected $database; protected $dblink; protected $dbname; function __construct(DatabaseInfo $database, $name) { $this->database = $database; $this->name = $name; $this->conn = $database->getConnection(); $this->dblink = $this->conn->getResource(); $this->dbname = $database->getName(); } function __sleep() { return array('name', 'columns', 'foreignKeys', 'indexes', 'primaryKey'); } function __wakeup() { foreach($this->columns as $col) { $col->table = $this; } } abstract protected function initColumns(); abstract protected function initPrimaryKey(); abstract protected function initForeignKeys(); abstract protected function initIndexes(); protected function initVendorSpecificInfo(){} public function getPrimaryKey() { if(!$this->pkLoaded) $this->initPrimaryKey(); return $this->primaryKey; } public function getColumn($name) { if(!$this->colsLoaded) $this->initColumns(); if (!isset($this->columns[$name])) { throw new SQLException("Table `".$this->name."` has no column `".$name."`"); } return $this->columns[$name]; } public function hasColumn($name) { if(!$this->colsLoaded) $this->initColumns(); return isset($this->columns[$name]); } public function getColumns() { if(!$this->colsLoaded) $this->initColumns(); return array_values($this->columns); } public function getForeignKey($name) { if(!$this->fksLoaded) $this->initForeignKeys(); if (!isset($this->foreignKeys[$name])) { throw new SQLException("Table `".$this->name."` has no foreign key `".$name."`"); } return $this->foreignKeys[$name]; } public function getForeignKeys() { if(!$this->fksLoaded) $this->initForeignKeys(); return array_values($this->foreignKeys); } public function getIndex($name) { if(!$this->indexesLoaded) $this->initIndexes(); if (!isset($this->indexes[$name])) { throw new SQLException("Table `".$this->name."` has no index `".$name."`"); } return $this->indexes[$name]; } public function getIndexes() { if(!$this->indexesLoaded) $this->initIndexes(); return array_values($this->indexes); } public function getIndices() { return $this->getIndexes(); } public function getName() { return $this->name; } public function toString() { return $this->name; } public function foreignKeysLoaded() { return $this->fksLoaded; } public function primaryKeyLoaded() { return $this->pkLoaded; } public function columnsLoaded() { return $this->colsLoaded; } public function indexesLoaded() { return $this->indexesLoaded; } public function getVendorSpecificInfo() { if(!$this->vendorLoaded) $this->initVendorSpecificInfo(); return $this->vendorSpecificInfo; } public function addColumn(ColumnInfo $column) { $this->columns[$column->getName()] = $column; } public function getDatabase() { return $this->database; } }   class Blob extends Lob { function dump() { if (!$this->data) { if ($this->inFile) { $fp = @fopen($this->inFile, "rb"); if (!$fp) { throw new Exception('Unable to open file: '.$this->inFile); } fpassthru($fp); @fclose($fp); } else { throw new Exception('No data to dump'); } } else { echo $this->data; } } }   class Clob extends Lob { public function readFromFile($file = null) { if ($file !== null) { $this->setInputFile($file); } if (!$this->inFile) { throw new Exception('No file specified for read.'); } $data = null; $file = fopen($this->inFile, "rt"); while (!feof($file)) $data .= fgets($file, 4096); fclose($file); if ($data === false) { throw new Exception('Unable to read from file: '.$this->inFile); } $this->setContents($data); } public function writeToFile($file = null) { if ($file !== null) { $this->setOutputFile($file); } if (!$this->outFile) { throw new Exception('No file specified for write'); } if ($this->data === null) { throw new Exception('No data to write to file'); } $fp = fopen($this->outFile, "wt"); if (fputs($fp, $this->data) === false) throw new Exception('Unable to write to file: '.$this->outFile); fclose($fp); } function dump() { if (!$this->data) { if ($this->inFile) { $fp = @fopen($this->inFile, "r"); if (!$fp) { throw new Exception('Unable to open file: '.$this->inFile); } fpassthru($fp); @fclose($fp); } else { throw new Exception('No data to dump'); } } else { echo $this->data; } } }   abstract class DataSet implements IteratorAggregate { const ALL_RECORDS = 0; protected $records; protected $conn; protected $allRecordsRetrieved = false; protected $recordRetrievedCount = 0; protected $lastFetchSize = 0; protected $totalFetchCount = 0; protected $columns; protected $selectSql; protected $keyDef; protected $resultSet; protected $stmt; public function getIterator() { $it = new DataSetIterator($this); return $it; } public function resultSet() { if ($this->resultSet === null) { throw new DataSetException ("ResultSet is null."); } return $this->resultSet; } public function allRecordsRetrieved() { return $this->allRecordsRetrieved; } function setAllRecordsRetrieved($set) { $this->allRecordsRetrieved = $set; } public function removeRecord(Record $rec) { $loc = array_search($rec, $this->records, true); $removeRec = array_splice($this->records, $loc, 1); return $removeRec; } public function clearRecords() { $this->records = null; return $this; } public function releaseRecords() { $this->records = null; $this->recordRetrievedCount = 0; $this->lastFetchSize = 0; $this->setAllRecordsRetrieved(false); return $this; } public function close() { $this->releaseRecords(); $this->schema = null; if ($this->resultSet !== null && !$this instanceof QueryDataSet) { $this->resultSet->close(); } $this->resultSet = null; if ( $this->stmt !== null ) { $this->stmt->close(); } $this->conn = null; } public function reset() { if (! ($this->resultSet !== null && ($this instanceof QueryDataSet))) { return $this->releaseRecords(); } else { throw new DataSetException("You cannot call reset() on a QueryDataSet."); } } public function connection() { return $this->conn; } public function schema() { return $this->schema; } public function getRecord($pos) { if ($this->containsRecord($pos)) { $rec = $this->records[$pos]; if ($this instanceof TableDataSet) { $rec->markForUpdate(); } $this->recordRetrievedCount++; return $rec; } throw new DataSetException ("Record not found at index: " . $pos); } public function findRecord($pos) { if ($this->containsRecord($pos)) { return $this->records[$pos]; } throw new DataSetException ("Record not found at index: " . $pos); } public function containsRecord($pos) { return (isset($this->records[$pos])); } public function fetchRecords($p1 = 0, $p2 = null) { if ($p2 !== null) { $start = $p1; $max = $p2; } else { $start = 0; $max = $p1; } if ($this->lastFetchSize() > 0 && $this->records !== null) { throw new DataSetException("You must call DataSet::clearRecords() before executing DataSet::fetchRecords() again!"); } try { if ($this->stmt === null && $this->resultSet === null) { $this->stmt = $this->conn->createStatement(); $this->stmt->setOffset($start); $this->stmt->setLimit($max); $start = 0; $max = 0; $this->resultSet = $this->stmt->executeQuery($this->selectSql); } if ($this->resultSet !== null) { $this->records = array(); $startCounter = 0; $fetchCount = 0; while (! $this->allRecordsRetrieved() ) { if ($this->resultSet->next()) { if ($startCounter >= $start) { $this->records[] = new Record($this); $fetchCount++; if ($fetchCount === $max) { break; } } else { $startCounter++; } } else { $this->setAllRecordsRetrieved(true); break; } } $this->lastFetchSize = $fetchCount; } } catch (SQLException $e) { if ($this->stmt) $this->stmt->close(); throw $e; } return $this; } public function lastFetchSize() { return $this->lastFetchSize; } public function keydef() { return $this->keyDef; } public function __toString() { $sb = ""; for ($i = 0, $size = $this->size(); $i < $size; $i++) { $sb .= $this->getRecord($i); } return $sb; } public abstract function getSelectSql(); public function getColumns() { return $this->columns; } public function size() { if ( $this->records === null ) return 0; return count($this->records); } } class DataSetIterator implements Iterator { private $ds; private $size; private $pos; function __construct(DataSet $ds) { $this->ds = $ds; $this->size = $ds->size(); } function rewind() { $this->pos = 0; } function valid() { return $this->pos < $this->size; } function key() { return $this->pos; } function current() { return $this->ds->getRecord($this->pos); } function next() { $this->pos++; } }   class DebugConnection implements Connection { private $childConnection = null; private $numQueriesExecuted = 0; private $lastExecutedQuery = ''; private $logger; public function setLogger($logger) { $this->logger = $logger; } public function getNumQueriesExecuted() { return $this->numQueriesExecuted; } public function getLastExecutedQuery() { return $this->lastExecutedQuery; } public function connect($dsninfo, $flags = 0) { if (!($driver = Creole::getDriver($dsninfo['phptype']))) { throw new SQLException("No driver has been registered to handle connection type: $type"); } $connectionClass = Creole::import($driver); $this->childConnection = new $connectionClass(); $this->log("connect(): DSN: ". var_export($dsninfo, true) . ", FLAGS: " . var_export($flags, true)); return $this->childConnection->connect($dsninfo, $flags); } public function getDatabaseInfo() { return $this->childConnection->getDatabaseInfo(); } public function getIdGenerator() { return $this->childConnection->getIdGenerator(); } public function isConnected() { return $this->childConnection->isConnected(); } public function prepareStatement($sql) { $this->log("prepareStatement(): $sql"); $obj = $this->childConnection->prepareStatement($sql); $objClass = get_class($obj); return new $objClass($this, $sql); } public function createStatement() { $obj = $this->childConnection->createStatement(); $objClass = get_class($obj); return new $objClass($this); } public function applyLimit(&$sql, $offset, $limit) { $this->log("applyLimit(): $sql, offset: $offset, limit: $limit"); return $this->childConnection->applyLimit($sql, $offset, $limit); } public function close() { $this->log("close(): Closing connection."); return $this->childConnection->close(); } public function executeQuery($sql, $fetchmode = null) { $this->log("executeQuery(): $sql"); $this->lastExecutedQuery = $sql; $this->numQueriesExecuted++; return $this->childConnection->executeQuery($sql, $fetchmode); } public function executeUpdate($sql) { $this->log("executeUpdate(): $sql"); $this->lastExecutedQuery = $sql; $this->numQueriesExecuted++; return $this->childConnection->executeUpdate($sql); } public function getUpdateCount() { return $this->childConnection->getUpdateCount(); } public function prepareCall($sql) { $this->log("prepareCall(): $sql"); return $this->childConnection->prepareCall($sql); } public function getResource() { return $this->childConnection->getResource(); } public function getDSN() { return $this->childConnection->getDSN(); } public function getFlags() { return $this->childConnection->getFlags(); } public function begin() { $this->log("Beginning transaction."); return $this->childConnection->begin(); } public function commit() { $this->log("Committing transaction."); return $this->childConnection->commit(); } public function rollback() { $this->log("Rolling back transaction."); return $this->childConnection->rollback(); } public function setAutoCommit($bit) { $this->log("Setting autocommit to: " . var_export($bit, true)); return $this->childConnection->setAutoCommit($bit); } public function getAutoCommit() { return $this->childConnection->getAutoCommit(); } private function log($msg) { if ($this->logger) { $this->logger->log($msg); } } }   class MSSQLIdGenerator implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return false; } public function isAfterInsert() { return true; } public function getIdMethod() { return self::AUTOINCREMENT; } public function getId($unused = null) { $rs = $this->conn->executeQuery("SELECT SCOPE_IDENTITY()", ResultSet::FETCHMODE_NUM); $rs->next(); return $rs->getInt(1); } }   class MSSQLPreparedStatement extends PreparedStatementCommon implements PreparedStatement { function setBlob($paramIndex, $blob) { $this->sql_cache_valid = false; if ($blob === null) { $this->setNull($paramIndex); } else { if (is_object($blob)) { $blob = $blob->__toString(); } $data = unpack("H*hex", $blob); $this->boundInVars[$paramIndex] = '0x'.$data['hex']; } } protected function escape($subject) { return str_replace("'", "''", $subject); } public function executeQuery($p1 = null, $fetchmode = null) { $params = null; if ($fetchmode !== null) { $params = $p1; } elseif ($p1 !== null) { if (is_array($p1)) $params = $p1; else $fetchmode = $p1; } if ($params) { for($i=0,$cnt=count($params); $i < $cnt; $i++) { $this->set($i+1, $params[$i]); } } $this->updateCount = null; $sql = $this->replaceParams(); if ( $this->offset > 0 || $this->limit > 0 ) { $this->conn->applyLimit( $sql, $this->offset, $this->limit ); } $this->resultSet = $this->conn->executeQuery($sql, $fetchmode); return $this->resultSet; } }   class MSSQLStatement extends StatementCommon implements Statement { public function executeQuery($sql, $fetchmode = null) { $this->updateCount = null; if ( $this->offset > 0 || $this->limit > 0 ) { $this->conn->applyLimit( $sql, $this->offset, $this->limit ); } $this->resultSet = $this->conn->executeQuery($sql, $fetchmode); return $this->resultSet; } public function getMoreResults() { if ($this->resultSet) $this->resultSet->close(); $this->resultSet = null; return false; } }   class MSSQLTypes extends CreoleTypes { private static $typeMap = array ( "binary" => CreoleTypes::BINARY, "bit" => CreoleTypes::BOOLEAN, "char" => CreoleTypes::CHAR, "datetime" => CreoleTypes::TIMESTAMP, "decimal() identity" => CreoleTypes::DECIMAL, "decimal" => CreoleTypes::DECIMAL, "image" => CreoleTypes::LONGVARBINARY, "int" => CreoleTypes::INTEGER, "int identity" => CreoleTypes::INTEGER, "integer" => CreoleTypes::INTEGER, "money" => CreoleTypes::DECIMAL, "nchar" => CreoleTypes::CHAR, "ntext" => CreoleTypes::LONGVARCHAR, "numeric() identity" => CreoleTypes::NUMERIC, "numeric" => CreoleTypes::NUMERIC, "nvarchar" => CreoleTypes::VARCHAR, "real" => CreoleTypes::REAL, "float" => CreoleTypes::FLOAT, "smalldatetime" => CreoleTypes::TIMESTAMP, "smallint" => CreoleTypes::SMALLINT, "smallint identity" => CreoleTypes::SMALLINT, "smallmoney" => CreoleTypes::DECIMAL, "sysname" => CreoleTypes::VARCHAR, "text" => CreoleTypes::LONGVARCHAR, "timestamp" => CreoleTypes::BINARY, "tinyint identity" => CreoleTypes::TINYINT, "tinyint" => CreoleTypes::TINYINT, "uniqueidentifier" => CreoleTypes::CHAR, "varbinary" => CreoleTypes::VARBINARY, "varchar" => CreoleTypes::VARCHAR, "uniqueidentifier" => CreoleTypes::CHAR, "bigint identity" => CreoleTypes::BIGINT, "bigint" => CreoleTypes::BIGINT, "sql_variant" => CreoleTypes::VARCHAR, ); private static $reverseMap = null; public static function getType($mssqlType) { $t = strtolower($mssqlType); if (isset(self::$typeMap[$t])) { return self::$typeMap[$t]; } else { return CreoleTypes::OTHER; } } public static function getNativeType($creoleType) { if (self::$reverseMap === null) { self::$reverseMap = array_flip(self::$typeMap); } return @self::$reverseMap[$creoleType]; } }   class MySQLIdGenerator implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return false; } public function isAfterInsert() { return true; } public function getIdMethod() { return self::AUTOINCREMENT; } public function getId($unused = null) { $insert_id = mysql_insert_id($this->conn->getResource()); if ( $insert_id < 0 ) { $insert_id = null; $result = mysql_query('SELECT LAST_INSERT_ID()', $this->conn->getResource()); if ( $result ) { $row = mysql_fetch_row($result); $insert_id = $row ? $row[0] : null; } } return $insert_id; } }   class MySQLiIdGenerator implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return false; } public function isAfterInsert() { return true; } public function getIdMethod() { return self::AUTOINCREMENT; } public function getId($unused = null) { $resource = $this->conn->getResource(); $insert_id = mysqli_insert_id($resource); if ( $insert_id < 0 ) { $insert_id = null; $result = mysqli_query($resource, 'SELECT LAST_INSERT_ID()'); if ( $result ) { $row = mysqli_fetch_row($result); $insert_id = $row ? $row[0] : null; } } return $insert_id; } }   class MySQLiPreparedStatement extends PreparedStatementCommon implements PreparedStatement { protected function escape($str) { return mysqli_real_escape_string($this->getConnection()->getResource(), $str); } }   class MySQLiStatement extends StatementCommon implements Statement { }   class MySQLPreparedStatement extends PreparedStatementCommon implements PreparedStatement { protected function escape($str) { return mysql_real_escape_string($str, $this->conn->getResource()); } }   class MySQLStatement extends StatementCommon implements Statement { }   class MySQLTypes extends CreoleTypes { private static $typeMap = array( 'tinyint' => CreoleTypes::TINYINT, 'smallint' => CreoleTypes::SMALLINT, 'mediumint' => CreoleTypes::SMALLINT, 'int' => CreoleTypes::INTEGER, 'integer' => CreoleTypes::INTEGER, 'bigint' => CreoleTypes::BIGINT, 'int24' => CreoleTypes::BIGINT, 'real' => CreoleTypes::REAL, 'float' => CreoleTypes::FLOAT, 'decimal' => CreoleTypes::DECIMAL, 'numeric' => CreoleTypes::NUMERIC, 'double' => CreoleTypes::DOUBLE, 'char' => CreoleTypes::CHAR, 'varchar' => CreoleTypes::VARCHAR, 'date' => CreoleTypes::DATE, 'time' => CreoleTypes::TIME, 'year' => CreoleTypes::YEAR, 'datetime' => CreoleTypes::TIMESTAMP, 'timestamp' => CreoleTypes::TIMESTAMP, 'tinyblob' => CreoleTypes::BINARY, 'blob' => CreoleTypes::VARBINARY, 'mediumblob' => CreoleTypes::VARBINARY, 'longblob' => CreoleTypes::VARBINARY, 'longtext' => CreoleTypes::LONGVARCHAR, 'tinytext' => CreoleTypes::VARCHAR, 'mediumtext' => CreoleTypes::LONGVARCHAR, 'text' => CreoleTypes::LONGVARCHAR, 'enum' => CreoleTypes::CHAR, 'set' => CreoleTypes::CHAR, ); private static $reverseMap = null; public static function getType($nativeType) { $t = strtolower($nativeType); if (isset(self::$typeMap[$t])) { return self::$typeMap[$t]; } else { return CreoleTypes::OTHER; } } public static function getNativeType($creoleType) { if (self::$reverseMap === null) { self::$reverseMap = array_flip(self::$typeMap); } return @self::$reverseMap[$creoleType]; } }   class OCI8IdGenerator implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return true; } public function isAfterInsert() { return false; } public function getIdMethod() { return self::SEQUENCE; } public function getId($name = null) { if ($name === null) { throw new SQLException("You must specify the sequence name when calling getId() method."); } $rs = $this->conn->executeQuery("select " . $name . ".nextval from dual", ResultSet::FETCHMODE_NUM); $rs->next(); return $rs->getInt(1); } }   class OCI8Statement extends StatementCommon implements Statement { }   class OCI8Types extends CreoleTypes { private static $typeMap = array( 'char' => CreoleTypes::CHAR, 'varchar2' => CreoleTypes::VARCHAR, 'long' => CreoleTypes::LONGVARCHAR, 'number' => CreoleTypes::NUMERIC, 'float' => CreoleTypes::FLOAT, 'integer' => CreoleTypes::INTEGER, 'smallint' => CreoleTypes::SMALLINT, 'double' => CreoleTypes::DOUBLE, 'raw' => CreoleTypes::VARBINARY, 'longraw' => CreoleTypes::LONGVARBINARY, 'date' => CreoleTypes::DATE, 'timestamp' => CreoleTypes::TIMESTAMP, 'blob' => CreoleTypes::BLOB, 'clob' => CreoleTypes::CLOB, 'varray' => CreoleTypes::ARR, ); private static $reverseMap = null; public static function getType($nativeType) { $t = str_replace(' ', '', strtolower($nativeType)); if ( substr($t, 0, 9) == 'timestamp' ) return CreoleTypes::TIMESTAMP; if (isset(self::$typeMap[$t])) { return self::$typeMap[$t]; } else { return CreoleTypes::OTHER; } } public static function getNativeType($creoleType) { if (self::$reverseMap === null) { self::$reverseMap = array_flip(self::$typeMap); } return @self::$reverseMap[$creoleType]; } }   class ODBCIdGenerator implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return true; } public function isAfterInsert() { return false; } public function getIdMethod() { return self::SEQUENCE; } public function getId($seqname = null) { if ($seqname === null) throw new SQLException('You must specify the sequence name when calling getId() method.'); $triedcreate = false; while (1) { try { $n = $this->conn->executeUpdate("UPDATE $seqname SET id = id + 1", ResultSet::FETCHMODE_NUM); if ($n == 0) throw new SQLException('Failed to update IdGenerator id', $this->conn->nativeError()); $rs = $this->conn->executeQuery("SELECT id FROM $seqname", ResultSet::FETCHMODE_NUM); } catch (SQLException $e) { if ($triedcreate) throw $e; $this->drop($seqname, true); $this->create($seqname); $triedcreate = true; continue; } break; } $rs->first(); return $rs->getInt(1); } public function create($seqname) { $this->conn->executeUpdate("CREATE TABLE $seqname ( id numeric(19,0) NOT NULL )"); $this->conn->executeUpdate("INSERT INTO $seqname ( id ) VALUES ( 0 )"); } public function drop($seqname, $ignoreerrs = false) { try { $this->conn->executeUpdate("DROP TABLE $seqname"); } catch (Exception $e) { if (!$ignoreerrs) throw $e; } } }   class ODBCPreparedStatement extends PreparedStatementCommon implements PreparedStatement { protected function replaceParams() { if ($this->conn->getAdapter()->emulatePrepareStmt()) return parent::replaceParams(); else return $this->sql; } protected function _execute($sql, $params, $fetchmode, $isupdate) { if ($this->resultSet) { $this->resultSet->close(); $this->resultSet = null; } $this->updateCount = null; if ($this->conn->getAdapter()->emulatePrepareStmt()) { $stmt = @odbc_exec($this->conn->getResource(), $sql); $ret = ($stmt !== false); } else { foreach ($this->boundInVars as $idx => $var) { if ($var instanceof Lob) { $file = ($isupdate ? $var->getInputFile() : $var->getOutputFile()); $this->boundInVars[$idx] = "'$file'"; } else if (is_string($var)) { $this->boundInVars[$idx] = trim($var, "\"\'"); } } $stmt = @odbc_prepare($this->conn->getResource(), $sql); if ($stmt === FALSE) throw new SQLException('Could not prepare query', $this->conn->nativeError(), $sql); $ret = @odbc_execute($stmt, $this->boundInVars); } if ($ret === FALSE) { @odbc_free_result($stmt); throw new SQLException('Could not execute query', $this->conn->nativeError(), $sql); } $this->odbcresult = new ODBCResultResource($stmt); return $this->conn->createResultSet($this->odbcresult, $fetchmode); } public function executeQuery() { switch (func_num_args()) { case 2: list($params, $fetchmode) = func_get_args(); if (!is_array($params)) { unset($params); } break; case 1: $params = null; list($fetchmode) = func_get_args(); break; case 0: $params = null; $fetchmode = null; break; } if (isset($params)) { for($i=0,$cnt=count($params); $i < $cnt; $i++) { $this->set($i+1, $params[$i]); } } else { $params = null; } $sql = $this->replaceParams(); if ($this->conn->getAdapter()->hasLimitOffset()) { if ($this->limit > 0 || $this->offset > 0) $this->conn->applyLimit($sql, $this->offset, $this->limit); } $this->resultSet = $this->_execute($sql, $params, $fetchmode, false); if (!$this->conn->getAdapter()->hasLimitOffset()) { $this->resultSet->_setOffset($this->offset); $this->resultSet->_setLimit($this->limit); } return $this->resultSet; } public function executeUpdate($params = null) { if ($params) { for($i=0,$cnt=count($params); $i < $cnt; $i++) { $this->set($i+1, $params[$i]); } } $sql = $this->replaceParams(); $this->_execute($sql, $params, 0, true); $this->updateCount = $this->conn->getUpdateCount(); return $this->updateCount; } protected function escape($str) { if ($this->conn->getAdapter()->emulatePrepareStmt()) return $this->conn->getAdapter()->escape($str); return $str; } function setNull($paramIndex) { $this->sql_cache_valid = false; $this->boundInVars[$paramIndex] = null; } function setBlob($paramIndex, $blob) { if ($this->conn->getAdapter()->emulatePrepareStmt()) return parent::setBlob($paramIndex, $blob); $this->sql_cache_valid = false; if ($blob === null) { $this->setNull($paramIndex); return; } if ($blob instanceof Blob) { if ($blob->isFromFile() && !$blob->isModified()) { $this->boundInVars[$paramIndex] = $blob; return; } $blob = $blob->__toString(); } $this->boundInVars[$paramIndex] = "'" . $this->escape($blob) . "'"; } function setClob($paramIndex, $clob) { if ($this->conn->getAdapter()->emulatePrepareStmt()) return parent::setClob($paramIndex, $clob); $this->sql_cache_valid = false; if ($clob === null) { $this->setNull($paramIndex); return; } if ($clob instanceof Clob) { if ($clob->isFromFile() && !$clob->isModified()) { $this->boundInVars[$paramIndex] = $clob; return; } $clob = $clob->__toString(); } $this->boundInVars[$paramIndex] = "'" . $this->escape($clob) . "'"; } }   class ODBCStatement extends StatementCommon implements Statement { public function executeQuery($sql, $fetchmode = null) { if ($this->resultSet) { $this->resultSet->close(); $this->resultSet = null; } $this->updateCount = null; if ($this->conn->getAdapter()->hasLimitOffset()) { if ($this->limit > 0 || $this->offset > 0) $this->conn->applyLimit($sql, $this->offset, $this->limit); } $this->resultSet = $this->conn->executeQuery($sql, $fetchmode); if (!$this->conn->getAdapter()->hasLimitOffset()) { $this->resultSet->_setOffset($this->offset); $this->resultSet->_setLimit($this->limit); } return $this->resultSet; } }   class ODBCTypes extends CreoleTypes { protected static $typeMap = null; protected static $reverseMap = null; public static function loadTypeMap($conn = null) { if (self::$typeMap !== null && count(self::$typeMap) > 0) return; if ($conn == null) throw new SQLException('No connection specified when loading ODBC type map.'); self::$typeMap = array(); $result = @odbc_gettypeinfo($conn->getResource()); if ($result === false) throw new SQLException('Failed to retrieve type info.', $conn->nativeError()); $rowNum = 1; while (odbc_fetch_row($result, $rowNum++)) { $odbctypeid = odbc_result($result, 'DATA_TYPE'); $odbctypename = odbc_result($result, 'TYPE_NAME'); switch ($odbctypeid) { case SQL_CHAR: self::$typeMap[$odbctypename] = CreoleTypes::CHAR; break; case SQL_VARCHAR: self::$typeMap[$odbctypename] = CreoleTypes::VARCHAR; break; case SQL_LONGVARCHAR: self::$typeMap[$odbctypename] = CreoleTypes::LONGVARCHAR; break; case SQL_DECIMAL: self::$typeMap[$odbctypename] = CreoleTypes::DECIMAL; break; case SQL_NUMERIC: self::$typeMap[$odbctypename] = CreoleTypes::NUMERIC; break; case SQL_BIT: self::$typeMap[$odbctypename] = CreoleTypes::BOOLEAN; break; case SQL_TINYINT: self::$typeMap[$odbctypename] = CreoleTypes::TINYINT; break; case SQL_SMALLINT: self::$typeMap[$odbctypename] = CreoleTypes::SMALLINT; break; case SQL_INTEGER: self::$typeMap[$odbctypename] = CreoleTypes::INTEGER; break; case SQL_BIGINT: self::$typeMap[$odbctypename] = CreoleTypes::BIGINT; break; case SQL_REAL: self::$typeMap[$odbctypename] = CreoleTypes::REAL; break; case SQL_FLOAT: self::$typeMap[$odbctypename] = CreoleTypes::FLOAT; break; case SQL_DOUBLE: self::$typeMap[$odbctypename] = CreoleTypes::DOUBLE; break; case SQL_BINARY: self::$typeMap[$odbctypename] = CreoleTypes::BINARY; break; case SQL_VARBINARY: self::$typeMap[$odbctypename] = CreoleTypes::VARBINARY; break; case SQL_LONGVARBINARY: self::$typeMap[$odbctypename] = CreoleTypes::LONGVARBINARY; break; case SQL_DATE: self::$typeMap[$odbctypename] = CreoleTypes::DATE; break; case SQL_TIME: self::$typeMap[$odbctypename] = CreoleTypes::TIME; break; case SQL_TIMESTAMP: self::$typeMap[$odbctypename] = CreoleTypes::TIMESTAMP; break; case SQL_TYPE_DATE: self::$typeMap[$odbctypename] = CreoleTypes::DATE; break; case SQL_TYPE_TIME: self::$typeMap[$odbctypename] = CreoleTypes::TIME; break; case SQL_TYPE_TIMESTAMP: self::$typeMap[$odbctypename] = CreoleTypes::TIMESTAMP; break; default: self::$typeMap[$odbctypename] = CreoleTypes::OTHER; break; } } @odbc_free_result($result); } public static function getType($nativeType) { if (!self::$typeMap) self::loadTypeMap(); $t = strtoupper($nativeType); if (isset(self::$typeMap[$t])) { return self::$typeMap[$t]; } else { return CreoleTypes::OTHER; } } public static function getNativeType($creoleType) { if (!self::$typeMap) self::loadTypeMap(); if (self::$reverseMap === null) { self::$reverseMap = array_flip(self::$typeMap); } return @self::$reverseMap[$creoleType]; } }   abstract class PdoConnectionCommon extends ConnectionCommon { private $update_count = 0; private $open_result_set = false; private $open_result_set_ref = null; function connect($dsninfo, $flags = 0, $pdo_dsn) { if (!extension_loaded('pdo')) { throw new SQLException('pdo extension not loaded'); } $file = $dsninfo['database']; $this->dsn = $dsninfo; $this->flags = $flags; $persistent = ($flags & Creole::PERSISTENT === Creole::PERSISTENT); $pdo_conn_flags = array(); if( $persistent ) { $pdo_conn_flags[PDO::ATTR_PERSISTENT] = true; } else { $pdo_conn_flags[PDO::ATTR_PERSISTENT] = false; } try { $conn = new PDO( $pdo_dsn, '', '', $pdo_conn_flags ); } catch( PDOException $e ) { throw new SQLException("Unable to connect to SQLite database", $e->getMessage()); } $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); if( ($flags & Creole::COMPAT_ASSOC_LOWER) === Creole::COMPAT_ASSOC_LOWER) { $conn->setAttribute(PDO::ATTR_CASE, PDO::CASE_LOWER); } $this->dblink = $conn; } function close() { $this->dblink = NULL; return null; } public function executeQuery($sql, $fetchmode = null, $rs_class) { if( $this->openResultSet() ) { $this->handleOpenResultSet( ); } $pdo_stmt = $this->executePdoQuery( $sql ); $rs = new $rs_class($this, $pdo_stmt, $fetchmode); $this->openResultSet( $rs ); return $rs; } public function handleOpenResultSet() { trigger_error( "Implicitly closing a result set that is still open", E_USER_WARNING ); $this->open_result_set_ref->closeCursor(); } public function openResultSet( $val = null ) { if( $val !== null ) { if( is_object($val) ) { if( is_object( $this->open_result_set_ref ) ) { $this->open_result_set_ref->closeCursor(); } $this->open_result_set_ref = $val; } elseif( $val == false ) { $this->open_result_set_ref = null; } $this->open_result_set = $val ? true : false; } return $this->open_result_set; } public function executePdoQuery( $sql ) { $this->lastQuery = $sql; try { $pdo_stmt = $this->dblink->prepare($this->lastQuery); $pdo_stmt->execute(); } catch( PDOException $e ) { throw new SQLException('Could not execute query', $e->getMessage(), $this->lastQuery); } return $pdo_stmt; } function executeUpdate($sql) { if( $this->openResultSet() ) { $this->handleOpenResultSet( ); } $this->update_count = 0; $pdo_stmt = $this->executePdoQuery( $sql ); try { $this->update_count = (int) $pdo_stmt->rowCount(); } catch( PDOException $e ) { throw new SQLException('Could not get update count', $e->getMessage(), $this->lastQuery); } return $this->getUpdateCount(); } protected function beginTrans() { try { $this->dblink->beginTransaction(); } catch( PDOException $e ) { throw new SQLException('Could not begin transaction', $e->getMessage()); } } protected function commitTrans() { try { $this->dblink->commit(); } catch( PDOException $e ) { throw new SQLException('Could not commit transaction', $e->getMessage()); } } protected function rollbackTrans() { try { $this->dblink->rollBack(); } catch( PDOException $e ) { throw new SQLException('Could not rollback transaction', $e->getMessage()); } } public function getUpdateCount() { return $this->update_count; } }   abstract class PdoIdGeneratorCommon implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return false; } public function isAfterInsert() { return true; } public function getIdMethod() { return self::AUTOINCREMENT; } public function getId($unused = null) { return $this->conn->getResource()->lastInsertId(); } }   class PdoSQLiteTypes extends CreoleTypes { private static $typeMap = array( 'tinyint' => CreoleTypes::TINYINT, 'smallint' => CreoleTypes::SMALLINT, 'mediumint' => CreoleTypes::SMALLINT, 'int' => CreoleTypes::INTEGER, 'integer' => CreoleTypes::INTEGER, 'bigint' => CreoleTypes::BIGINT, 'int24' => CreoleTypes::BIGINT, 'real' => CreoleTypes::REAL, 'float' => CreoleTypes::FLOAT, 'decimal' => CreoleTypes::DECIMAL, 'numeric' => CreoleTypes::NUMERIC, 'double' => CreoleTypes::DOUBLE, 'char' => CreoleTypes::CHAR, 'varchar' => CreoleTypes::VARCHAR, 'date' => CreoleTypes::DATE, 'time' => CreoleTypes::TIME, 'year' => CreoleTypes::YEAR, 'datetime' => CreoleTypes::TIMESTAMP, 'timestamp' => CreoleTypes::TIMESTAMP, 'tinyblob' => CreoleTypes::BINARY, 'blob' => CreoleTypes::VARBINARY, 'mediumblob' => CreoleTypes::VARBINARY, 'longblob' => CreoleTypes::VARBINARY, 'tinytext' => CreoleTypes::VARCHAR, 'mediumtext' => CreoleTypes::LONGVARCHAR, 'text' => CreoleTypes::LONGVARCHAR, ); private static $reverseMap = null; public static function getType($nativeType) { $t = strtolower($nativeType); if (isset(self::$typeMap[$t])) { return self::$typeMap[$t]; } else { return CreoleTypes::TEXT; } } public static function getNativeType($creoleType) { if (self::$reverseMap === null) { self::$reverseMap = array_flip(self::$typeMap); } return @self::$reverseMap[$creoleType]; } }   class PdoStatementCommon extends StatementCommon implements Statement { }   class PgSQLIdGenerator implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return true; } public function isAfterInsert() { return false; } public function getIdMethod() { return self::SEQUENCE; } public function getId($name = null) { if ($name === null) { throw new SQLException("You must specify the sequence name when calling getId() method."); } $rs = $this->conn->executeQuery("SELECT nextval('" . pg_escape_string ( $name ) . "')", ResultSet::FETCHMODE_NUM); $rs->next(); return $rs->getInt(1); } }   class PgSQLPreparedStatement extends PreparedStatementCommon implements PreparedStatement { protected function escape($str) { return pg_escape_string($str); } private function arrayToStr($arr) { $parts = array(); foreach((array)$arr as $el) { if (is_array($el)) { $parts[] = $this->arrayToStr($el); } else { if (is_string($el)) { $parts[] = '"' . $this->escape($el) . '"'; } else { $parts[] = $el; } } } return '{' . implode(',', $parts) . '}'; } function setArray($paramIndex, $value) { if( $paramIndex > $this->positionsCount || $paramIndex < 1) { throw new SQLException('Cannot bind to invalid param index: '.$paramIndex); } if ($value === null) $this->setNull($paramIndex); else $this->boundInVars[$paramIndex] = "'" . $this->arrayToStr($value) . "'"; } function setBoolean($paramIndex, $value) { if( $paramIndex > $this->positionsCount || $paramIndex < 1) { throw new SQLException('Cannot bind to invalid param index: '.$paramIndex); } if ($value === null) $this->setNull($paramIndex); else $this->boundInVars[$paramIndex] = ($value ? "'t'" : "'f'"); } function setBlob($paramIndex, $blob) { if ($blob === null) { $this->setNull($paramIndex); } else { if (is_object($blob)) { $blob = $blob->__toString(); } $this->boundInVars[$paramIndex] = "'" . pg_escape_bytea( $blob ) . "'"; } } function setTime($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { if ( is_numeric ( $value ) ) { $value = date ( "H:i:s O", $value ); } elseif ( is_object ( $value ) ) { $value = date ( "H:i:s O", $value->getTime ( ) ); } $this->boundInVars [ $paramIndex ] = "'" . $this->escape ( $value ) . "'"; } } function setTimestamp($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date('Y-m-d H:i:s O', $value); elseif (is_object($value)) $value = date("Y-m-d H:i:s O", $value->getTime()); $this->boundInVars[$paramIndex] = "'".$this->escape($value)."'"; } } }   class PgSQLStatement extends StatementCommon implements Statement { }   class PgSQLTypes extends CreoleTypes { private static $typeMap = array ( "int2" => CreoleTypes::SMALLINT, "int4" => CreoleTypes::INTEGER, "oid" => CreoleTypes::INTEGER, "int8" => CreoleTypes::BIGINT, "cash" => CreoleTypes::DOUBLE, "money" => CreoleTypes::DOUBLE, "numeric" => CreoleTypes::NUMERIC, "float4" => CreoleTypes::REAL, "float8" => CreoleTypes::DOUBLE, "bpchar" => CreoleTypes::CHAR, "char" => CreoleTypes::CHAR, "char2" => CreoleTypes::CHAR, "char4" => CreoleTypes::CHAR, "char8" => CreoleTypes::CHAR, "char16" => CreoleTypes::CHAR, "varchar" => CreoleTypes::VARCHAR, "text" => CreoleTypes::VARCHAR, "name" => CreoleTypes::VARCHAR, "filename" => CreoleTypes::VARCHAR, "bytea" => CreoleTypes::BINARY, "bool" => CreoleTypes::BOOLEAN, "date" => CreoleTypes::DATE, "time" => CreoleTypes::TIME, "abstime" => CreoleTypes::TIMESTAMP, "timestamp" => CreoleTypes::TIMESTAMP, "timestamptz" => CreoleTypes::TIMESTAMP, "_bool" => CreoleTypes::ARR, "_char" => CreoleTypes::ARR, "_int2" => CreoleTypes::ARR, "_int4" => CreoleTypes::ARR, "_text" => CreoleTypes::ARR, "_oid" => CreoleTypes::ARR, "_varchar" => CreoleTypes::ARR, "_int8" => CreoleTypes::ARR, "_float4" => CreoleTypes::ARR, "_float8" => CreoleTypes::ARR, "_abstime" => CreoleTypes::ARR, "_date" => CreoleTypes::ARR, "_time" => CreoleTypes::ARR, "_timestamp" => CreoleTypes::ARR, "_numeric" => CreoleTypes::ARR, "_bytea" => CreoleTypes::ARR, ); private static $reverseMap = null; public static function getType($pgsqlType) { $t = strtolower($pgsqlType); if (isset(self::$typeMap[$t])) { return self::$typeMap[$t]; } else { return CreoleTypes::OTHER; } } public static function getNativeType($creoleType) { if (self::$reverseMap === null) { self::$reverseMap = array_flip(self::$typeMap); } return @self::$reverseMap[$creoleType]; } }   class SQLiteIdGenerator implements IdGenerator { private $conn; public function __construct(Connection $conn) { $this->conn = $conn; } public function isBeforeInsert() { return false; } public function isAfterInsert() { return true; } public function getIdMethod() { return self::AUTOINCREMENT; } public function getId($unused = null) { return sqlite_last_insert_rowid($this->conn->getResource()); } }   class SQLitePreparedStatement extends PreparedStatementCommon implements PreparedStatement { protected function escape($str) { return sqlite_escape_string($str); } function setBlob($paramIndex, $blob) { if ($blob === null) { $this->setNull($paramIndex); } else { if (is_object($blob)) { $blob = $blob->__toString(); } $this->boundInVars[$paramIndex] = "'" . sqlite_udf_encode_binary( $blob ) . "'"; } } }   class SQLiteStatement extends StatementCommon implements Statement { }   class SQLiteTypes extends CreoleTypes { private static $typeMap = array( 'tinyint' => CreoleTypes::TINYINT, 'smallint' => CreoleTypes::SMALLINT, 'mediumint' => CreoleTypes::SMALLINT, 'int' => CreoleTypes::INTEGER, 'integer' => CreoleTypes::INTEGER, 'bigint' => CreoleTypes::BIGINT, 'int24' => CreoleTypes::BIGINT, 'real' => CreoleTypes::REAL, 'float' => CreoleTypes::FLOAT, 'decimal' => CreoleTypes::DECIMAL, 'numeric' => CreoleTypes::NUMERIC, 'double' => CreoleTypes::DOUBLE, 'char' => CreoleTypes::CHAR, 'varchar' => CreoleTypes::VARCHAR, 'date' => CreoleTypes::DATE, 'time' => CreoleTypes::TIME, 'year' => CreoleTypes::YEAR, 'datetime' => CreoleTypes::TIMESTAMP, 'timestamp' => CreoleTypes::TIMESTAMP, 'tinyblob' => CreoleTypes::BINARY, 'blob' => CreoleTypes::VARBINARY, 'mediumblob' => CreoleTypes::VARBINARY, 'longblob' => CreoleTypes::VARBINARY, 'tinytext' => CreoleTypes::VARCHAR, 'mediumtext' => CreoleTypes::LONGVARCHAR, 'text' => CreoleTypes::LONGVARCHAR, ); private static $reverseMap = null; public static function getType($nativeType) { $t = strtolower($nativeType); if (isset(self::$typeMap[$t])) { return self::$typeMap[$t]; } else { return CreoleTypes::TEXT; } } public static function getNativeType($creoleType) { if (self::$reverseMap === null) { self::$reverseMap = array_flip(self::$typeMap); } return @self::$reverseMap[$creoleType]; } }   class MSSQLCallableStatement extends MSSQLPreparedStatement implements CallableStatement { private $boundOutVars = array(); private static $typeMap = array( CreoleTypes::BOOLEAN => SQLBIT, CreoleTypes::BIGINT => SQLINT4, CreoleTypes::SMALLINT => SQLINT2, CreoleTypes::TINYINT => SQLINT2, CreoleTypes::INTEGER => SQLINT4, CreoleTypes::CHAR => SQLCHAR, CreoleTypes::VARCHAR => SQLVARCHAR, CreoleTypes::TEXT => SQLTEXT, CreoleTypes::FLOAT => SQLFLT8, CreoleTypes::DOUBLE => SQLFLT8, CreoleTypes::DATE => SQLVARCHAR, CreoleTypes::TIME => SQLVARCHAR, CreoleTypes::TIMESTAMP => SQLVARCHAR, CreoleTypes::VARBINARY => SQLVARCHAR, CreoleTypes::NUMERIC => SQLINT4, CreoleTypes::DECIMAL => SQLFLT8 ); private $stmt; private $result; public function __construct(Connection $conn, $stmt) { $this->conn = $conn; $this->stmt = $stmt; } public function getResource() { return $this->stmt; } function close() { @mssql_free_statement($this->stmt); $this->rsFetchCount = 0; } function executeQuery($p1 = null, $fetchmode = null) { $params = null; if ($fetchmode !== null) { $params = $p1; } elseif ($p1 !== null) { if (is_array($p1)) $params = $p1; else $fetchmode = $p1; } if ($params) { for($i=0,$cnt=count($params); $i < $cnt; $i++) { $this->set($i+1, $params[$i]); } } $this->result = mssql_execute($this->stmt); if (!$this->result) { throw new SQLException('unable to execute callable statement', mssql_get_last_message()); } return new MSSQLResultSet($this->conn, $this->result, $fetchmode, $this->offset, $this->limit); } function getMoreResults() { $this->rsFetchCount++; $hasMore = mssql_next_result($this->result); if ($this->resultSet) $this->resultSet->close(); if ($hasMore) { $clazz = $this->resultClass; $this->resultSet = new $clazz($this, $this->result); } else { $this->resultSet = null; } return $hasMore; } function registerOutParameter($paramIndex, $sqlType, $maxLength = null) { mssql_bind($this->stmt, $paramIndex, $this->boundOutVars[$paramIndex], self::$typeMap[$sqlType], true, false, $maxLength); } function setArray($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { $value = serialize($value); mssql_bind($this->stmt, $paramIndex, $value, SQLTEXT, $out); } } function setBoolean($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { $value = ($value) ? 1 : 0; mssql_bind($this->stmt, $paramIndex, $value, SQLBIT, $out); } } function setBlob($paramIndex, $blob, $out = false) { if ($blob === null) { $this->setNull($paramIndex); } else { if (is_object($blob)) { $blob = $blob->__toString(); } if ($out) $this->boundOutVars[$paramIndex] = &$blob; $data = unpack("H*hex", $blob); mssql_bind($this->stmt, $paramIndex, $data, SQLTEXT, $out); } } function setClob($paramIndex, $clob, $out = false) { if ($clob === null) { $this->setNull($paramIndex); } else { if (is_object($clob)) { $clob = $clob->__toString(); } if ($out) $this->boundOutVars[$paramIndex] = &$clob; mssql_bind($this->stmt, $paramIndex, $clob, SQLTEXT, $out); } } function setDate($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date("Y-m-d", $value); mssql_bind($this->stmt, $paramIndex, $value, SQLVARCHAR, $out); } } function setFloat($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { $value = (float) $value; mssql_bind($this->stmt, $paramIndex, $value, SQLFLT8, $out); } } function setInt($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { $value = (int) $value; mssql_bind($this->stmt, $paramIndex, $value, SQLINT4, $out); } } function setNull($paramIndex) { $value = null; mssql_bind($this->stmt, $paramIndex, $value, $type=null, $out=false, $is_null=true); } function setString($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { $value = (string) $value; mssql_bind($this->stmt, $paramIndex, $value, SQLVARCHAR, $out); } } function setTime($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date("H:i:s", $value); mssql_bind($this->stmt, $paramIndex, $value, SQLVARCHAR, $out); } } function setTimestamp($paramIndex, $value, $out = false) { if ($out) $this->boundOutVars[$paramIndex] = &$value; if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date('Y-m-d H:i:s', $value); mssql_bind($this->stmt, $paramIndex, $value, SQLVARCHAR, $out); } } function getArray($paramIndex) { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } return (array) unserialize($this->boundOutVars[$paramIndex]); } function getBoolean($paramIndex) { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } return (boolean) $this->boundOutVars[$paramIndex]; } function getBlob($paramIndex) { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } $b = new Blob(); $b->setContents($this->boundOutVars[$paramIndex]); return $b; } function getClob($paramIndex) { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } $c = new Clob(); $c->setContents($this->boundOutVars[$paramIndex]); return $c; } function getDate($paramIndex, $format = '%Y-%m-%d') { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } $ts = strtotime($this->boundOutVars[$paramIndex]); if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . $paramIndex . " to timestamp: " . $this->boundOutVars[$paramIndex]); } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } return $this->boundOutVars[$paramIndex]; } function getFloat($paramIndex) { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } return (float) $this->boundOutVars[$paramIndex]; } function getInt($paramIndex) { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } return (int) $this->boundOutVars[$paramIndex]; } function getString($paramIndex) { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } return (string) $this->boundOutVars[$paramIndex]; } function getTime($paramIndex, $format='%X') { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } $ts = strtotime($this->boundOutVars[$paramIndex]); if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . $paramIndex . " to timestamp: " . $this->boundOutVars[$paramIndex]); } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } function getTimestamp($paramIndex, $format = 'Y-m-d H:i:s') { if (!array_key_exists($paramIndex, $this->boundOutVars)) { throw new SQLException('Requesting variable not bound to output var: '.$paramIndex); } if ($this->boundOutVars[$paramIndex] === null) { return null; } $ts = strtotime($this->boundOutVars[$paramIndex]); if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . $paramIndex . " to timestamp: " . $this->boundOutVars[$paramIndex]); } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } }   class MSSQLTableInfo extends TableInfo { protected function initColumns() { if (!@mssql_select_db($this->dbname, $this->conn->getResource())) { throw new SQLException('No database selected'); } $res = mssql_query("sp_columns '".$this->name."'", $this->conn->getResource()); if (!$res) { throw new SQLException('Could not get column names', mssql_get_last_message()); } while ($row = mssql_fetch_array($res)) { $name = $row['COLUMN_NAME']; $type = $row['TYPE_NAME']; $length = $row['LENGTH']; $is_nullable = $row['NULLABLE']; $default = $row['COLUMN_DEF']; $precision = $row['PRECISION']; $scale = $row['SCALE']; $identity = false; if (strtolower($type) == "int identity") { $identity = true; } $this->columns[$name] = new ColumnInfo($this, $name, MSSQLTypes::getType($type), $type, $length, $precision, $scale, $is_nullable, $default, $identity); } $this->colsLoaded = true; } protected function initIndexes() { if (!$this->colsLoaded) $this->initColumns(); if (!@mssql_select_db($this->dbname, $this->conn->getResource())) { throw new SQLException('No database selected'); } $res = mssql_query("sp_indexes_rowset ".$this->name, $this->conn->getResource()); while ($row = mssql_fetch_array($res)) { $name = $row['INDEX_NAME']; if (!isset($this->indexes[$name])) { $this->indexes[$name] = new IndexInfo($name); } $this->indexes[$name]->addColumn($this->columns[ $row['COLUMN_NAME'] ]); } $this->indexesLoaded = true; } protected function initForeignKeys() { if (!$this->colsLoaded) $this->initColumns(); if (!@mssql_select_db($this->dbname, $this->conn->getResource())) { throw new SQLException('No database selected'); } $res = mssql_query("SELECT     ccu1.TABLE_NAME, ccu1.COLUMN_NAME, ccu2.TABLE_NAME AS FK_TABLE_NAME, ccu2.COLUMN_NAME AS FK_COLUMN_NAME
                            FROM         INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu1 INNER JOIN
                                      INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc1 ON tc1.CONSTRAINT_NAME = ccu1.CONSTRAINT_NAME AND
                                      CONSTRAINT_TYPE = 'Foreign Key' INNER JOIN
                                      INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc1 ON rc1.CONSTRAINT_NAME = tc1.CONSTRAINT_NAME INNER JOIN
                                      INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu2 ON ccu2.CONSTRAINT_NAME = rc1.UNIQUE_CONSTRAINT_NAME
                            WHERE     (ccu1.table_name = '".$this->name."')", $this->conn->getResource()); while($row = mssql_fetch_array($res)) { $name = $row['COLUMN_NAME']; $ftbl = $row['FK_TABLE_NAME']; $fcol = $row['FK_COLUMN_NAME']; if (!isset($this->foreignKeys[$name])) { $this->foreignKeys[$name] = new ForeignKeyInfo($name); if ($this->database->hasTable($ftbl)) { $foreignTable = $this->database->getTable($ftbl); } else { $foreignTable = new TableInfo($ftbl); $this->database->addTable($foreignTable); } if ($foreignTable->hasColumn($fcol)) { $foreignCol = $foreignTable->getColumn($fcol); } else { $foreignCol = new ColumnInfo($foreignTable, $fcol); $foreignTable->addColumn($foreignCol); } $this->foreignKeys[$name]->addReference($this->columns[$name], $foreignCol); } } $this->fksLoaded = true; } protected function initPrimaryKey() { if (!$this->colsLoaded) $this->initColumns(); if (!@mssql_select_db($this->dbname, $this->conn->getResource())) { throw new SQLException('No database selected'); } $res = mssql_query("SELECT COLUMN_NAME
                        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS
                                INNER JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ON
                      INFORMATION_SCHEMA.TABLE_CONSTRAINTS.CONSTRAINT_NAME = INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE.constraint_name
                        WHERE     (INFORMATION_SCHEMA.TABLE_CONSTRAINTS.CONSTRAINT_TYPE = 'PRIMARY KEY') AND
                      (INFORMATION_SCHEMA.TABLE_CONSTRAINTS.TABLE_NAME = '".$this->name."')", $this->conn->getResource()); while($row = mssql_fetch_row($res)) { $name = $row[0]; if (!isset($this->primaryKey)) { $this->primaryKey = new PrimaryKeyInfo($name); } $this->primaryKey->addColumn($this->columns[ $name ]); } $this->pkLoaded = true; } }   class MySQLTableInfoBase extends TableInfo { protected function initColumns() { if (!$this->database->selectDb($this->dbname)) { throw new SQLException('No database selected'); } $res = $this->database->sqlQuery("SHOW COLUMNS FROM `" . $this->name . "`"); $defaults = array(); $nativeTypes = array(); $precisions = array(); while($row = $this->database->fetchAssoc($res)) { $name = $row['Field']; $is_nullable = ($row['Null'] == 'YES'); $is_auto_increment = (strpos($row['Extra'], 'auto_increment') !== false); $size = null; $precision = null; $scale = null; if (preg_match('/^(\w+)[\(]?([\d,]*)[\)]?( |$)/', $row['Type'], $matches)) { $nativeType = $matches[1]; if ($matches[2]) { if ( ($cpos = strpos($matches[2], ',')) !== false) { $size = (int) substr($matches[2], 0, $cpos); $precision = $size; $scale = (int) substr($matches[2], $cpos + 1); } else { $size = (int) $matches[2]; } } } elseif (preg_match('/^(\w+)\(/', $row['Type'], $matches)) { $nativeType = $matches[1]; } else { $nativeType = $row['Type']; } $default = preg_match('~blob|text~', $nativeType) ? null : $row['Default']; $this->columns[$name] = new ColumnInfo($this, $name, MySQLTypes::getType($nativeType), $nativeType, $size, $precision, $scale, $is_nullable, $default, $is_auto_increment, $row); } $this->colsLoaded = true; } protected function initPrimaryKey() { if (!$this->colsLoaded) $this->initColumns(); if (!$this->database->selectDb($this->dbname)) { throw new SQLException('No database selected'); } $res = $this->database->sqlQuery("SHOW KEYS FROM `" . $this->name . "`"); while($row = $this->database->fetchAssoc($res)) { if ($row['Key_name'] !== 'PRIMARY') { continue; } $name = $row["Column_name"]; if (!isset($this->primaryKey)) { $this->primaryKey = new PrimaryKeyInfo($name, $row); } $this->primaryKey->addColumn($this->columns[$name]); } $this->pkLoaded = true; } protected function initIndexes() { if (!$this->colsLoaded) $this->initColumns(); if (!$this->database->selectDb($this->dbname)) { throw new SQLException('No database selected'); } $res = $this->database->sqlQuery("SHOW INDEX FROM `" . $this->name . "`"); while($row = $this->database->fetchAssoc($res)) { $colName = $row["Column_name"]; $name = $row["Key_name"]; if($name == "PRIMARY") { continue; } if (!isset($this->indexes[$name])) { $isUnique = ($row["Non_unique"] == 0); $this->indexes[$name] = new IndexInfo($name, $isUnique, $row); } $this->indexes[$name]->addColumn($this->columns[$colName]); } $this->indexesLoaded = true; } protected function initForeignKeys() { $res = $this->database->sqlQuery("SELECT VERSION()"); $row = $this->database->fetchRow($res); if ($row[0] < '3.23.44') { $this->fksLoaded = true; return; } if (!$this->colsLoaded) $this->initColumns(); if (!$this->database->selectDb($this->dbname)) { throw new SQLException('No database selected'); } $res = $this->database->sqlQuery("SHOW CREATE TABLE `" . $this->name . "`"); $row = $this->database->fetchRow($res); $regEx = '/FOREIGN KEY \(`([^`]*)`\) REFERENCES `([^`]*)` \(`([^`]*)`\)(.*)/'; if (preg_match_all($regEx,$row[1],$matches)) { $tmpArray = array_keys($matches[0]); foreach ($tmpArray as $curKey) { $name = $matches[1][$curKey]; $ftbl = $matches[2][$curKey]; $fcol = $matches[3][$curKey]; $fkey = $matches[4][$curKey]; if (!isset($this->foreignKeys[$name])) { $this->foreignKeys[$name] = new ForeignKeyInfo($name); if ($this->database->hasTable($ftbl)) { $foreignTable = $this->database->getTable($ftbl); } else { $foreignTable = new $this->database->tableClassName($this->database, $ftbl); $this->database->addTable($foreignTable); } if ($foreignTable->hasColumn($fcol)) { $foreignCol = $foreignTable->getColumn($fcol); } else { $foreignCol = new ColumnInfo($foreignTable, $fcol); $foreignTable->addColumn($foreignCol); } $fkactions = array( 'ON DELETE' => ForeignKeyInfo::RESTRICT, 'ON UPDATE' => ForeignKeyInfo::RESTRICT, ); if ($fkey) { foreach (array_keys($fkactions) as $fkaction) { $result = NULL; preg_match('/' . $fkaction . ' (' . ForeignKeyInfo::CASCADE . '|' . ForeignKeyInfo::SETNULL . ')/', $fkey, $result); if ($result && is_array($result) && isset($result[1])) { $fkactions[$fkaction] = $result[1]; } } } $this->foreignKeys[$name]->addReference($this->columns[$name], $foreignCol, $fkactions['ON DELETE'], $fkactions['ON UPDATE']); } } } $this->fksLoaded = true; } protected function initVendorSpecificInfo() { $res = $this->database->sqlQuery("SHOW TABLE STATUS LIKE '" . $this->name . "'"); $this->vendorSpecificInfo = $this->database->fetchAssoc($res); $this->vendorLoaded = true; } }   class OCI8PreparedStatement extends PreparedStatementCommon implements PreparedStatement { private $lobDescriptors = array(); private $lobs = array(); private $columns = array(); function close() { if (isset($this->stmt)) @oci_free_statement($this->stmt); } protected function escape($str) { return $str; } public function executeQuery($p1 = null, $fetchmode = null) { $params = null; if ($fetchmode !== null) { $params = $p1; } elseif ($p1 !== null) { if (is_array($p1)) $params = $p1; else $fetchmode = $p1; } if ($params) { for($i=0,$cnt=count($params); $i < $cnt; $i++) { $this->set($i+1, $params[$i]); } } $this->updateCount = null; $sql = $this->sqlToOracleBindVars($this->sql); if ($this->limit > 0 || $this->offset > 0) { $this->conn->applyLimit($sql, $this->offset, $this->limit); } $result = oci_parse($this->conn->getResource(), $sql); if (!$result) { throw new SQLException("Unable to prepare query", $this->conn->nativeError(), $this->sqlToOracleBindVars($this->sql)); } $this->bindVars($result); $success = oci_execute($result, OCI_DEFAULT); if (!$success) { throw new SQLException("Unable to execute query", $this->conn->nativeError($result), $this->sqlToOracleBindVars($this->sql)); } $this->resultSet = new OCI8ResultSet($this->conn, $result, $fetchmode); return $this->resultSet; } public function executeUpdate($params = null) { if ($params) { for($i=0,$cnt=count($params); $i < $cnt; $i++) { $this->set($i+1, $params[$i]); } } if($this->resultSet) $this->resultSet->close(); $this->resultSet = null; $stmt = oci_parse($this->conn->getResource(), $this->sqlToOracleBindVars($this->sql)); if (!$stmt) { throw new SQLException("Unable to prepare update", $this->conn->nativeError(), $this->sqlToOracleBindVars($this->sql)); } $this->bindVars($stmt); $success = oci_execute($stmt, OCI_DEFAULT); if (!$success) { throw new SQLException("Unable to execute update", $this->conn->nativeError($stmt), $this->sqlToOracleBindVars($this->sql)); } foreach($this->lobDescriptors as $paramIndex => $lobster) { $lob = $this->lobs[$paramIndex]; if ($lob->isFromFile()) { $success = $lobster->savefile($lob->getInputFile()); } else { $success = $lobster->save($lob->getContents()); } if (!$success) { $lobster->free(); throw new SQLException("Error saving lob bound to " . $paramIndex); } $lobster->free(); } if ($this->conn->getAutoCommit()) { oci_commit($this->conn->getResource()); } $this->updateCount = @oci_num_rows($stmt); return $this->updateCount; } private function bindVars($stmt) { foreach ($this->boundInVars as $idx => $val) { $idxName = ":var" . $idx; if (!oci_bind_by_name($stmt, $idxName, $this->boundInVars[$idx], -1)) { throw new SQLException("Erorr binding value to placeholder " . $idx); } } foreach ($this->lobs as $idx => $val) { $idxName = ":var" . $idx; if (class_exists('Blob') && $val instanceof Blob){ if (!oci_bind_by_name($stmt, $idxName, $this->lobDescriptors[$idx], -1, OCI_B_BLOB)) throw new SQLException("Erorr binding blob to placeholder " . $idx); } elseif (class_exists('Clob') && $val instanceof Clob){ if (!oci_bind_by_name($stmt, $idxName, $this->lobDescriptors[$idx], -1, OCI_B_CLOB)) throw new SQLException("Erorr binding clob to placeholder " . $idx); } } } private function sqlToOracleBindVars($sql) { $out = ""; $in_literal = 0; $idxNum = 1; for ($i = 0; $i < strlen($sql); $i++) { $char = $sql[$i]; if (strcmp($char,"'")==0) { $in_literal = ~$in_literal; } if (strcmp($char,"?")==0 && !$in_literal) { if (array_key_exists($idxNum, $this->lobs)){ if (class_exists('Blob') && ($this->lobs[$idxNum] instanceof Blob)) $out .= "empty_blob()"; if (class_exists('Clob') && ($this->lobs[$idxNum] instanceof Clob)) $out .= "empty_clob()"; } else $out .= ":var" . $idxNum; $idxNum++; } else { $out .= $char; } } if (isset($this->lobs) && !empty($this->lobs)) { $this->setColumnArray(); $retstmt = " Returning "; $collist = ""; $bindlist = ""; foreach ($this->lobs as $idx=>$val) { $idxName = ":var" . $idx; if ((class_exists('Blob') && $val instanceof Blob) || (class_exists('Clob') && $val instanceof Clob)) { $collist .= $this->columns[$idx-1] . ","; $bindlist .= $idxName . ","; } } if (!empty($collist)) $out .= $retstmt . rtrim($collist, ",") . " into " . rtrim($bindlist, ","); } return $out; } function setBlob($paramIndex, $blob) { if (!($blob instanceof Blob)) { $b = new Blob(); $b->setContents($blob); $blob = $b; } $this->lobDescriptors[$paramIndex] = oci_new_descriptor($this->conn->getResource(), OCI_D_LOB); $this->lobs[$paramIndex] = $blob; } function setClob($paramIndex, $clob) { if (!($clob instanceof Clob)) { $c = new Clob(); $c->setContents($clob); $clob = $c; } $this->lobDescriptors[$paramIndex] = oci_new_descriptor($this->conn->getResource(), OCI_D_LOB); $this->lobs[$paramIndex] = $clob; } function setString($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { if ( is_object ( $value ) ) { $this->boundInVars[$paramIndex] = $value->__toString(); } else { $this->boundInVars[$paramIndex] = (string)$value; } } } function setTimestamp($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date('Y-m-d H:i:s', $value); elseif (is_object($value)) $value = date('Y-m-d H:i:s', $value->getTime()); $this->boundInVars[$paramIndex] = $value; } } function setDate($paramIndex, $value) { if ($value === null) { $this->setNull($paramIndex); } else { if (is_numeric($value)) $value = date("Y-m-d", $value); elseif (is_object($value)) $value = date("Y-m-d", $value->getTime()); $this->boundInVars[$paramIndex] = $value; } } private function setColumnArray() { $this->columns = array(); if(strtoupper(substr($this->sql, 0, 6)) == 'INSERT') { $firstPos = strpos($this->sql, '('); $secPos = strpos($this->sql, ')'); $collist = substr($this->sql, $firstPos + 1, $secPos - $firstPos - 1); $this->columns = explode(',', $collist); } if (strtoupper(substr($this->sql, 0, 6)) == 'UPDATE') { $tmp = $this->sql; $tmp = str_replace(" =", "=", $this->sql); $tmp = str_replace("= ", "=", $tmp); $tmp = str_replace(",", " ", $tmp); $stage1 = explode("=?",$tmp); foreach($stage1 as $chunk) { $stage2 = explode(' ', $chunk); $this->columns[count($this->columns)] = $stage2[count($stage2) - 1]; } } } function setNull($paramIndex) { $this->boundInVars[$paramIndex] = ''; } }   class OCI8TableInfo extends TableInfo { private $schema; public function __construct(OCI8DatabaseInfo $database, $name) { $this->schema = strtoupper( $database->getSchema() ); parent::__construct($database, $name); $this->name = strtoupper( $this->name ); } protected function initColumns() { $sql = "
			SELECT column_name
				, data_type
				, data_precision
				, data_length
				, data_default
				, nullable
				, data_scale
            FROM  all_tab_columns
            WHERE table_name = '{$this->name}'
                AND OWNER = '{$this->schema}'"; $statement = @oci_parse($this->conn->getResource(),$sql); $success = @oci_execute($statement,OCI_DEFAULT); if (!$success) { throw new SQLException("Could Not Get Columns"); } while ( $statement && $row = oci_fetch_array( $statement , OCI_ASSOC + OCI_RETURN_NULLS ) ) { $row = array_change_key_case($row, CASE_LOWER); $this->columns[$row['column_name']] = new ColumnInfo( $this , $row['column_name'] , OCI8Types::getType($row['data_type']) , $row['data_type'] , $row['data_length'] , $row['data_precision'] , $row['data_scale'] , $row['nullable'] , $row['data_default'] ); } $this->colsLoaded = true; } protected function initPrimaryKey() { if (!$this->colsLoaded) $this->initColumns(); $sql = "SELECT a.owner, a.table_name,
                            a.constraint_name, a.column_name
                        FROM all_cons_columns a, all_constraints b
                        WHERE b.constraint_type = 'P'
                        AND a.constraint_name = b.constraint_name
                        AND b.table_name = '{$this->name}'
                        AND b.owner = '{$this->schema}' AND a.owner = b.owner
            "; $statement = @oci_parse($this->conn->getResource(),$sql); $success = @oci_execute($statement,OCI_DEFAULT); if (!$success) { throw new SQLException("Could Not Get Primary Keys"); } while ( $statement && $row = oci_fetch_assoc( $statement )) { $row = array_change_key_case($row,CASE_LOWER); $name = $row['column_name']; if (!isset($this->primaryKey)) { $this->primaryKey = new PrimaryKeyInfo($name); } $this->primaryKey->addColumn($this->columns[$name]); } $this->pkLoaded = true; } protected function initIndexes() { if (!$this->colsLoaded) $this->initColumns(); $sql = "SELECT
            allind.index_name,
            allind.table_name,
            allind.index_type,
            allind.uniqueness,
            indcol.column_name
            FROM all_indexes allind INNER JOIN all_ind_columns indcol
                ON allind.owner = indcol.index_owner
                AND allind.index_name = indcol.index_name
            WHERE allind.table_owner = '{$this->schema}'
            AND allind.table_name = '{$this->name}'
            AND allind.index_name NOT IN (SELECT
                    constraint_name
                    FROM all_constraints
                    WHERE constraint_type = 'P')
            ORDER BY allind.index_name,
                indcol.column_position"; $statement = @oci_parse($this->conn->getResource(),$sql); $success = @oci_execute($statement,OCI_DEFAULT); if (!$success) { throw new SQLException("Could Not Get Primary Keys"); } while ( $statement && $row = oci_fetch_assoc( $statement )) { $row = array_change_key_case($row,CASE_LOWER); $name = $row['index_name']; $index_col_name = $row['column_name']; if (!isset($this->indexes[$name])) { $this->indexes[$name] = new IndexInfo($name); } $this->indexes[$name]->addColumn($this->columns[ $index_col_name ]); } $this->indexesLoaded = true; } protected function initForeignKeys() { if (!$this->colsLoaded) $this->initColumns(); $sql = "
			SELECT a.owner AS local_owner
				, a.table_name AS local_table
				, c.column_name AS local_column
				, a.constraint_name AS foreign_key_name
				, b.owner AS foreign_owner
				, b.table_name AS foreign_table
				, d.column_name AS foreign_column
				, b.constraint_name AS foreign_constraint_name
				, a.delete_rule AS on_delete
            FROM all_constraints a
				, all_constraints b
				, all_cons_columns c
				, all_cons_columns d
            WHERE a.r_constraint_name = b.constraint_name
                AND c.constraint_name = a.constraint_name
                AND d.constraint_name = b.constraint_name
                AND a.r_owner = b.owner
		AND c.owner = a.owner
		AND d.owner = b.owner
		AND c.position = d.position
                AND a.constraint_type='R'
				AND a.table_name = '{$this->name}'
				AND a.owner = '{$this->schema}'
		"; $statement = @oci_parse($this->conn->getResource(),$sql); $success = @oci_execute($statement,OCI_DEFAULT); if (!$success) { throw new SQLException("Could Not Get Primary Keys"); } while ( $statement && $row = oci_fetch_assoc( $statement )) { $row = array_change_key_case($row,CASE_LOWER); $name = $row['foreign_key_name']; $foreignTable = $this->database->getTable($row['foreign_table']); $foreignColumn = $foreignTable->getColumn($row['foreign_column']); $localTable = $this->database->getTable($row['local_table']); $localColumn = $localTable->getColumn($row['local_column']); if (!isset($this->foreignKeys[$name])) { $this->foreignKeys[$name] = new ForeignKeyInfo($name); } switch ( $row[ 'on_delete' ] ) { case 'CASCADE': $onDelete = ForeignKeyInfo::CASCADE; break; case 'SET NULL': $onDelete = ForeignKeyInfo::SETNULL; break; default: case 'NO ACTION': $onDelete = ForeignKeyInfo::NONE; break; } $this->foreignKeys[ $name ]->addReference( $localColumn , $foreignColumn , $onDelete ); } $this->fksLoaded = true; } }   class ODBCTableInfo extends TableInfo { protected function initColumns() { ODBCTypes::loadTypeMap($this->conn); $result = @odbc_columns($this->conn->getResource(), $this->dbname, '', $this->name); if (!$result) throw new SQLException('Could not get column names', $this->conn->nativeError()); while (odbc_fetch_row($result)) { $name = odbc_result($result, 'COLUMN_NAME'); $type = odbc_result($result, 'TYPE_NAME'); $length = odbc_result($result, 'LENGTH'); $is_nullable = odbc_result($result, 'NULLABLE'); $default = ''; $precision = odbc_result($result, 'PRECISION'); $scale = odbc_result($result, 'SCALE'); $this->columns[$name] = new ColumnInfo($this, $name, ODBCTypes::getType($type), $type, $length, $precision, $scale, $is_nullable, $default); } @odbc_free_result($result); $this->colsLoaded = true; } protected function initPrimaryKey() { if (!$this->colsLoaded) $this->initColumns(); $result = @odbc_primarykeys($this->conn->getResource(), $this->dbname, '', $this->name); while (odbc_fetch_row($result)) { $name = odbc_result($result, 'COLUMN_NAME'); if (!isset($this->primaryKey)) $this->primaryKey = new PrimaryKeyInfo($name); $this->primaryKey->addColumn($this->columns[$name]); } @odbc_free_result($result); $this->pkLoaded = true; } protected function initIndexes() { } protected function initForeignKeys() { if (!$this->colsLoaded) $this->initColumns(); $result = @odbc_foreignkeys($this->conn->getResource(), '', '', '', $this->dbname, '', $this->name); while (odbc_fetch_row($result)) { $name = odbc_result($result, 'COLUMN_NAME'); $ftbl = odbc_result($result, 'FKTABLE_NAME'); $fcol = odbc_result($result, 'FKCOLUMN_NAME'); if (!isset($this->foreignKeys[$name])) { $this->foreignKeys[$name] = new ForeignKeyInfo($name); if (($foreignTable = $this->database->getTable($ftbl)) === null) { $foreignTable = new TableInfo($ftbl); $this->database->addTable($foreignTable); } if (($foreignCol = $foreignTable->getColumn($name)) === null) { $foreignCol = new ColumnInfo($foreignTable, $name); $foreignTable->addColumn($foreignCol); } $this->foreignKeys[$name]->addReference($this->columns[$name], $foreignCol); } } @odbc_free_result($result); $this->fksLoaded = true; } }   class PdoSQLiteIdGenerator extends PdoIdGeneratorCommon { }   class PdoSQLiteStatement extends PdoStatementCommon { }   class PgSQLTableInfo extends TableInfo { private $version; private $oid; function __construct(DatabaseInfo $database, $name, $version, $intOID) { parent::__construct ($database, $name); $this->version = $version; $this->oid = $intOID; } protected function initColumns () { $result = pg_query ($this->conn->getResource(), sprintf ("SELECT
    								att.attname,
    								att.atttypmod,
    								att.atthasdef,
    								att.attnotnull,
    								def.adsrc,
    								CASE WHEN att.attndims > 0 THEN 1 ELSE 0 END AS isarray,
    								CASE
    									WHEN ty.typname = 'bpchar'
    										THEN 'char'
    									WHEN ty.typname = '_bpchar'
	    									THEN '_char'
    									ELSE
	    									ty.typname
    								END AS typname,
    								ty.typtype
								FROM pg_attribute att
									JOIN pg_type ty ON ty.oid=att.atttypid
									LEFT OUTER JOIN pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
								WHERE att.attrelid = %d AND att.attnum > 0
									AND att.attisdropped IS FALSE
								ORDER BY att.attnum", $this->oid)); if (!$result) { throw new SQLException("Could not list fields for table: " . $this->name, pg_last_error($this->conn->getResource())); } while($row = pg_fetch_assoc($result)) { $size = null; $precision = null; $scale = null; if (((int) $row['isarray']) === 1) { throw new SQLException (sprintf ("Array datatypes are not currently supported [%s.%s]", $this->name, $row['attname'])); } $name = $row['attname']; if (strtolower ($row['typtype']) == 'd') { $arrDomain = $this->processDomain ($row['typname']); $type = $arrDomain['type']; $size = $arrDomain['length']; $precision = $size; $scale = $arrDomain['scale']; $boolHasDefault = (strlen (trim ($row['atthasdef'])) > 0) ? $row['atthasdef'] : $arrDomain['hasdefault']; $default = (strlen (trim ($row['adsrc'])) > 0) ? $row['adsrc'] : $arrDomain['default']; $is_nullable = (strlen (trim ($row['attnotnull'])) > 0) ? $row['attnotnull'] : $arrDomain['notnull']; $is_nullable = (($is_nullable == 't') ? false : true); } else { $type = $row['typname']; $arrLengthPrecision = $this->processLengthScale ($row['atttypmod'], $type); $size = $arrLengthPrecision['length']; $precision = $size; $scale = $arrLengthPrecision['scale']; $boolHasDefault = $row['atthasdef']; $default = $row['adsrc']; $is_nullable = (($row['attnotnull'] == 't') ? false : true); } $autoincrement = null; if (($boolHasDefault == 't') && (strlen (trim ($default)) > 0)) { if (!preg_match('/^nextval\(/', $default)) { $strDefault= preg_replace ('/::[\W\D]*/', '', $default); $default = str_replace ("'", '', $strDefault); } else { $autoincrement = true; $default = null; } } else { $default = null; } $this->columns[$name] = new ColumnInfo($this, $name, PgSQLTypes::getType($type), $type, $size, $precision, $scale, $is_nullable, $default, $autoincrement); } $this->colsLoaded = true; } private function processLengthScale ($intTypmod, $strName) { $arrRetVal = array ('length'=>null, 'scale'=>null); if ($intTypmod == -1) { return $arrRetVal; } if ($strName == PgSQLTypes::getNativeType (CreoleTypes::NUMERIC)) { $intLen = ($intTypmod - 4) >> 16; $intPrec = ($intTypmod - 4) & 0xffff; $intLen = sprintf ("%ld", $intLen); if ($intPrec) { $intPrec = sprintf ("%ld", $intPrec); } $arrRetVal['length'] = $intLen; $arrRetVal['scale'] = $intPrec; } elseif ($strName == PgSQLTypes::getNativeType (CreoleTypes::TIME) || $strName == 'timetz' || $strName == PgSQLTypes::getNativeType (CreoleTypes::TIMESTAMP) || $strName == 'timestamptz' || $strName == 'interval' || $strName == 'bit') { $arrRetVal['length'] = sprintf ("%ld", $intTypmod); } else { $arrRetVal['length'] = sprintf ("%ld", ($intTypmod - 4)); } return $arrRetVal; } private function processDomain ($strDomain) { if (strlen (trim ($strDomain)) < 1) { throw new SQLException ("Invalid domain name [" . $strDomain . "]"); } $result = pg_query ($this->conn->getResource(), sprintf ("SELECT
														d.typname as domname,
														b.typname as basetype,
														d.typlen,
														d.typtypmod,
														d.typnotnull,
														d.typdefault
													FROM pg_type d
														INNER JOIN pg_type b ON b.oid = CASE WHEN d.typndims > 0 then d.typelem ELSE d.typbasetype END
													WHERE
														d.typtype = 'd'
														AND d.typname = '%s'
													ORDER BY d.typname", $strDomain)); if (!$result) { throw new SQLException("Query for domain [" . $strDomain . "] failed.", pg_last_error($this->conn->getResource())); } $row = pg_fetch_assoc ($result); if (!$row) { throw new SQLException ("Domain [" . $strDomain . "] not found."); } $arrDomain = array (); $arrDomain['type'] = $row['basetype']; $arrLengthPrecision = $this->processLengthScale ($row['typtypmod'], $row['basetype']); $arrDomain['length'] = $arrLengthPrecision['length']; $arrDomain['scale'] = $arrLengthPrecision['scale']; $arrDomain['notnull'] = $row['typnotnull']; $arrDomain['default'] = $row['typdefault']; $arrDomain['hasdefault'] = (strlen (trim ($row['typdefault'])) > 0) ? 't' : 'f'; pg_free_result ($result); return $arrDomain; } protected function initForeignKeys() { $result = pg_query ($this->conn->getResource(), sprintf ("SELECT
						      conname,
						      confupdtype,
						      confdeltype,
						      cl.relname as fktab,
						      a2.attname as fkcol,
						      cr.relname as reftab,
						      a1.attname as refcol
						FROM pg_constraint ct
						     JOIN pg_class cl ON cl.oid=conrelid
						     JOIN pg_class cr ON cr.oid=confrelid
						     LEFT JOIN pg_catalog.pg_attribute a1 ON a1.attrelid = ct.confrelid
						     LEFT JOIN pg_catalog.pg_attribute a2 ON a2.attrelid = ct.conrelid
						WHERE
						     contype='f'
						     AND conrelid = %d
						     AND a2.attnum = ct.conkey[1]
						     AND a1.attnum = ct.confkey[1]
						ORDER BY conname", $this->oid)); if (!$result) { throw new SQLException("Could not list foreign keys for table: " . $this->name, pg_last_error($this->conn->getResource())); } while($row = pg_fetch_assoc($result)) { $name = $row['conname']; $local_table = $row['fktab']; $local_column = $row['fkcol']; $foreign_table = $row['reftab']; $foreign_column = $row['refcol']; switch ($row['confupdtype']) { case 'c': $onupdate = ForeignKeyInfo::CASCADE; break; case 'd': $onupdate = ForeignKeyInfo::SETDEFAULT; break; case 'n': $onupdate = ForeignKeyInfo::SETNULL; break; case 'r': $onupdate = ForeignKeyInfo::RESTRICT; break; default: case 'a': $onupdate = ForeignKeyInfo::NONE; break; } switch ($row['confdeltype']) { case 'c': $ondelete = ForeignKeyInfo::CASCADE; break; case 'd': $ondelete = ForeignKeyInfo::SETDEFAULT; break; case 'n': $ondelete = ForeignKeyInfo::SETNULL; break; case 'r': $ondelete = ForeignKeyInfo::RESTRICT; break; default: case 'a': $ondelete = ForeignKeyInfo::NONE; break; } $foreignTable = $this->database->getTable($foreign_table); $foreignColumn = $foreignTable->getColumn($foreign_column); $localTable = $this->database->getTable($local_table); $localColumn = $localTable->getColumn($local_column); if (!isset($this->foreignKeys[$name])) { $this->foreignKeys[$name] = new ForeignKeyInfo($name); } $this->foreignKeys[$name]->addReference($localColumn, $foreignColumn, $ondelete, $onupdate); } $this->fksLoaded = true; } protected function initIndexes() { if (!$this->colsLoaded) $this->initColumns(); $result = pg_query ($this->conn->getResource(), sprintf ("SELECT
													      DISTINCT ON(cls.relname)
													      cls.relname as idxname,
													      indkey,
													      indisunique
													FROM pg_index idx
													     JOIN pg_class cls ON cls.oid=indexrelid
													WHERE indrelid = %d AND NOT indisprimary
													ORDER BY cls.relname", $this->oid)); if (!$result) { throw new SQLException("Could not list indexes keys for table: " . $this->name, pg_last_error($this->conn->getResource())); } while($row = pg_fetch_assoc($result)) { $name = $row["idxname"]; $unique = ($row["indisunique"] == 't') ? true : false; if (!isset($this->indexes[$name])) { $this->indexes[$name] = new IndexInfo($name, $unique); } $arrColumns = explode (' ', $row['indkey']); foreach ($arrColumns as $intColNum) { $result2 = pg_query ($this->conn->getResource(), sprintf ("SELECT a.attname
															FROM pg_catalog.pg_class c JOIN pg_catalog.pg_attribute a ON a.attrelid = c.oid
															WHERE c.oid = '%s' AND a.attnum = %d AND NOT a.attisdropped
															ORDER BY a.attnum", $this->oid, $intColNum)); if (!$result2) { throw new SQLException("Could not list indexes keys for table: " . $this->name, pg_last_error($this->conn->getResource())); } $row2 = pg_fetch_assoc($result2); $this->indexes[$name]->addColumn($this->columns[ $row2['attname'] ]); } } $this->indexesLoaded = true; } protected function initPrimaryKey() { if (!$this->colsLoaded) $this->initColumns(); $result = pg_query($this->conn->getResource(), sprintf ("SELECT
													      DISTINCT ON(cls.relname)
													      cls.relname as idxname,
													      indkey,
													      indisunique
													FROM pg_index idx
													     JOIN pg_class cls ON cls.oid=indexrelid
													WHERE indrelid = %s AND indisprimary
													ORDER BY cls.relname", $this->oid)); if (!$result) { throw new SQLException("Could not list primary keys for table: " . $this->name, pg_last_error($this->conn->getResource())); } while($row = pg_fetch_assoc($result)) { $arrColumns = explode (' ', $row['indkey']); foreach ($arrColumns as $intColNum) { $result2 = pg_query ($this->conn->getResource(), sprintf ("SELECT a.attname
															FROM pg_catalog.pg_class c JOIN pg_catalog.pg_attribute a ON a.attrelid = c.oid
															WHERE c.oid = '%s' AND a.attnum = %d AND NOT a.attisdropped
															ORDER BY a.attnum", $this->oid, $intColNum)); if (!$result2) { throw new SQLException("Could not list indexes keys for table: " . $this->name, pg_last_error($this->conn->getResource())); } $row2 = pg_fetch_assoc($result2); if (!isset($this->primaryKey)) { $this->primaryKey = new PrimaryKeyInfo($row2['attname']); } $this->primaryKey->addColumn($this->columns[ $row2['attname'] ]); } } $this->pkLoaded = true; } }   class QueryDataSet extends DataSet { public function __construct($p1, $selectSql = null) { if ($selectSql !== null) { $this->conn = $p1; $this->selectSql = $selectSql; } else { $this->resultSet = $p1; } } public function getSelectSql() { return $this->selectSql; } }   abstract class ResultSetCommon { protected $fetchmode; protected $conn; protected $result; protected $cursorPos = 0; protected $fields; protected $lowerAssocCase = false; protected $rtrimString = false; public function __construct(Connection $conn, $result, $fetchmode = null) { $this->conn = $conn; $this->result = $result; if ($fetchmode !== null) { $this->fetchmode = $fetchmode; } else { $this->fetchmode = ResultSet::FETCHMODE_ASSOC; } $this->lowerAssocCase = (($conn->getFlags() & Creole::COMPAT_ASSOC_LOWER) === Creole::COMPAT_ASSOC_LOWER); $this->rtrimString = (($conn->getFlags() & Creole::COMPAT_RTRIM_STRING) === Creole::COMPAT_RTRIM_STRING); } public function __destruct() { $this->close(); } public function getIterator() { return new ResultSetIterator($this); } public function getResource() { return $this->result; } public function isLowerAssocCase() { return $this->lowerAssocCase; } public function setFetchmode($mode) { $this->fetchmode = $mode; } public function getFetchmode() { return $this->fetchmode; } public function previous() { $ok = $this->seek($this->cursorPos - 2); if ($ok === false) { $this->beforeFirst(); return false; } return $this->next(); } public function relative($offset) { $pos = $this->cursorPos + ($offset - 1); $ok = $this->seek($pos); if ($ok === false) { if ($pos < 0) { $this->beforeFirst(); } else { $this->afterLast(); } } else { $ok = $this->next(); } return $ok; } public function absolute($pos) { $ok = $this->seek( $pos - 1 ); if ($ok === false) { if ($pos - 1 < 0) { $this->beforeFirst(); } else { $this->afterLast(); } } else { $ok = $this->next(); } return $ok; } public function first() { if($this->cursorPos !== 0) { $this->seek(0); } return $this->next(); } public function last() { if($this->cursorPos !== ($last = $this->getRecordCount() - 1)) { $this->seek( $last ); } return $this->next(); } public function beforeFirst() { $this->cursorPos = 0; } public function afterLast() { $this->cursorPos = $this->getRecordCount() + 1; } public function isAfterLast() { return ($this->cursorPos === $this->getRecordCount() + 1); } public function isBeforeFirst() { return ($this->cursorPos === 0); } public function getCursorPos() { return $this->cursorPos; } public function getRow() { return $this->fields; } public function get($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } return $this->fields[$idx]; } public function getArray($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } return (array) unserialize($this->fields[$idx]); } public function getBoolean($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } return (boolean) $this->fields[$idx]; } public function getBlob($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } $b = new Blob(); $b->setContents($this->fields[$idx]); return $b; } public function getClob($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } $c = new Clob(); $c->setContents($this->fields[$idx]); return $c; } public function getDate($column, $format = '%x') { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } $ts = strtotime($this->fields[$idx]); if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . $column . " to timestamp: " . $this->fields[$idx]); } if ($format === null) { return $ts; } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } public function getFloat($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } return (float) $this->fields[$idx]; } public function getInt($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } return (int) $this->fields[$idx]; } public function getString($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } return ($this->rtrimString ? rtrim($this->fields[$idx]) : (string) $this->fields[$idx]); } public function getTime($column, $format = '%X') { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } $ts = strtotime($this->fields[$idx]); if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . (is_int($column) ? $column + 1 : $column) . " to timestamp: " . $this->fields[$idx]); } if ($format === null) { return $ts; } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } public function getTimestamp($column, $format = 'Y-m-d H:i:s') { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } $ts = strtotime($this->fields[$idx]); if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . $column . " to timestamp: " . $this->fields[$idx]); } if ($format === null) { return $ts; } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } }   class SQLiteTableInfo extends TableInfo { protected $resource; protected $i2resource; protected function prepTable() { $sql = "PRAGMA table_info('".$this->name."')"; $this->resource = sqlite_query($this->conn->getResource(), $sql); } protected function getRow() { return sqlite_fetch_array($this->resource, SQLITE_ASSOC); } protected function prepIndex1() { $sql = "PRAGMA index_list('".$this->name."')"; $this->resource = sqlite_query($this->conn->getResource(), $sql); } protected function prepIndex2($name) { $this->i2resource = sqlite_query($this->conn->getResource(), "PRAGMA index_info('$name')"); } protected function getI2Row() { return sqlite_fetch_array($this->i2resource, SQLITE_ASSOC); } protected function initColumns() { $this->prepTable(); while($row = $this->getRow()) { $name = $row['name']; $fulltype = $row['type']; $size = null; $precision = null; $scale = null; if (preg_match('/^([^\(]+)\(\s*(\d+)\s*,\s*(\d+)\s*\)$/', $fulltype, $matches)) { $type = $matches[1]; $precision = $matches[2]; $scale = $matches[3]; } elseif (preg_match('/^([^\(]+)\(\s*(\d+)\s*\)$/', $fulltype, $matches)) { $type = $matches[1]; $size = $matches[2]; } else { $type = $fulltype; } $is_auto_increment = ($row['pk'] == 1 && $fulltype == 'INTEGER'); $not_null = $row['notnull']; $is_nullable = !$not_null; $default_val = $row['dflt_value']; $this->columns[$name] = new ColumnInfo($this, $name, SQLiteTypes::getType($type), $type, $size, $precision, $scale, $is_nullable, $default_val, $is_auto_increment); if( $this->name == 'products' && $name == 'ProductID' ) { } if (($row['pk'] == 1) || (strtolower($type) == 'integer primary key')) { if ($this->primaryKey === null) { $this->primaryKey = new PrimaryKeyInfo($name); } $this->primaryKey->addColumn($this->columns[ $name ]); } } $this->colsLoaded = true; } protected function initPrimaryKey() { if (!$this->colsLoaded) $this->initColumns(); $this->pkLoaded = true; } protected function initIndexes() { if (!$this->colsLoaded) $this->initColumns(); $this->prepIndex1(); while($row = $this->getRow()) { $name = $row['name']; $this->indexes[$name] = new IndexInfo($name); $this->prepIndex2($name); while($row2 = $this->getI2Row()) { $colname = $row2['name']; $this->indexes[$name]->addColumn($this->columns[ $colname ]); } } $this->indexesLoaded = true; } protected function initForeignKeys() { if (!$this->colsLoaded) $this->initColumns(); $this->fksLoaded = true; } }   class TableDataSet extends DataSet { private $tableName; private $tableInfo; private $optimisticLockingCol; private $where; private $order; private $other; private $refreshOnSave = false; public function __construct(Connection $conn, $tableName, $p3 = null, $p4 = null) { $this->conn = $conn; $this->columns = "*"; $this->tableName = $tableName; if ($p4 !== null) { $this->columns = $p3; $this->keyDef = $p4; } elseif ($p3 !== null) { if ($p3 instanceof KeyDef) { $this->keyDef = $p3; } else { $this->columns = $p3; } } } public function tableName() { return $this->tableName; } public function tableInfo() { if ($this->tableInfo === null) { $this->tableInfo = $this->conn->getDatabaseInfo()->getTable($this->tableName); } return $this->tableInfo; } public function fetchRecords($p1 = 0, $p2 = null) { $this->buildSelectString(); return parent::fetchRecords($p1, $p2); } public function addRecord() { $rec = new Record($this, true); $rec->markForInsert(); $this->records[] = $rec; return $rec; } public function save() { $j = 0; foreach($this->records as $rec) { $rec->save(); $j++; } $this->removeDeletedRecords(); return $j; } public function removeDeletedRecords() { $new_recs = array(); foreach($this->records as $rec) { if (!$rec->isAZombie()) { $new_recs[] = $rec; } } $this->records = $new_recs; } public function setOptimisticLockingColumn($olc) { $this->optimisticLockingCol = $olc; } public function optimisticLockingCol() { return $this->optimisticLockingCol; } public function where($where) { if ($where == null) { throw new DataSetException("null not allowed for where clause"); } $this->where = $where; return $this; } public function getWhere() { return $this->where; } public function order($order) { if ($order === null) { throw new DataSetException("null not allowed for order clause"); } $this->order = $order; return $this; } public function getOrder() { return $this->order; } public function other($other) { if ($other === null) { throw new DataSetException("null not allowed for other clause"); } $this->other = $other; return $this; } public function getOther() { return $this->other; } public function refresh() { foreach($this->records as $rec) { $rec->refresh($this->conn); } } public function setRefreshOnSave($v) { $this->refreshOnSave = $v; } public function refreshOnSave() { return $this->refreshOnSave; } public function getSelectSql() { return $this->selectSql; } private function buildSelectString () { $this->selectSql = "SELECT "; $this->selectSql .= $this->columns; $this->selectSql .= " FROM " . $this->tableName; if ($this->where !== null && $this->where !== "") { $this->selectSql .= " WHERE " . $this->where; } if ($this->order !== null && $this->order !== "") { $this->selectSql .= " ORDER BY " . $this->order; } if ($this->other !== null && $this->other !== "") { $this->selectSql .= $this->other; } } }   class MSSQLDatabaseInfo extends DatabaseInfo { protected function initTables() { $dsn = $this->conn->getDSN(); if (!@mssql_select_db($this->dbname, $this->conn->getResource())) { throw new SQLException('No database selected'); } $result = mssql_query("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME <> 'dtproperties'", $this->conn->getResource()); if (!$result) { throw new SQLException("Could not list tables", mssql_get_last_message()); } while ($row = mssql_fetch_row($result)) { $this->tables[strtoupper($row[0])] = new MSSQLTableInfo($this, $row[0]); } } protected function initSequences() { } }   class MSSQLResultSet extends ResultSetCommon implements ResultSet { function seek($rownum) { $actual = $rownum; if (!@mssql_data_seek($this->result, $actual)) { return false; } $this->cursorPos = $rownum; return true; } function next() { if ($this->fetchmode === ResultSet::FETCHMODE_ASSOC) { $this->fields = mssql_fetch_assoc($this->result); } else { $this->fields = mssql_fetch_row($this->result); } if (!$this->fields) { if ($errmsg = mssql_get_last_message()) { throw new SQLException("Error fetching result", $errmsg); } else { $this->afterLast(); return false; } } if ($this->fetchmode === ResultSet::FETCHMODE_ASSOC && $this->lowerAssocCase) { $this->fields = array_change_key_case($this->fields, CASE_LOWER); } $this->cursorPos++; return true; } function getRecordCount() { $rows = @mssql_num_rows($this->result); if ($rows === null) { throw new SQLException('Error getting record count', mssql_get_last_message()); } return $rows; } public function getTime($column, $format = '%X') { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } $fvalue = $this->fields[$idx]; $fvalue = str_replace('1900-01-01 ', '', $fvalue); $ts = strtotime($fvalue); if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . (is_int($column) ? $column + 1 : $column) . " to timestamp: " . $this->fields[$idx]); } if ($format === null) { return $ts; } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } function close() { $ret = @mssql_free_result($this->result); $this->result = false; $this->fields = array(); $this->limit = 0; $this->offset = 0; } }   abstract class MySQLDatabaseInfoBase extends DatabaseInfo { protected $driverName; protected $tableClassName; protected function initTables() { $sql = "SHOW TABLES FROM `" . $this->dbname . "`"; $result = $this->sqlQuery($sql); if (!$result) { throw new SQLException("Could not list tables", mysql_error($this->conn->getResource())); } while ($row = $this->fetchRow($result) ) { $this->tables[strtoupper($row[0])] = new $this->tableClassName($this, $row[0]); } $this->tablesLoaded = true; } protected function initSequences() { } abstract function sqlQuery( $sql ); abstract function fetchRow($result); abstract function fetchAssoc($result); abstract function selectDb($dbName); }   class MySQLiResultSet extends ResultSetCommon implements ResultSet { public function seek($rownum) { if (!@mysqli_data_seek($this->result, $rownum)) { return false; } $this->cursorPos = $rownum; return true; } public function next() { $this->fields = mysqli_fetch_array($this->result, $this->fetchmode); $resource = $this->conn->getResource(); if (!$this->fields) { $errno = mysqli_errno($resource); if (!$errno) { $this->afterLast(); return false; } else { throw new SQLException("Error fetching result", mysqli_error($resource)); } } if ($this->fetchmode === ResultSet::FETCHMODE_ASSOC && $this->lowerAssocCase) { $this->fields = array_change_key_case($this->fields, CASE_LOWER); } $this->cursorPos++; return true; } public function getRecordCount() { $rows = @mysqli_num_rows($this->result); if ($rows === null) { throw new SQLException("Error fetching num rows", mysqli_error($this->conn->getResource())); } return (int) $rows; } public function close() { @mysqli_free_result($this->result); $this->fields = array(); } public function getString($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } return (string) $this->fields[$idx]; } public function getTimestamp($column, $format='Y-m-d H:i:s') { if (is_int($column)) { $column--; } if (!array_key_exists($column, $this->fields)) { throw new SQLException("Invalid resultset column: " . (is_int($column) ? $column + 1 : $column)); } if ($this->fields[$column] === null || $this->fields[$column] == '0000-00-00 00:00:00') { return null; } $ts = strtotime($this->fields[$column]); if ($ts === -1 || $ts === false) { if (preg_match('/([\d]{4})([\d]{2})([\d]{2})([\d]{2})([\d]{2})([\d]{2})/', $this->fields[$column], $matches)) { $ts = mktime($matches[4], $matches[5], $matches[6], $matches[2], $matches[3], $matches[1]); } } if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . (is_int($column) ? $column + 1 : $column) . " to timestamp: " . $this->fields[$column]); } if ($format === null) { return $ts; } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } public function getDate($column, $format = '%X') { $idx = (is_int($column) ? $column - 1 : $column); if (array_key_exists($idx, $this->fields) && $this->fields[$idx] == '0000-00-00') return null; return parent::getDate($column, $format); } }   class MySQLiTableInfo extends MySQLTableInfoBase { }   class MySQLResultSet extends ResultSetCommon implements ResultSet { public function seek($rownum) { if (!@mysql_data_seek($this->result, $rownum)) { return false; } $this->cursorPos = $rownum; return true; } public function next() { $this->fields = mysql_fetch_array($this->result, $this->fetchmode); if (!$this->fields) { $errno = mysql_errno($this->conn->getResource()); if (!$errno) { $this->afterLast(); return false; } else { throw new SQLException("Error fetching result", mysql_error($this->conn->getResource())); } } if ($this->fetchmode === ResultSet::FETCHMODE_ASSOC && $this->lowerAssocCase) { $this->fields = array_change_key_case($this->fields, CASE_LOWER); } $this->cursorPos++; return true; } function getRecordCount() { $rows = @mysql_num_rows($this->result); if ($rows === null) { throw new SQLException("Error fetching num rows", mysql_error($this->conn->getResource())); } return (int) $rows; } function close() { if(is_resource($this->result)) @mysql_free_result($this->result); $this->fields = array(); } public function getString($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } return (string) $this->fields[$idx]; } function getTimestamp($column, $format='Y-m-d H:i:s') { if (is_int($column)) { $column--; } if (!array_key_exists($column, $this->fields)) { throw new SQLException("Invalid resultset column: " . (is_int($column) ? $column + 1 : $column)); } if ($this->fields[$column] === null || $this->fields[$column] == '0000-00-00 00:00:00') { return null; } $ts = strtotime($this->fields[$column]); if ($ts === -1 || $ts === false) { if (preg_match('/([\d]{4})([\d]{2})([\d]{2})([\d]{2})([\d]{2})([\d]{2})/', $this->fields[$column], $matches)) { $ts = mktime($matches[4], $matches[5], $matches[6], $matches[2], $matches[3], $matches[1]); } } if ($ts === -1 || $ts === false) { throw new SQLException("Unable to convert value at column " . (is_int($column) ? $column + 1 : $column) . " to timestamp: " . $this->fields[$column]); } if ($format === null) { return $ts; } if (strpos($format, '%') !== false) { return strftime($format, $ts); } else { return date($format, $ts); } } public function getDate($column, $format = '%X') { $idx = (is_int($column) ? $column - 1 : $column); if (array_key_exists($idx, $this->fields) && $this->fields[$idx] == '0000-00-00') return null; return parent::getDate($column, $format); } }   class MySQLTableInfo extends MySQLTableInfoBase { }   class OCI8DatabaseInfo extends DatabaseInfo { private $schema; public function __construct(Connection $conn) { parent::__construct($conn); $dsn = $conn->getDSN(); if (isset($dsn['schema'])) { $this->schema = $dsn['schema']; } else { $this->schema = $dsn['username']; } $this->schema = strtoupper( $this->schema ); } public function getSchema() { return $this->schema; } protected function initTables() { $sql = "SELECT table_name
            FROM all_tables
            WHERE owner = '{$this->schema}'"; $statement = @oci_parse($this->conn->getResource(),$sql); $success = @oci_execute($statement,OCI_DEFAULT); if (!$success) { throw new SQLException("Could not get tables", $this->conn->getResource()->nativeError($statement)); } while ( $statement && $row = oci_fetch_assoc( $statement ) ) { $row = array_change_key_case($row,CASE_LOWER); $this->tables[strtoupper($row['table_name'])] = new OCI8TableInfo($this,$row['table_name']); } } protected function initSequences() { } }   class OCI8ResultSet extends ResultSetCommon implements ResultSet { function seek($rownum) { if ( $rownum < $this->cursorPos ) { throw new SQLException( 'Oracle ResultSet is FORWARD-ONLY' ); } while ( $this->cursorPos < $rownum ) { $this->next(); } $this->cursorPos = $rownum; return true; } function next() { $this->fields = oci_fetch_array( $this->result , $this->fetchmode + OCI_RETURN_NULLS + OCI_RETURN_LOBS ); if ( ! $this->fields ) { $error = oci_error( $this->result ); if ( ! $error ) { $this->afterLast(); return false; } else { throw new SQLException( 'Error fetching result' , $error[ 'code' ] . ': ' . $error[ 'message' ] ); } } if ($this->fetchmode === ResultSet::FETCHMODE_ASSOC && $this->lowerAssocCase) { $this->fields = array_change_key_case($this->fields, CASE_LOWER); } $this->cursorPos++; return true; } function getRecordCount() { $rows = oci_num_rows( $this->result ); if ( $rows === false ) { throw new SQLException( 'Error fetching num rows' , $this->conn->nativeError( $this->result ) ); } return ( int ) $rows; } function close() { $this->fields = array(); @oci_free_statement( $this->result ); } }   class ODBCDatabaseInfo extends DatabaseInfo { protected function initTables() { $result = @odbc_tables($this->conn->getResource()); if (!$result) throw new SQLException('Could not list tables', $this->conn->nativeError()); while (odbc_fetch_row($result)) { $tablename = strtoupper(odbc_result($result, 'TABLE_NAME')); $this->tables[$tablename] = new ODBCTableInfo($this, $tablename); } @odbc_free_result($result); } protected function initSequences() { } }   abstract class ODBCResultSetCommon extends ResultSetCommon { protected $offset = 0; protected $limit = 0; public function __construct(Connection $conn, $result, $fetchmode = null) { parent::__construct($conn, $result, $fetchmode); } public function close() { $this->result = null; $this->conn = null; $this->fetchmode = null; $this->cursorPos = 0; $this->fields = null; $this->lowerAssocCase = false; $this->limit = 0; $this->offset = 0; } public function _setOffset($offset) { $this->offset = $offset; } public function _setLimit($limit) { $this->limit = $limit; } function getFieldNum($colname) { $fieldnum = 0; if ($this->fetchmode == ResultSet::FETCHMODE_ASSOC) { $keys = array_keys($this->fields); $fieldnum = array_search($colname, $keys); } return $fieldnum; } protected function readLobData($column, $binmode, $curdata = null) { $fldNum = (is_int($column) ? $column : getFieldNum($column)); $data = $curdata; $newdata = null; odbc_binmode($this->result->getHandle(), $binmode); odbc_longreadlen($this->result->getHandle(), 4096); while (1) { $newdata = odbc_result($this->result->getHandle(), $fldNum); if ($newdata === false) break; else $data .= $newdata; } odbc_binmode($this->result->getHandle(), ODBC_BINMODE_PASSTHRU); odbc_longreadlen($this->result->getHandle(), ini_get('odbc.defaultlrl')); $data = rtrim($data, "\x0"); return $data; } protected function checkFetchMode(&$row) { if ($this->fetchmode == ResultSet::FETCHMODE_ASSOC) { $newrow = array(); for ($i = 0, $n = count($row); $i < $n; $i++) { $colname = @odbc_field_name($this->result->getHandle(), $i+1); if ($this->lowerAssocCase) { $colname = strtolower($colname); } $newrow[$colname] = $row[$i]; } $row =& $newrow; } return $row; } }   class PdoResultSetCommon extends ResultSetCommon{ protected $numRows = -1; private $pdo_fetch_style; private $oldCursorPos = -1; private $in_cursor_recover = false; public function __construct(Connection $conn, $result, $fetchmode = null) { parent::__construct($conn, $result, $fetchmode ); $this->pdo_fetch_style = $this->getFetchMode() == ResultSet::FETCHMODE_ASSOC ? PDO::FETCH_ASSOC : PDO::FETCH_NUM; } public function getIterator() { throw new SQLException('PdoResultSet::getIterator() not yet implimented'); } private function closedCursorRecover() { if( $this->oldCursorPos != -1 ) { try { $this->result->execute(); } catch( PDOException $e ) { throw new SQLException('Could not re-execute PDO statement', $e->getMessage()); } $this->in_cursor_recover = true; $this->seek( $this->oldCursorPos ); $this->oldCursorPos = -1; $this->in_cursor_recover = false; $this->conn->openResultSet( $this ); } } public function relative($offset) { $this->closedCursorRecover(); return parent::relative($offset); } public function absolute($pos) { $this->closedCursorRecover(); return parent::absolute($pos); } public function first() { $this->closedCursorRecover(); return parent::first(); } public function last() { $this->closedCursorRecover(); return parent::last(); } public function getCursorPos() { $this->closedCursorRecover(); return parent::getCursorPos(); } function seek($rownum) { if ( $rownum < $this->cursorPos ) { throw new SQLException( 'PDO ResultSet is FORWARD-ONLY' ); } $ok = true; while ( ($this->cursorPos < $rownum) && $ok ) { $result = $this->_next(); $ok = empty($result) ? false : true; } if( $ok ) { $this->cursorPos = $rownum; return true; } else { return false; } } private function _next() { try { $result = $this->result->fetch( $this->pdo_fetch_style ); if( empty($result) ) { $this->afterLast(); $this->conn->openResultSet( false ); return false; } } catch( PDOException $e ) { throw new SQLException('Error fetching result', $e->getMessage()); } $this->cursorPos++; return $result; } function next() { $this->fields = $this->_next(); return empty($this->fields) ? false : true; } public function getRecordCount() { if( $this->numRows == -1 ) { $sql = $this->result->queryString; $pdo_stmt = $this->conn->executePdoQuery( $sql ); $this->numRows = count($pdo_stmt->fetchAll()); } return $this->numRows; } public function close() { $this->closeCursor(); unset($this->result); $this->fields = array(); } public function closeCursor() { $this->oldCursorPos = $this->cursorPos; $this->cursorPos = 0; $this->conn->openResultSet(false); if( !empty( $this->result ) && $this->result instanceof PDOStatement ) { $this->result->closeCursor(); } } }   class PdoSQLiteTableInfo extends SQLiteTableInfo { protected $statement; protected $i2statement; protected function prepTable() { $sql = 'PRAGMA table_info('.$this->name.')'; try { $this->statement = $this->dblink->prepare($sql); $this->statement->execute(); } catch( PDOException $e ) { throw new SQLException('Could not get table info', $e->getMessage(), $sql); } } protected function getRow() { return $this->statement->fetch(PDO::FETCH_ASSOC); } protected function prepIndex1() { $sql = "PRAGMA index_list('".$this->name."')"; try { $this->statement = $this->dblink->prepare($sql); $this->statement->execute(); } catch( PDOException $e ) { throw new SQLException('Could not get index info', $e->getMessage(), $sql); } } protected function prepIndex2($name) { $sql = "PRAGMA index_info('$name')"; try { $this->i2statement = $this->dblink->prepare($sql); $this->i2statement->execute(); } catch( PDOException $e ) { throw new SQLException("Could not get index info for: $name", $e->getMessage(), $sql); } } protected function getI2Row() { return $this->i2statement->fetch(PDO::FETCH_ASSOC); } }   class PgSQLDatabaseInfo extends DatabaseInfo { protected function initTables() { $result = pg_query ($this->conn->getResource(), "SELECT version() as ver"); if (!$result) { throw new SQLException ("Failed to select database version"); } $row = pg_fetch_assoc ($result, 0); $arrVersion = sscanf ($row['ver'], '%*s %d.%d'); $version = sprintf ("%d.%d", $arrVersion[0], $arrVersion[1]); $arrVersion = null; $row = null; pg_free_result ($result); $result = null; $result = pg_query($this->conn->getResource(), "SELECT c.oid,
														case when n.nspname='public' then c.relname else n.nspname||'.'||c.relname end as relname
														FROM pg_class c join pg_namespace n on (c.relnamespace=n.oid)
														WHERE c.relkind = 'r'
														  AND n.nspname NOT IN ('information_schema','pg_catalog')
														  AND n.nspname NOT LIKE 'pg_temp%'
														  AND n.nspname NOT LIKE 'pg_toast%'
														ORDER BY relname"); if (!$result) { throw new SQLException("Could not list tables", pg_last_error($this->dblink)); } while ($row = pg_fetch_assoc($result)) { $this->tables[strtoupper($row['relname'])] = new PgSQLTableInfo($this, $row['relname'], $version, $row['oid']); } $this->tablesLoaded = true; } protected function initSequences() { $this->sequences = array(); $result = pg_query($this->conn->getResource(), "SELECT c.oid,
														case when n.nspname='public' then c.relname else n.nspname||'.'||c.relname end as relname
														FROM pg_class c join pg_namespace n on (c.relnamespace=n.oid)
														WHERE c.relkind = 'S'
														  AND n.nspname NOT IN ('information_schema','pg_catalog')
														  AND n.nspname NOT LIKE 'pg_temp%'
														  AND n.nspname NOT LIKE 'pg_toast%'
														ORDER BY relname"); if (!$result) { throw new SQLException("Could not list sequences", pg_last_error($this->dblink)); } while ($row = pg_fetch_assoc($result)) { $obj = new stdClass; $obj->name = $row['relname']; $obj->oid = $row['oid']; $this->sequences[strtoupper($row['relname'])] = $obj; } } }   class PgSQLResultSet extends ResultSetCommon implements ResultSet { public function seek($rownum) { if ($rownum < 0) { return false; } $this->cursorPos = $rownum; return true; } public function next() { $this->fields = @pg_fetch_array($this->result, $this->cursorPos, $this->fetchmode); if (!$this->fields) { $err = @pg_result_error($this->result); if (!$err) { $this->afterLast(); return false; } else { throw new SQLException("Error fetching result", $err); } } if ($this->fetchmode === ResultSet::FETCHMODE_ASSOC && $this->lowerAssocCase) { $this->fields = array_change_key_case($this->fields, CASE_LOWER); } $this->cursorPos++; return true; } public function getRecordCount() { $rows = @pg_num_rows($this->result); if ($rows === null) { throw new SQLException("Error fetching num rows", pg_result_error($this->result)); } return (int) $rows; } public function close() { $this->fields = array(); @pg_free_result($this->result); } private function strToArray($str) { $str = substr($str, 1, -1); $res = array(); $subarr = array(); $in_subarr = 0; $toks = explode(',', $str); foreach($toks as $tok) { if ($in_subarr > 0) { $subarr[$in_subarr][] = $tok; if ('}' === substr($tok, -1, 1)) { $res[] = $this->strToArray(implode(',', $subarr[$in_subarr])); $in_subarr--; } } elseif ($tok{0} === '{') { if ('}' !== substr($tok, -1, 1)) { $in_subarr++; $subarr[$in_subarr] = array(); $subarr[$in_subarr][] = $tok; } else { $res[] = $this->strToArray($tok); } } else { $val = trim($tok, '"'); $res[] = $val; } } return $res; } public function getArray($column) { if (is_int($column)) { $column--; } if (!array_key_exists($column, $this->fields)) { throw new SQLException("Invalid resultset column: " . (is_int($column) ? $column + 1 : $column)); } if ($this->fields[$column] === null) { return null; } return $this->strToArray($this->fields[$column]); } public function getBlob($column) { if (is_int($column)) { $column--; } if (!array_key_exists($column, $this->fields)) { throw new SQLException("Invalid resultset column: " . (is_int($column) ? $column + 1 : $column)); } if ($this->fields[$column] === null) { return null; } $b = new Blob(); $b->setContents(pg_unescape_bytea($this->fields[$column])); return $b; } public function getBoolean($column) { if (is_int($column)) { $column--; } if (!array_key_exists($column, $this->fields)) { throw new SQLException("Invalid resultset column: " . (is_int($column) ? $column + 1 : $column)); } if ($this->fields[$column] === null) { return null; } return ($this->fields[$column] === 't'); } }   class Query { protected $conn; protected $sql; protected $max = 0; protected $start = 0; public function __construct(Connection $conn, $sql = null) { $this->conn = $conn; $this->sql = $sql; } public function setSql($sql) { $this->sql = $sql; } public function setStart($v) { $this->start = $v; } public function setMax($v) { $this->max = $v; } public function getRows() { $stmt = $this->conn->createStatement(); if ($this->max) $stmt->setLimit($this->max); if ($this->start) $stmt->setOffset($this->start); $rs = $stmt->executeQuery($this->sql); $results = array(); while($rs->next()) { $results[] = $rs->getRow(); } $rs->close(); $stmt->close(); return $results; } public function getRow() { $stmt = $this->conn->createStatement(); if ($this->max) $stmt->setLimit($this->max); if ($this->start) $stmt->setOffset($this->start); $rs = $stmt->executeQuery($this->sql); $rs->next(); $results = $rs->getRow(); $rs->close(); $stmt->close(); return $results; } public function getCol() { $stmt = $this->conn->createStatement(); if ($this->max) $stmt->setLimit($this->max); if ($this->start) $stmt->setOffset($this->start); $rs = $stmt->executeQuery($this->sql); $results = array(); while($rs->next()) { $results[] = array_shift($rs->getRow()); } $rs->close(); $stmt->close(); return $results; } public function getOne() { $stmt = $this->conn->createStatement(); if ($this->max) $stmt->setLimit($this->max); if ($this->start) $stmt->setOffset($this->start); $rs = $stmt->executeQuery($this->sql); $rs->next(); $row = $rs->getRow(); if( is_array( $row ) ) { $res = array_shift($row); } else { $res = null; } $rs->close(); $stmt->close(); return $res; } public function getAssoc($scalar = false) { $stmt = $this->conn->createStatement(); if ($this->max) $stmt->setLimit($this->max); if ($this->start) $stmt->setOffset($this->start); $rs = $stmt->executeQuery($this->sql); $numcols = null; $results = array(); while($rs->next()) { $fields = $rs->getRow(); if ($numcols === null) { $numcols = count($fields); } if (!$scalar || ($numcols > 2)) { $results[ array_shift($fields) ] = array_values($fields); } else { $results[ array_shift($fields) ] = array_shift($fields); } } $rs->close(); $stmt->close(); return $results; } public function getDataSet() { $qds = new QueryDataSet($this->conn, $this->sql); $qds->fetchRecords($this->start, $this->max); return $qds; } }   class SQLiteDatabaseInfo extends DatabaseInfo { protected function initTables() { $sql = "SELECT name FROM sqlite_master WHERE type='table' UNION ALL SELECT name FROM sqlite_temp_master WHERE type='table' ORDER BY name;"; $result = sqlite_query($this->dblink, $sql); if (!$result) { throw new SQLException("Could not list tables", sqlite_last_error($this->dblink)); } while ($row = sqlite_fetch_array($result)) { $this->tables[strtoupper($row[0])] = new SQLiteTableInfo($this, $row[0]); } } protected function initSequences() { } }   class SQLiteResultSet extends ResultSetCommon implements ResultSet { public function getIterator() { return new SQLiteResultSetIterator($this); } public function seek($rownum) { if (!@sqlite_seek($this->result, $rownum)) { return false; } $this->cursorPos = $rownum; return true; } function next() { $this->fields = sqlite_fetch_array($this->result, $this->fetchmode); if (!$this->fields) { $errno = sqlite_last_error($this->conn->getResource()); if (!$errno) { $this->afterLast(); return false; } else { throw new SQLException("Error fetching result", sqlite_error_string($errno)); } } $keys = array_keys($this->fields); foreach( $keys as $key ) { if( ($pos = strpos($key, '.')) !== false ) { $newkey = substr($key, $pos + 1 ); $this->fields[$newkey] = $this->fields[$key]; unset($this->fields[$key]); } } $this->cursorPos++; return true; } public function getRecordCount() { $rows = @sqlite_num_rows($this->result); if ($rows === null) { throw new SQLException("Error fetching num rows", sqlite_error_string(sqlite_last_error($this->conn->getResource()))); } return (int) $rows; } public function getBlob($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } if ($this->fields[$idx] === null) { return null; } $b = new Blob(); $b->setContents(sqlite_udf_decode_binary($this->fields[$idx])); return $b; } public function close() { $this->fields = array(); $this->result = null; } }   class MSSQLConnection extends ConnectionCommon implements Connection { private $database; function connect($dsninfo, $flags = 0) { if (!extension_loaded('mssql') && !extension_loaded('sybase') && !extension_loaded('sybase_ct')) { throw new SQLException('mssql extension not loaded'); } $this->dsn = $dsninfo; $this->flags = $flags; $persistent = ($flags & Creole::PERSISTENT === Creole::PERSISTENT); $user = $dsninfo['username']; $pw = $dsninfo['password']; $dbhost = $dsninfo['hostspec'] ? $dsninfo['hostspec'] : 'localhost'; if (PHP_OS == "WINNT" || PHP_OS == "WIN32") { $portDelimiter = ","; } else { $portDelimiter = ":"; } if(!empty($dsninfo['port'])) { $dbhost .= $portDelimiter.$dsninfo['port']; } else { $dbhost .= $portDelimiter.'1433'; } $connect_function = $persistent ? 'mssql_pconnect' : 'mssql_connect'; if ($dbhost && $user && $pw) { $conn = @$connect_function($dbhost, $user, $pw); } elseif ($dbhost && $user) { $conn = @$connect_function($dbhost, $user); } else { $conn = @$connect_function($dbhost); } if (!$conn) { throw new SQLException('connect failed', mssql_get_last_message()); } if ($dsninfo['database']) { if (!@mssql_select_db($dsninfo['database'], $conn)) { throw new SQLException('No database selected'); } $this->database = $dsninfo['database']; } $this->dblink = $conn; } public function getDatabaseInfo() { return new MSSQLDatabaseInfo($this); } public function getIdGenerator() { return new MSSQLIdGenerator($this); } public function prepareStatement($sql) { return new MSSQLPreparedStatement($this, $sql); } public function createStatement() { return new MSSQLStatement($this); } public function applyLimit(&$sql, $offset, $limit) { preg_match('/\A(.*)select(.*)from/si',$sql,$select_segment); if(count($select_segment>0)) { $original_select = $select_segment[0]; } else { return; } $modified_select = substr_replace($original_select, null, stristr($original_select,'SELECT') , 6 ); $sql = str_replace($original_select , null, $sql); preg_match('/order by(.*)\Z/si',$sql,$order_segment); if(count($order_segment)>0) { $order_by = $order_segment[0]; } else { $select_items = split(',',trim(substr($modified_select,0,strlen($modified_select)-4))); if(count($select_items)>0) { $item_number = 0; $order_by = null; while($order_by === null && $item_number<count($select_items)) { if(!strstr($select_items[$item_number],'*')) { if (strstr($select_items[$item_number],'(')) { $aggregateFieldName = array(); if (count($aggregateFieldName) == 0) { $select_items[$item_number].=' AS _creole_order_field'; $aggregateFieldName = array('_creole_order_field'); } $order_by = 'ORDER BY ' . $aggregateFieldName[0] . ' ASC'; } else { $order_by = 'ORDER BY ' . $select_items[$item_number] . ' ASC'; } } $item_number++; } } $modified_select = ' '.join(', ', $select_items).' FROM'; if($order_by === null) { $fieldSql = 'SELECT TOP 1 '.$modified_select.$sql; $fieldStmt = $this->prepareStatement($fieldSql); $fieldRs = $fieldStmt->executeQuery(); $fieldRs->next(); $fields = array_keys($fieldRs->getRow()); $order_by = 'ORDER BY ' . $fields[0] . ' ASC'; } $sql.= ' '.$order_by; } $inverted_order = ''; $order_columns = split(',',str_ireplace('order by ','',$order_by)); $original_order_by = $order_by; $order_by = ''; foreach($order_columns as $column) { $column = array_reverse(split("\.",$column)); $column = $column[0]; if(strlen($inverted_order)>0){ $order_by.= ', '; $inverted_order.=', '; } if(stristr($column,' desc')) { $order_by .= $column; $inverted_order .= str_ireplace(' desc',' ASC',$column); } elseif(stristr($column,' asc')) { $order_by .= $column; $inverted_order .= str_ireplace(' asc',' DESC',$column); } else { $order_by .= $column; $inverted_order .= $column .' DESC'; } } $order_by = 'ORDER BY ' . $order_by; $inverted_order = 'ORDER BY ' . $inverted_order; $modified_sql = ""; if ( $limit > 0 ) { $modified_sql = 'SELECT * FROM ('; $modified_sql.= 'SELECT TOP '.$limit.' * FROM ('; $modified_sql.= 'SELECT TOP '.($limit+$offset).' '.$modified_select.$sql; $modified_sql.= ') OffsetSet '.$inverted_order.') LimitSet '.$order_by; } else { $countSql = count($order_segment)>0 ? str_replace($order_segment[0] , null, $sql) : $sql; $countStmt = $this->prepareStatement("SELECT COUNT(*) FROM $countSql"); $countRs = $countStmt->executeQuery(ResultSet::FETCHMODE_NUM); $countRs->next(); $rowCount = $countRs->getInt(1); $modified_sql = 'SELECT * FROM ('; $modified_sql.= 'SELECT TOP '.($rowCount-$offset).' * FROM ('; $modified_sql.= 'SELECT TOP 100 PERCENT '.$modified_select.$sql; $modified_sql.= ') OffsetSet '.$inverted_order.') LimitSet '.$order_by; } $sql = $modified_sql; } function close() { $ret = @mssql_close($this->dblink); $this->dblink = null; return $ret; } function executeQuery($sql, $fetchmode = null) { $this->lastQuery = $sql; if (!@mssql_select_db($this->database, $this->dblink)) { throw new SQLException('No database selected'); } $result = @mssql_query($sql, $this->dblink); if (!$result) { throw new SQLException('Could not execute query', mssql_get_last_message()); } return new MSSQLResultSet($this, $result, $fetchmode); } function executeUpdate($sql) { $this->lastQuery = $sql; if (!mssql_select_db($this->database, $this->dblink)) { throw new SQLException('No database selected'); } $result = @mssql_query($sql, $this->dblink); if (!$result) { throw new SQLException('Could not execute update', mssql_get_last_message(), $sql); } return $this->getUpdateCount(); } protected function beginTrans() { $result = @mssql_query('BEGIN TRAN', $this->dblink); if (!$result) { throw new SQLException('Could not begin transaction', mssql_get_last_message()); } } protected function commitTrans() { if (!@mssql_select_db($this->database, $this->dblink)) { throw new SQLException('No database selected'); } $result = @mssql_query('COMMIT TRAN', $this->dblink); if (!$result) { throw new SQLException('Could not commit transaction', mssql_get_last_message()); } } protected function rollbackTrans() { if (!@mssql_select_db($this->database, $this->dblink)) { throw new SQLException('no database selected'); } $result = @mssql_query('ROLLBACK TRAN', $this->dblink); if (!$result) { throw new SQLException('Could not rollback transaction', mssql_get_last_message()); } } function getUpdateCount() { $res = @mssql_query('select @@rowcount', $this->dblink); if (!$res) { throw new SQLException('Unable to get affected row count', mssql_get_last_message()); } $ar = @mssql_fetch_row($res); if (!$ar) { $result = 0; } else { @mssql_free_result($res); $result = $ar[0]; } return $result; } function prepareCall($sql) { $stmt = mssql_init($sql); if (!$stmt) { throw new SQLException('Unable to prepare statement', mssql_get_last_message(), $sql); } return new MSSQLCallableStatement($this, $stmt); } }   class MySQLDatabaseInfo extends MySQLDatabaseInfoBase { protected $driverName = 'mysql'; protected $tableClassName = 'MySQLTableInfo'; function sqlQuery( $sql ) { return @mysql_query( $sql, $this->conn->getResource()); } function fetchRow($result) { return mysql_fetch_row($result); } function fetchAssoc($result) { return mysql_fetch_assoc($result); } function selectDb($dbName) { return @mysql_select_db($dbName, $this->conn->getResource()); } }   class MySQLiDatabaseInfo extends MySQLDatabaseInfoBase { protected $driverName = 'mysqli'; protected $tableClassName = 'MySQLiTableInfo'; function sqlQuery( $sql ) { return @mysqli_query( $this->conn->getResource(), $sql); } function fetchRow($result) { return mysqli_fetch_row($result); } function fetchAssoc($result) { return mysqli_fetch_assoc($result); } function selectDb($dbName) { return @mysqli_select_db($this->conn->getResource(), $dbName); } }   class OCI8Connection extends ConnectionCommon implements Connection { protected $lastStmt = null; protected $execMode = OCI_COMMIT_ON_SUCCESS; function connect( $dsninfo, $flags = 0 ) { if ( !extension_loaded( 'oci8' ) ) { throw new SQLException( 'oci8 extension not loaded' ); } $this->dsn = $dsninfo; $this->flags = $flags; $persistent = ( $flags & Creole::PERSISTENT === Creole::PERSISTENT ); $user = $dsninfo[ 'username' ]; $pw = $dsninfo[ 'password' ]; $hostspec = $dsninfo[ 'hostspec' ]; $port = $dsninfo[ 'port' ]; $db = $dsninfo[ 'database' ]; $connect_function = ( $persistent ) ? 'oci_pconnect' : 'oci_connect'; $encoding = !empty($dsninfo['encoding']) ? $dsninfo['encoding'] : null; @ini_set( 'track_errors', true ); if ( $hostspec && $port ) { $hostspec .= ':' . $port; } if ( $db && $hostspec && $user && $pw ) { $conn = @$connect_function( $user, $pw, "//$hostspec/$db", $encoding); } elseif ( $hostspec && $user && $pw ) { $conn = @$connect_function( $user, $pw, $hostspec, $encoding ); } elseif ( $user || $pw ) { $conn = @$connect_function( $user, $pw, null, $encoding ); } else { $conn = false; } @ini_restore( 'track_errors' ); if ( $conn == false ) { $error = oci_error(); $error = ( is_array( $error ) ) ? $error[ 'message' ] : null; throw new SQLException( 'connect failed', $error ); } $this->dblink = $conn; $sql = "ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS'"; $this->executeQuery($sql); $sql = "ALTER SESSION SET NLS_TIMESTAMP_FORMAT='YYYY-MM-DD HH24:MI:SS'"; $this->executeQuery($sql); } function close() { $ret = @oci_close( $this->dblink ); $this->dblink = null; return $ret; } function executeQuery( $sql, $fetchmode = null ) { $this->lastQuery = $sql; $result = oci_parse( $this->dblink, $sql ); if ( ! $result ) { throw new SQLException( 'Unable to prepare query' , $this->nativeError() , $sql ); } $success = oci_execute( $result, $this->execMode ); if ( ! $success ) { throw new SQLException( 'Unable to execute query' , $this->nativeError( $result ) , $sql ); } return new OCI8ResultSet( $this, $result, $fetchmode ); } function executeUpdate( $sql ) { $this->lastQuery = $sql; $statement = oci_parse( $this->dblink, $sql ); if ( ! $statement ) { throw new SQLException( 'Unable to prepare update' , $this->nativeError() , $sql ); } $success = @oci_execute( $statement, $this->execMode ); if ( ! $success ) { throw new SQLException( 'Unable to execute update' , $this->nativeError( $statement ) , $sql ); } $this->lastStmt = $statement; return oci_num_rows( $statement ); } protected function beginTrans() { $this->execMode = OCI_DEFAULT; } protected function commitTrans() { $result = oci_commit( $this->dblink ); if ( ! $result ) { throw new SQLException( 'Unable to commit transaction' , $this->nativeError() ); } $this->execMode = OCI_COMMIT_ON_SUCCESS; } protected function rollbackTrans() { $result = oci_rollback( $this->dblink ); if ( ! $result ) { throw new SQLException( 'Unable to rollback transaction' , $this->nativeError() ); } $this->execMode = OCI_COMMIT_ON_SUCCESS; } function getUpdateCount() { if ( ! $this->lastStmt ) { return 0; } $result = oci_num_rows( $this->lastStmt ); if ( $result === false ) { throw new SQLException( 'Update count failed' , $this->nativeError( $this->lastStmt ) ); } return $result; } public function applyLimit( &$sql, $offset, $limit ) { $sql = 'SELECT B.* FROM (  ' . 'SELECT A.*, rownum AS CREOLE$ROWNUM FROM (  ' . $sql . '  ) A ' . ' ) B WHERE '; if ( $offset > 0 ) { $sql .= ' B.CREOLE$ROWNUM > ' . $offset; if ( $limit > 0 ) { $sql .= ' AND B.CREOLE$ROWNUM <= ' . ( $offset + $limit ); } } else { $sql .= ' B.CREOLE$ROWNUM <= ' . $limit; } } public function nativeError( $result = null ) { if ( $result !== null ) { $error = oci_error( $result ); } else { $error = oci_error( $this->dblink ); } return $error[ 'code' ] . ': ' . $error[ 'message' ]; } public function getDatabaseInfo() { return new OCI8DatabaseInfo( $this ); } public function getIdGenerator() { return new OCI8IdGenerator( $this ); } public function prepareStatement( $sql ) { return new OCI8PreparedStatement( $this, $sql ); } public function prepareCall( $sql ) { throw new SQLException( 'Oracle driver does not yet support stored procedures using CallableStatement.' ); } public function createStatement() { return new OCI8Statement( $this ); } }   class ODBCCachedResultSet extends ODBCResultSetCommon implements ResultSet { protected $recs = array(); protected $lastPos = -1; protected $cacheLobs = false; public function __construct(Connection $conn, $result, $fetchmode = null, $cacheLobs = false) { parent::__construct($conn, $result, $fetchmode); $this->cacheLobs = $cacheLobs; } function close() { parent::close(); $this->recs = null; $this->lastPos = -1; $this->cacheLobs = false; } public function loadCache($recPos = -1) { $rid = $this->result->getHandle(); $curRecs = count($this->recs); $totRecs = ($curRecs ? $this->offset + $curRecs : 0); while (1) { if ($this->lastPos != -1 || ($recPos > -1 && $recPos <= $curRecs)) return; $rowNum = ++$totRecs; $result = @odbc_fetch_row($rid, $rowNum); if ($result === false || ($this->limit > 0 && $curRecs+1 > $this->limit)) { $this->lastPos = $curRecs; continue; } if ($totRecs <= $this->offset) continue; $row = array(); for ($i = 0, $n = @odbc_num_fields($rid); $i < $n; $i++) { $fldNum = $i+1; $row[$i] = odbc_result($rid, $fldNum); if ($this->cacheLobs) { ODBCTypes::loadTypeMap($this->conn); $nativeType = @odbc_field_type($rid, $fldNum); $creoleType = ODBCTypes::getType($nativeType); $isBlob = ($creoleType == CreoleTypes::BLOB || $creoleType == CreoleTypes::LONGVARBINARY); $isClob = ($creoleType == CreoleTypes::CLOB || $creoleType == CreoleTypes::LONGVARCHAR); if (($isBlob || $isClob) && $row[$i] !== null) { $binmode = ($isBlob ? ODBC_BINMODE_RETURN : ODBC_BINMODE_CONVERT); $curdata = $row[$i]; $row[$i] = $this->readLobData($fldNum, $binmode, $curdata); } } } $this->recs[++$curRecs] = $row; } } public function seek($rownum) { $this->loadCache($rownum); if ($rownum < 0 || $rownum > count($this->recs)+1) return false; $this->cursorPos = $rownum; return true; } function next() { $this->loadCache(++$this->cursorPos); if ($this->isAfterLast()) { $this->afterLast(); return false; } $this->fields =& $this->checkFetchMode($this->recs[$this->cursorPos]); return true; } function getRecordCount() { if ($this->lastPos == -1) $this->loadCache(-1); return $this->lastPos; } public function isAfterLast() { if ($this->lastPos == -1) return false; return ($this->cursorPos > $this->lastPos); } }   class ODBCResultSet extends ODBCResultSetCommon implements ResultSet { protected $numRows = -1; protected $hasRowCount = false; public function __construct(Connection $conn, $result, $fetchmode = null) { parent::__construct($conn, $result, $fetchmode); $this->numRows = @odbc_num_rows($result->getHandle()); $this->hasRowCount = $this->numRows != -1; } function close() { parent::close(); $numRows = -1; } public function seek($rownum) { if ($rownum < 0 || $this->limit > 0 && $rownum > $this->limit) return false; $this->cursorPos = $rownum; return true; } public function next() { $this->cursorPos++; if ($this->limit > 0 && $this->cursorPos > $this->limit) { $this->cursorPos = $this->limit+1; return false; } $rowNum = $this->offset + $this->cursorPos; $fields = null; $cols = @odbc_fetch_into($this->result->getHandle(), $fields, $rowNum); if ($cols === false) { $this->cursorPos = -1; return false; } $this->fields =& $this->checkFetchMode($fields); return true; } public function isAfterLast() { if ($this->cursorPos == -1) $this->getRecordCount(); return parent::isAfterLast(); } function getRecordCount() { if ($this->hasRowCount) { $numRows = $this->numRows - $this->offset; if ($this->limit > 0 && $numRows > $this->limit) $numRows = $this->limit; } else { if ($this->numRows == -1) { $this->numRows = 0; $this->beforeFirst(); while($this->next()) $this->numRows++; } $numRows = $this->numRows; } if ($this->cursorPos == -1) $this->cursorPos = $numRows+1; return $numRows; } public function getBlob($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } $data = $this->readLobData($column, ODBC_BINMODE_RETURN, $this->fields[$idx]); if (!$data) { return null; } $b = new Blob(); $b->setContents($data); return $b; } public function getClob($column) { $idx = (is_int($column) ? $column - 1 : $column); if (!array_key_exists($idx, $this->fields)) { throw new SQLException("Invalid resultset column: " . $column); } $data = $this->readLobData($column, ODBC_BINMODE_CONVERT, $this->fields[$idx]); if (!$data) { return null; } $c = new Clob(); $c->setContents($data); return $c; } }   class PagedQuery extends Query { private $page; public function __construct(Connection $conn, $sql = null, $page = 1, $rowsPerPage = 25) { parent::__construct($conn, $sql); $this->setRowsPerPage($rowsPerPage); $this->setPage($page); } public function setPage($page) { $this->page = $page; $this->calculateStart(); } public function getPage() { return $this->page; } public function setRowsPerPage($r) { $this->max = $r; $this->calculateStart(); } public function getRowsPerPage() { return $this->max; } private function calculateStart() { $this->start = ( ($this->page - 1) * $this->max ); } public function getTotalRecordCount() { $rs = $this->conn->createStatement()->executeQuery($this->sql); return $rs->getRecordCount(); } }   class PdoSQLiteDatabaseInfo extends DatabaseInfo { protected function initTables() { $sql = "SELECT name FROM sqlite_master WHERE type='table' UNION ALL SELECT name FROM sqlite_temp_master WHERE type='table' ORDER BY name;"; try { $statement = $this->dblink->prepare($sql); $statement->execute(); } catch( PDOException $e ) { throw new SQLException('Could not list tables', $e->getMessage(), $sql); } while ($row = $statement->fetch()) { $this->tables[strtoupper($row[0])] = new PdoSQLiteTableInfo($this, $row[0]); } } protected function initSequences() { } }   class PdoSQLiteResultSet extends PdoResultSetCommon implements ResultSet { public function getIterator() { throw new SQLException('PdoSQLiteResultSet::getIterator() not yet implimented'); } }   class PgSQLConnection extends ConnectionCommon implements Connection { private $result_affected_rows; function connect($dsninfo, $flags = 0) { global $php_errormsg; if (!extension_loaded('pgsql')) { throw new SQLException('pgsql extension not loaded'); } $this->dsn = $dsninfo; $this->flags = $flags; $persistent = ($flags & Creole::PERSISTENT === Creole::PERSISTENT); $protocol = (isset($dsninfo['protocol'])) ? $dsninfo['protocol'] : 'tcp'; $connstr = ''; if ($protocol == 'tcp') { if (!empty($dsninfo['hostspec'])) { $connstr = 'host=' . $dsninfo['hostspec']; } if (!empty($dsninfo['port'])) { $connstr .= ' port=' . $dsninfo['port']; } } if (isset($dsninfo['database'])) { $connstr .= ' dbname=\'' . addslashes($dsninfo['database']) . '\''; } if (!empty($dsninfo['username'])) { $connstr .= ' user=\'' . addslashes($dsninfo['username']) . '\''; } if (!empty($dsninfo['password'])) { $connstr .= ' password=\'' . addslashes($dsninfo['password']) . '\''; } if (!empty($dsninfo['options'])) { $connstr .= ' options=' . $dsninfo['options']; } if (!empty($dsninfo['tty'])) { $connstr .= ' tty=' . $dsninfo['tty']; } @ini_set('track_errors', true); if ($persistent) { $conn = @pg_pconnect($connstr); } else { $conn = @pg_connect($connstr); } if (!$conn) { $cleanconnstr = preg_replace('/password=\'.*?\'($|\s)/', 'password=\'*********\'', $connstr); throw new SQLException('Could not connect', $php_errormsg, $cleanconnstr); } @ini_restore('track_errors'); $this->dblink = $conn; if( !empty( $dsninfo['schema'] ) ) { $this->setSchemaSearchPath( $dsninfo['schema'] ); } } public function applyLimit(&$sql, $offset, $limit) { if ( $limit > 0 ) { $sql .= " LIMIT ".$limit; } if ( $offset > 0 ) { $sql .= " OFFSET ".$offset; } } function close() { $ret = @pg_close($this->dblink); $this->result_affected_rows = null; $this->dblink = null; return $ret; } function executeQuery($sql, $fetchmode = null) { $result = @pg_query($this->dblink, $sql); if (!$result) { throw new SQLException('Could not execute query', pg_last_error($this->dblink), $sql); } $this->result_affected_rows = (int) @pg_affected_rows($result); return new PgSQLResultSet($this, $result, $fetchmode); } function executeUpdate($sql) { $result = @pg_query($this->dblink, $sql); if (!$result) { throw new SQLException('Could not execute update', pg_last_error($this->dblink), $sql); } $this->result_affected_rows = (int) @pg_affected_rows($result); return $this->result_affected_rows; } protected function beginTrans() { $result = @pg_query($this->dblink, "BEGIN"); if (!$result) { throw new SQLException('Could not begin transaction', pg_last_error($this->dblink)); } } protected function commitTrans() { $result = @pg_query($this->dblink, "COMMIT"); if (!$result) { throw new SQLException('Could not commit transaction', pg_last_error($this->dblink)); } } protected function rollbackTrans() { $result = @pg_query($this->dblink, "ROLLBACK"); if (!$result) { throw new SQLException('Could not rollback transaction', pg_last_error($this->dblink)); } } function getUpdateCount() { if ( $this->result_affected_rows === null ) { throw new SQLException('getUpdateCount called before any sql queries were executed'); } return $this->result_affected_rows; } public function getDatabaseInfo() { return new PgSQLDatabaseInfo($this); } public function getIdGenerator() { return new PgSQLIdGenerator($this); } public function prepareStatement($sql) { return new PgSQLPreparedStatement($this, $sql); } public function prepareCall($sql) { throw new SQLException('PostgreSQL does not support stored procedures.'); } public function createStatement() { return new PgSQLStatement($this); } protected function supportsSavepoints() { return true; } protected function setSavepoint( $identifier ) { $result = @pg_query($this->dblink, "savepoint ".$identifier); if (!$result) { throw new SQLException('Could not begin transaction', pg_last_error($this->dblink)); } } protected function releaseSavepoint( $identifier ) { $result = @pg_query($this->dblink, "release savepoint ".$identifier); if (!$result) { throw new SQLException('Could not begin transaction', pg_last_error($this->dblink)); } } protected function rollbackToSavepoint( $identifier ) { $result = @pg_query($this->dblink, "rollback to savepoint ".$identifier); if (!$result) { throw new SQLException('Could not begin transaction', pg_last_error($this->dblink)); } } public function setSchemaSearchPath( $searchPath ) { $sql = "SET search_path TO $searchPath"; return $this->executeUpdate( $sql ); } }   class SQLiteConnection extends ConnectionCommon implements Connection { private $sqliteAssocCase; function connect($dsninfo, $flags = 0) { if (!extension_loaded('sqlite')) { throw new SQLException('sqlite extension not loaded'); } $file = $dsninfo['database']; $this->dsn = $dsninfo; $this->flags = $flags; $persistent = ($flags & Creole::PERSISTENT === Creole::PERSISTENT); if (PHP_VERSION == '5.0.4' || PHP_VERSION == '5.0.5') { $nochange = TRUE; } else { $nochange = !(($flags & Creole::COMPAT_ASSOC_LOWER) === Creole::COMPAT_ASSOC_LOWER); } if ($nochange) { $this->sqliteAssocCase = 0; } else { $this->sqliteAssocCase = 2; } if ($file === null) { throw new SQLException("No SQLite database specified."); } $mode = (isset($dsninfo['mode']) && is_numeric($dsninfo['mode'])) ? $dsninfo['mode'] : 0644; if ($file != ':memory:') { if (!file_exists($file)) { if( !@touch($file) ) { throw new SQLException("Unable to create SQLite database.  Check parent folder permissions."); } chmod($file, $mode); if (!file_exists($file)) { throw new SQLException("Unable to create SQLite database."); } } if (!is_file($file)) { throw new SQLException("Unable to open SQLite database: not a valid file."); } if (!is_readable($file)) { throw new SQLException("Unable to read SQLite database."); } } $connect_function = $persistent ? 'sqlite_popen' : 'sqlite_open'; if (!($conn = @$connect_function($file, $mode, $errmsg) )) { throw new SQLException("Unable to connect to SQLite database", $errmsg); } $this->dblink = $conn; } public function getDatabaseInfo() { return new SQLiteDatabaseInfo($this); } public function getIdGenerator() { return new SQLiteIdGenerator($this); } public function prepareStatement($sql) { return new SQLitePreparedStatement($this, $sql); } public function prepareCall($sql) { throw new SQLException('SQLite does not support stored procedures using CallableStatement.'); } public function createStatement() { return new SQLiteStatement($this); } function close() { $ret = @sqlite_close($this->dblink); $this->dblink = null; return $ret; } public function applyLimit(&$sql, $offset, $limit) { if ( $limit > 0 ) { $sql .= " LIMIT " . $limit . ($offset > 0 ? " OFFSET " . $offset : ""); } elseif ( $offset > 0 ) { $sql .= " LIMIT -1 OFFSET " . $offset; } } public function executeQuery($sql, $fetchmode = null) { ini_set('sqlite.assoc_case', $this->sqliteAssocCase); $this->lastQuery = $sql; $result = @sqlite_query($this->dblink, $this->lastQuery); if (!$result) { throw new SQLException('Could not execute query', $php_errormsg, $this->lastQuery); } return new SQLiteResultSet($this, $result, $fetchmode); } function executeUpdate($sql) { $this->lastQuery = $sql; $result = @sqlite_query($this->dblink, $this->lastQuery); if (!$result) { throw new SQLException('Could not execute update', @$php_errormsg, $this->lastQuery); } return (int) @sqlite_changes($this->dblink); } protected function beginTrans() { $result = @sqlite_query($this->dblink, 'BEGIN'); if (!$result) { throw new SQLException('Could not begin transaction', $php_errormsg); } } protected function commitTrans() { $result = @sqlite_query($this->dblink, 'COMMIT'); if (!$result) { throw new SQLException('Can not commit transaction', $php_errormsg); } } protected function rollbackTrans() { $result = @sqlite_query($this->dblink, 'ROLLBACK'); if (!$result) { throw new SQLException('Could not rollback transaction', $php_errormsg); } } function getUpdateCount() { return (int) @sqlite_changes($this->dblink); } }   class MySQLConnection extends ConnectionCommon implements Connection { private $database; function connect($dsninfo, $flags = 0) { if (!extension_loaded('mysql')) { throw new SQLException('mysql extension not loaded'); } $this->dsn = $dsninfo; $this->flags = $flags; $persistent = ($flags & Creole::PERSISTENT) === Creole::PERSISTENT; $multi_statement = ($flags & Creole::MYSQL_CLIENT_MULTI_STATEMENTS) === Creole::MYSQL_CLIENT_MULTI_STATEMENTS; $multi_result = ($flags & Creole::MYSQL_CLIENT_MULTI_RESULTS) === Creole::MYSQL_CLIENT_MULTI_RESULTS; $connect_flags = ($multi_statement ? Creole::MYSQL_CLIENT_MULTI_STATEMENTS : 0) | ($multi_result ? Creole::MYSQL_CLIENT_MULTI_RESULTS : 0); if (isset($dsninfo['protocol']) && $dsninfo['protocol'] == 'unix') { $dbhost = ':' . $dsninfo['socket']; } else { $dbhost = $dsninfo['hostspec'] ? $dsninfo['hostspec'] : 'localhost'; if (!empty($dsninfo['port'])) { $dbhost .= ':' . $dsninfo['port']; } } $user = $dsninfo['username']; $pw = $dsninfo['password']; $encoding = !empty($dsninfo['encoding']) ? $dsninfo['encoding'] : null; @ini_set('track_errors', true); if ($dbhost && $user && $pw) { $conn = $persistent ? mysql_pconnect($dbhost, $user, $pw, $connect_flags) : mysql_connect($dbhost, $user, $pw, null, $connect_flags); } elseif ($dbhost && $user) { $conn = $persistent ? mysql_pconnect($dbhost, $user, null, $connect_flags) : mysql_connect($dbhost, $user, null, null, $connect_flags); } elseif ($dbhost) { $conn = $persistent ? mysql_pconnect($dbhost, null, null, $connect_flags) : mysql_connect($dbhost, null, null, null, $connect_flags); } else { $conn = false; } @ini_restore('track_errors'); if (empty($conn)) { if (($err = @mysql_error()) != '') { throw new SQLException("connect failed", $err); } elseif (empty($php_errormsg)) { throw new SQLException("connect failed"); } else { throw new SQLException("connect failed", $php_errormsg); } } if ($dsninfo['database']) { if (!@mysql_select_db($dsninfo['database'], $conn)) { switch(mysql_errno($conn)) { case 1049: $exc = new SQLException("no such database", mysql_error($conn)); break; case 1044: $exc = new SQLException("access violation", mysql_error($conn)); break; default: $exc = new SQLException("cannot select database", mysql_error($conn)); } throw $exc; } $this->database = $dsninfo['database']; } $this->dblink = $conn; if ($encoding) { $this->executeUpdate("SET NAMES " . $encoding); } } public function getDatabaseInfo() { return new MySQLDatabaseInfo($this); } public function getIdGenerator() { return new MySQLIdGenerator($this); } public function prepareStatement($sql) { return new MySQLPreparedStatement($this, $sql); } public function prepareCall($sql) { throw new SQLException('MySQL does not support stored procedures.'); } public function createStatement() { return new MySQLStatement($this); } function close() { $ret = mysql_close($this->dblink); $this->dblink = null; return $ret; } public function applyLimit(&$sql, $offset, $limit) { if ( $limit > 0 ) { $sql .= " LIMIT " . ($offset > 0 ? $offset . ", " : "") . $limit; } else if ( $offset > 0 ) { $sql .= " LIMIT " . $offset . ", 18446744073709551615"; } } function executeQuery($sql, $fetchmode = null) { $this->lastQuery = $sql; if ($this->database) { if (!@mysql_select_db($this->database, $this->dblink)) { throw new SQLException('No database selected', mysql_error($this->dblink)); } } $result = @mysql_query($sql, $this->dblink); if (!$result) { throw new SQLException('Could not execute query', mysql_error($this->dblink), $sql); } return new MySQLResultSet($this, $result, $fetchmode); } function executeUpdate($sql) { $this->lastQuery = $sql; if ($this->database) { if (!@mysql_select_db($this->database, $this->dblink)) { throw new SQLException('No database selected', mysql_error($this->dblink)); } } $result = @mysql_query($sql, $this->dblink); if (!$result) { throw new SQLException('Could not execute update', mysql_error($this->dblink), $sql); } return (int) mysql_affected_rows($this->dblink); } protected function beginTrans() { $result = @mysql_query('SET AUTOCOMMIT=0', $this->dblink); $result = @mysql_query('BEGIN', $this->dblink); if (!$result) { throw new SQLException('Could not begin transaction', mysql_error($this->dblink)); } } protected function commitTrans() { if ($this->database) { if (!@mysql_select_db($this->database, $this->dblink)) { throw new SQLException('No database selected', mysql_error($this->dblink)); } } $result = @mysql_query('COMMIT', $this->dblink); if (!$result) { throw new SQLException('Could not commit transaction', mysql_error($this->dblink)); } $result = @mysql_query('SET AUTOCOMMIT=1', $this->dblink); if (!$result) { throw new SQLException('Could not set AUTOCOMMIT', mysql_error($this->dblink)); } } protected function rollbackTrans() { if ($this->database) { if (!@mysql_select_db($this->database, $this->dblink)) { throw new SQLException('No database selected', mysql_error($this->dblink)); } } $result = @mysql_query('ROLLBACK', $this->dblink); if (!$result) { throw new SQLException('Could not rollback transaction', mysql_error($this->dblink)); } $result = @mysql_query('SET AUTOCOMMIT=1', $this->dblink); if (!$result) { throw new SQLException('Could not set AUTOCOMMIT', mysql_error($this->dblink)); } } function getUpdateCount() { return (int) @mysql_affected_rows($this->dblink); } protected function supportsSavepoints() { return true; } protected function setSavepoint( $identifier ) { $result = @mysql_query("savepoint ".$identifier, $this->dblink); if (!$result) { throw new SQLException('Could not begin transaction', mysql_error($this->dblink)); } } protected function releaseSavepoint( $identifier ) { $result = @mysql_query("release savepoint ".$identifier, $this->dblink); if (!$result) { throw new SQLException('Could not begin transaction', mysql_error($this->dblink)); } } protected function rollbackToSavepoint( $identifier ) { $result = @mysql_query("rollback to savepoint ".$identifier, $this->dblink); if (!$result) { throw new SQLException('Could not begin transaction', mysql_error($this->dblink)); } } }   class MySQLiConnection extends ConnectionCommon implements Connection { public function connect($dsninfo, $flags = 0) { if (!extension_loaded('mysqli')) { throw new SQLException('mysqli extension not loaded'); } $this->dsn = $dsninfo; $this->flags = $flags; $dbhost = null; if (isset($dsninfo['protocol']) && $dsninfo['protocol'] == 'unix') { $dbhost = ':' . $dsninfo['socket']; } else { $dbhost = $dsninfo['hostspec'] ? $dsninfo['hostspec'] : 'localhost'; if (!empty($dsninfo['port'])) { $dbhost .= ':' . $dsninfo['port']; } } $host = !empty($dsninfo['hostspec']) ? $dsninfo['hostspec'] : null; $user = !empty($dsninfo['username']) ? $dsninfo['username'] : null; $pw = !empty($dsninfo['password']) ? $dsninfo['password'] : null; $port = !empty($dsninfo['port']) ? $dsninfo['port'] : null; $socket = !empty($dsninfo['socket']) ? $dsninfo['socket'] : null; $database = !empty($dsninfo['database']) ? $dsninfo['database'] : null; $encoding = !empty($dsninfo['encoding']) ? $dsninfo['encoding'] : null; @ini_set('track_errors', true); $conn = mysqli_connect($host, $user, $pw, $database, $port, $socket); @ini_restore('track_errors'); if (!$conn) { if (($err = @mysqli_error()) != '') { throw new SQLException("connect failed", $err); } elseif (empty($php_errormsg)) { throw new SQLException("connect failed"); } else { throw new SQLException("connect failed", $php_errormsg); } } $this->dblink = $conn; if ($encoding) { $this->dblink->set_charset( $encoding ); } } public function getDatabaseInfo() { return new MySQLiDatabaseInfo($this); } public function getIdGenerator() { return new MySQLiIdGenerator($this); } public function prepareStatement($sql) { return new MySQLiPreparedStatement($this, $sql); } public function prepareCall($sql) { throw new SQLException('MySQL does not support stored procedures.'); } public function createStatement() { return new MySQLiStatement($this); } public function close() { $ret = mysqli_close($this->dblink); $this->dblink = null; return $ret; } public function applyLimit(&$sql, $offset, $limit) { if ( $limit > 0 ) { $sql .= " LIMIT " . ($offset > 0 ? $offset . ", " : "") . $limit; } else if ( $offset > 0 ) { $sql .= " LIMIT " . $offset . ", 18446744073709551615"; } } public function executeQuery($sql, $fetchmode = null) { $this->lastQuery = $sql; $result = @mysqli_query($this->dblink, $sql); if (!$result) { throw new SQLException('Could not execute query', mysqli_error($this->dblink), $sql); } return new MySQLiResultSet($this, $result, $fetchmode); } public function executeUpdate($sql) { $this->lastQuery = $sql; $result = @mysqli_query($this->dblink, $sql); if (!$result) { throw new SQLException('Could not execute update', mysqli_error($this->dblink), $sql); } return (int) mysqli_affected_rows($this->dblink); } protected function beginTrans() { if (!mysqli_autocommit($this->dblink, FALSE)) { throw new SQLException('Could not begin transaction', mysqli_error($this->dblink)); } } protected function commitTrans() { if (!mysqli_commit($this->dblink)) { throw new SQLException('Can not commit transaction', mysqli_error($this->dblink)); } if (!mysqli_autocommit($this->dblink, TRUE)) { throw new SQLException('Could not set AUTOCOMMIT', mysqli_error($this->dblink)); } } protected function rollbackTrans() { if (!mysqli_rollback($this->dblink)) { throw new SQLException('Could not rollback transaction', mysqli_error($this->dblink)); } if (!mysqli_autocommit($this->dblink, TRUE)) { throw new SQLException('Could not set AUTOCOMMIT', mysqli_error($this->dblink)); } } public function getUpdateCount() { return (int) @mysqli_affected_rows($this->dblink); } }   class ODBCAdapter { public function preservesColumnCase() { return true; } public function emulatePrepareStmt() { return false; } public function hasLimitOffset() { return false; } public function applyLimit(&$sql, $offset, $limit) { } public function escape($str) { return str_replace("'", "''", $str); } public function createResultSet($conn, $odbcresult, $fetchmode) { return new ODBCResultSet($conn, $odbcresult, $fetchmode); } public function getIdGenerator($conn) { return new ODBCIdGenerator($conn); } public function supportsTransactions() { return true; } }   class PdoSQLiteConnection extends PdoConnectionCommon implements Connection { function connect($dsninfo, $flags = 0) { if (!extension_loaded('pdo_sqlite')) { throw new SQLException('pdo_sqlite extension not loaded'); } $file = $dsninfo['database']; if ($file === null) { throw new SQLException("No SQLite database specified."); } $mode = (isset($dsninfo['mode']) && is_numeric($dsninfo['mode'])) ? $dsninfo['mode'] : 0644; if ($file != ':memory:') { if (!file_exists($file)) { if( !@touch($file) ) { throw new SQLException("Unable to create SQLite database.  Check parent folder permissions."); } chmod($file, $mode); if (!file_exists($file)) { throw new SQLException("Unable to create SQLite database."); } } if (!is_file($file)) { throw new SQLException("Unable to open SQLite database: not a valid file."); } if (!is_readable($file)) { throw new SQLException("Unable to read SQLite database."); } } $pdo_dsn = $dsninfo['phptype'] == 'pdosqlite2' ? 'sqlite2' : 'sqlite'; $pdo_dsn .= ':'.$dsninfo['database']; parent::connect( $dsninfo, $flags, $pdo_dsn ); $this->executeQuery('PRAGMA full_column_names=0'); $this->executeQuery('PRAGMA short_column_names=1'); } public function getDatabaseInfo() { return new PdoSQLiteDatabaseInfo($this); } public function getIdGenerator() { return new PdoSQLiteIdGenerator($this); } public function prepareStatement($sql) { return new PdoSQLitePreparedStatement($this, $sql); } public function prepareCall($sql) { throw new SQLException('SQLite does not support stored procedures using CallableStatement.'); } public function createStatement() { return new PdoSQLiteStatement($this); } function close() { $this->dblink = NULL; return null; } public function applyLimit(&$sql, $offset, $limit) { if ( $limit > 0 ) { $sql .= " LIMIT " . $limit . ($offset > 0 ? " OFFSET " . $offset : ""); } elseif ( $offset > 0 ) { $sql .= " LIMIT -1 OFFSET " . $offset; } } public function executeQuery($sql, $fetchmode = null) { return parent::executeQuery( $sql, $fetchmode, 'PdoSQLiteResultSet'); } }   class CodeBaseAdapter extends ODBCAdapter { public function preservesColumnCase() { return false; } public function createResultSet($conn, $odbcresult, $fetchmode) { return new ODBCResultSet($conn, $odbcresult, $fetchmode, true); } }   class MySQLAdapter extends ODBCAdapter { public function hasLimitOffset() { return true; } public function applyLimit(&$sql, $offset, $limit) { if ( $limit > 0 ) { $sql .= " LIMIT " . ($offset > 0 ? $offset . ", " : "") . $limit; } else if ( $offset > 0 ) { $sql .= " LIMIT " . $offset . ", 18446744073709551615"; } } public function escape($str) { return addslashes($str); } public function createResultSet($conn, $odbcresult, $fetchmode) { return new ODBCResultSet($conn, $odbcresult, $fetchmode); } }   class ODBCConnection extends ConnectionCommon implements Connection { protected $adapter = null; protected $odbcresult = null; public function connect($dsninfo, $flags = 0) { if (!function_exists('odbc_connect')) throw new SQLException('odbc extension not loaded'); $adapterclass = isset($dsninfo['adapter']) ? $dsninfo['adapter'] : null; if (!$adapterclass) $adapterclass = 'ODBCAdapter'; else $adapterclass .= 'Adapter'; Creole::import('creole.drivers.odbc.adapters.' . $adapterclass); $this->adapter = new $adapterclass(); $this->dsn = $dsninfo; $this->flags = $flags; if ( !($this->flags & Creole::COMPAT_ASSOC_LOWER) && !$this->adapter->preservesColumnCase()) { trigger_error('Connection created without Creole::COMPAT_ASSOC_LOWER, ' . 'but driver does not support case preservation.', E_USER_WARNING); $this->flags != Creole::COMPAT_ASSOC_LOWER; } $persistent = ($flags & Creole::PERSISTENT) === Creole::PERSISTENT; if ($dsninfo['database']) $odbcdsn = $dsninfo['database']; elseif ($dsninfo['hostspec']) $odbcdsn = $dsninfo['hostspec']; else $odbcdsn = 'localhost'; $user = @$dsninfo['username']; $pw = @$dsninfo['password']; $connect_function = $persistent ? 'odbc_pconnect' : 'odbc_connect'; $conn = @$connect_function($odbcdsn, $user, $pw, SQL_CUR_USE_IF_NEEDED); if (!is_resource($conn)) throw new SQLException('connect failed', $this->nativeError(), $odbcdsn); $this->dblink = $conn; @odbc_binmode(0, ODBC_BINMODE_PASSTHRU); @odbc_longreadlen(0, ini_get('odbc.defaultlrl')); } public function close() { $ret = true; $this->adapter = null; $this->odbcresult = null; if ($this->dblink !== null) { $ret = @odbc_close($this->dblink); $this->dblink = null; } return $ret; } public function __destruct() { $this->close(); } public function nativeError() { if ($this->dblink && is_resource($this->dblink)) $errstr = '[' . @odbc_error($this->dblink) . '] ' . @odbc_errormsg($this->dblink); else $errstr = '[' . @odbc_error() . '] ' . @odbc_errormsg(); return $errstr; } public function getAdapter() { return $this->adapter; } public function getDatabaseInfo() { return new ODBCDatabaseInfo($this); } public function getIdGenerator() { return $this->adapter->getIdGenerator($this); } public function createResultSet($odbcresult, $fetchmode) { return $this->adapter->createResultSet($this, $odbcresult, $fetchmode); } public function prepareStatement($sql) { return new ODBCPreparedStatement($this, $sql); } public function createStatement() { return new ODBCStatement($this); } public function prepareCall($sql) { throw new SQLException('Stored procedures not currently implemented.'); } public function applyLimit(&$sql, $offset, $limit) { if ($this->adapter->hasLimitOffset()) $this->adapter->applyLimit($sql, $offset, $limit); } public function executeQuery($sql, $fetchmode = null) { if ($this->odbcresult) $this->odbcresult = null; $r = @odbc_exec($this->dblink, $sql); if ($r === false) throw new SQLException('Could not execute query', $this->nativeError(), $sql); $this->odbcresult = new ODBCResultResource($r); return $this->createResultSet($this->odbcresult, $fetchmode); } public function executeUpdate($sql) { if ($this->odbcresult) $this->odbcresult = null; $r = @odbc_exec($this->dblink, $sql); if ($r === false) throw new SQLException('Could not execute update', $this->nativeError(), $sql); $this->odbcresult = new ODBCResultResource($r); return $this->getUpdateCount(); } protected function beginTrans() { if ($this->adapter->supportsTransactions()) { @odbc_autocommit($this->dblink, false); if (odbc_error($this->dblink) == 'S1C00') { throw new SQLException('Could not begin transaction', $this->nativeError()); } } } protected function commitTrans() { if ($this->adapter->supportsTransactions()) { $result = @odbc_commit($this->dblink); if (!$result) { throw new SQLException('Could not commit transaction', $this->nativeError()); } @odbc_autocommit($this->dblink, true); if (odbc_error($this->dblink) == 'S1C00') { throw new SQLException('Could not commit transaction (autocommit failed)', $this->nativeError()); } } } protected function rollbackTrans() { if ($this->adapter->supportsTransactions()) { $result = @odbc_rollback($this->dblink); if (!$result) { throw new SQLException('Could not rollback transaction', $this->nativeError()); } @odbc_autocommit($this->dblink, true); if (odbc_error($this->dblink) == 'S1C00') { throw new SQLException('Could not rollback transaction (autocommit failed)', $this->nativeError()); } } } public function getUpdateCount() { if ($this->odbcresult === null) return 0; $n = @odbc_num_rows($this->odbcresult->getHandle()); if ($n == -1) throw new SQLException('Could not retrieve update count', $this->nativeError()); return (int) $n; } } class ODBCResultResource { protected $handle = null; public function __construct($handle) { if (is_resource($handle)) $this->handle = $handle; } public function __destruct() { if ($this->handle !== null) @odbc_free_result($this->handle); } public function getHandle() { return $this->handle; } } ?>