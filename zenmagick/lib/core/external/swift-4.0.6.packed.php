<?php  abstract class Swift_Transport_AbstractSmtpTransport implements Swift_Transport { protected $_buffer; protected $_started = false; protected $_domain = '[127.0.0.1]'; protected $_eventDispatcher; abstract protected function _getBufferParams(); public function __construct(Swift_Transport_IoBuffer $buf, Swift_Events_EventDispatcher $dispatcher) { $this->_eventDispatcher = $dispatcher; $this->_buffer = $buf; $this->_lookupHostname(); } public function setLocalDomain($domain) { $this->_domain = $domain; return $this; } public function getLocalDomain() { return $this->_domain; } public function start() { if (!$this->_started) { if ($evt = $this->_eventDispatcher->createTransportChangeEvent($this)) { $this->_eventDispatcher->dispatchEvent($evt, 'beforeTransportStarted'); if ($evt->bubbleCancelled()) { return; } } try { $this->_buffer->initialize($this->_getBufferParams()); } catch (Swift_TransportException $e) { $this->_throwException($e); } $this->_readGreeting(); $this->_doHeloCommand(); if ($evt) { $this->_eventDispatcher->dispatchEvent($evt, 'transportStarted'); } $this->_started = true; } } public function isStarted() { return $this->_started; } public function send(Swift_Mime_Message $message, &$failedRecipients = null) { $sent = 0; $failedRecipients = (array) $failedRecipients; if (!$reversePath = $this->_getReversePath($message)) { throw new Swift_TransportException( 'Cannot send message without a sender address' ); } if ($evt = $this->_eventDispatcher->createSendEvent($this, $message)) { $this->_eventDispatcher->dispatchEvent($evt, 'beforeSendPerformed'); if ($evt->bubbleCancelled()) { return 0; } } $to = (array) $message->getTo(); $cc = (array) $message->getCc(); $bcc = (array) $message->getBcc(); $message->setBcc(array()); try { $sent += $this->_sendTo($message, $reversePath, $to, $failedRecipients); $sent += $this->_sendCc($message, $reversePath, $cc, $failedRecipients); $sent += $this->_sendBcc($message, $reversePath, $bcc, $failedRecipients); } catch (Exception $e) { $message->setBcc($bcc); throw $e; } $message->setBcc($bcc); if ($evt) { if ($sent == count($to) + count($cc) + count($bcc)) { $evt->setResult(Swift_Events_SendEvent::RESULT_SUCCESS); } elseif ($sent > 0) { $evt->setResult(Swift_Events_SendEvent::RESULT_TENTATIVE); } else { $evt->setResult(Swift_Events_SendEvent::RESULT_FAILED); } $evt->setFailedRecipients($failedRecipients); $this->_eventDispatcher->dispatchEvent($evt, 'sendPerformed'); } $message->generateId(); return $sent; } public function stop() { if ($this->_started) { if ($evt = $this->_eventDispatcher->createTransportChangeEvent($this)) { $this->_eventDispatcher->dispatchEvent($evt, 'beforeTransportStopped'); if ($evt->bubbleCancelled()) { return; } } try { $this->executeCommand("QUIT\r\n", array(221)); } catch (Swift_TransportException $e) {} try { $this->_buffer->terminate(); if ($evt) { $this->_eventDispatcher->dispatchEvent($evt, 'transportStopped'); } } catch (Swift_TransportException $e) { $this->_throwException($e); } } $this->_started = false; } public function registerPlugin(Swift_Events_EventListener $plugin) { $this->_eventDispatcher->bindEventListener($plugin); } public function reset() { $this->executeCommand("RSET\r\n", array(250)); } public function getBuffer() { return $this->_buffer; } public function executeCommand($command, $codes = array(), &$failures = null) { $failures = (array) $failures; $seq = $this->_buffer->write($command); $response = $this->_getFullResponse($seq); if ($evt = $this->_eventDispatcher->createCommandEvent($this, $command, $codes)) { $this->_eventDispatcher->dispatchEvent($evt, 'commandSent'); } $this->_assertResponseCode($response, $codes); return $response; } protected function _readGreeting() { $this->_assertResponseCode($this->_getFullResponse(0), array(220)); } protected function _doHeloCommand() { $this->executeCommand( sprintf("HELO %s\r\n", $this->_domain), array(250) ); } protected function _doMailFromCommand($address) { $this->executeCommand( sprintf("MAIL FROM: <%s>\r\n", $address), array(250) ); } protected function _doRcptToCommand($address) { $this->executeCommand( sprintf("RCPT TO: <%s>\r\n", $address), array(250, 251, 252) ); } protected function _doDataCommand() { $this->executeCommand("DATA\r\n", array(354)); } protected function _streamMessage(Swift_Mime_Message $message) { $this->_buffer->setWriteTranslations(array("\r\n." => "\r\n..")); try { $message->toByteStream($this->_buffer); $this->_buffer->flushBuffers(); } catch (Swift_TransportException $e) { $this->_throwException($e); } $this->_buffer->setWriteTranslations(array()); $this->executeCommand("\r\n.\r\n", array(250)); } protected function _getReversePath(Swift_Mime_Message $message) { $return = $message->getReturnPath(); $sender = $message->getSender(); $from = $message->getFrom(); $path = null; if (!empty($return)) { $path = $return; } elseif (!empty($sender)) { reset($sender); $path = key($sender); } elseif (!empty($from)) { reset($from); $path = key($from); } return $path; } protected function _throwException(Swift_TransportException $e) { if ($evt = $this->_eventDispatcher->createTransportExceptionEvent($this, $e)) { $this->_eventDispatcher->dispatchEvent($evt, 'exceptionThrown'); if (!$evt->bubbleCancelled()) { throw $e; } } else { throw $e; } } protected function _assertResponseCode($response, $wanted) { list($code, $separator, $text) = sscanf($response, '%3d%[ -]%s'); $valid = (empty($wanted) || in_array($code, $wanted)); if ($evt = $this->_eventDispatcher->createResponseEvent($this, $response, $valid)) { $this->_eventDispatcher->dispatchEvent($evt, 'responseReceived'); } if (!$valid) { $this->_throwException( new Swift_TransportException( 'Expected response code ' . implode('/', $wanted) . ' but got code ' . '"' . $code . '", with message "' . $response . '"' ) ); } } protected function _getFullResponse($seq) { $response = ''; try { do { $line = $this->_buffer->readLine($seq); $response .= $line; } while (null !== $line && false !== $line && ' ' != $line{3}); } catch (Swift_TransportException $e) { $this->_throwException($e); } return $response; } private function _doMailTransaction($message, $reversePath, array $recipients, array &$failedRecipients) { $sent = 0; $this->_doMailFromCommand($reversePath); foreach ($recipients as $forwardPath) { try { $this->_doRcptToCommand($forwardPath); $sent++; } catch (Swift_TransportException $e) { $failedRecipients[] = $forwardPath; } } if ($sent != 0) { $this->_doDataCommand(); $this->_streamMessage($message); } else { $this->reset(); } return $sent; } private function _sendTo(Swift_Mime_Message $message, $reversePath, array $to, array &$failedRecipients) { if (empty($to)) { return 0; } return $this->_doMailTransaction($message, $reversePath, array_keys($to), $failedRecipients); } private function _sendCc(Swift_Mime_Message $message, $reversePath, array $cc, array &$failedRecipients) { if (empty($cc)) { return 0; } return $this->_doMailTransaction($message, $reversePath, array_keys($cc), $failedRecipients); } private function _sendBcc(Swift_Mime_Message $message, $reversePath, array $bcc, array &$failedRecipients) { $sent = 0; foreach ($bcc as $forwardPath => $name) { $message->setBcc(array($forwardPath => $name)); $sent += $this->_doMailTransaction( $message, $reversePath, array($forwardPath), $failedRecipients ); } return $sent; } private function _lookupHostname() { if (!empty($_SERVER['SERVER_NAME']) && $this->_isFqdn($_SERVER['SERVER_NAME'])) { $this->_domain = $_SERVER['SERVER_NAME']; } elseif (!empty($_SERVER['SERVER_ADDR'])) { $this->_domain = sprintf('[%s]', $_SERVER['SERVER_ADDR']); } } private function _isFqdn($hostname) { if (false !== $dotPos = strpos($hostname, '.')) { return ($dotPos > 0) && ($dotPos != strlen($hostname) - 1); } else { return false; } } public function __destruct() { $this->stop(); } }   interface Swift_Transport_Esmtp_Authenticator { public function getAuthKeyword(); public function authenticate(Swift_Transport_SmtpAgent $agent, $username, $password); }   class Swift_Transport_Esmtp_AuthHandler implements Swift_Transport_EsmtpHandler { private $_authenticators = array(); private $_username; private $_password; private $_auth_mode; private $_esmtpParams = array(); public function __construct(array $authenticators) { $this->setAuthenticators($authenticators); } public function setAuthenticators(array $authenticators) { $this->_authenticators = $authenticators; } public function getAuthenticators() { return $this->_authenticators; } public function setUsername($username) { $this->_username = $username; } public function getUsername() { return $this->_username; } public function setPassword($password) { $this->_password = $password; } public function getPassword() { return $this->_password; } public function setAuthMode($mode) { $this->_auth_mode = $mode; } public function getAuthMode() { return $this->_auth_mode; } public function getHandledKeyword() { return 'AUTH'; } public function setKeywordParams(array $parameters) { $this->_esmtpParams = $parameters; } public function afterEhlo(Swift_Transport_SmtpAgent $agent) { if ($this->_username) { $count = 0; foreach ($this->_getAuthenticatorsForAgent() as $authenticator) { if (in_array(strtolower($authenticator->getAuthKeyword()), array_map('strtolower', $this->_esmtpParams))) { $count++; if ($authenticator->authenticate($agent, $this->_username, $this->_password)) { return; } } } throw new Swift_TransportException( 'Failed to authenticate on SMTP server with username "' . $this->_username . '" using ' . $count . ' possible authenticators' ); } } public function getMailParams() { return array(); } public function getRcptParams() { return array(); } public function onCommand(Swift_Transport_SmtpAgent $agent, $command, $codes = array(), &$failedRecipients = null, &$stop = false) { } public function getPriorityOver($esmtpKeyword) { return 0; } public function exposeMixinMethods() { return array('setUsername', 'getUsername', 'setPassword', 'getPassword', 'setAuthMode', 'getAuthMode'); } public function resetState() { } protected function _getAuthenticatorsForAgent() { if (!$mode = strtolower($this->_auth_mode)) { return $this->_authenticators; } foreach ($this->_authenticators as $authenticator) { if (strtolower($authenticator->getAuthKeyword()) == $mode) { return array($authenticator); } } throw new Swift_TransportException('Auth mode '.$mode.' is invalid'); } }   interface Swift_CharacterReader { const MAP_TYPE_INVALID = 0x01; const MAP_TYPE_FIXED_LEN = 0x02; const MAP_TYPE_POSITIONS = 0x03; public function getCharPositions($string, $startOffset, &$currentMap, &$ignoredChars); public function getMapType(); public function validateByteSequence($bytes, $size); public function getInitialByteSize(); }   interface Swift_CharacterReaderFactory { public function getReaderFor($charset); }   interface Swift_CharacterStream { public function setCharacterSet($charset); public function setCharacterReaderFactory( Swift_CharacterReaderFactory $factory); public function importByteStream(Swift_OutputByteStream $os); public function importString($string); public function read($length); public function readBytes($length); public function write($chars); public function setPointer($charOffset); public function flushContents(); }   interface Swift_Mime_CharsetObserver { public function charsetChanged($charset); }   class Swift_Transport_Esmtp_Auth_CramMd5Authenticator implements Swift_Transport_Esmtp_Authenticator { public function getAuthKeyword() { return 'CRAM-MD5'; } public function authenticate(Swift_Transport_SmtpAgent $agent, $username, $password) { try { $challenge = $agent->executeCommand("AUTH CRAM-MD5\r\n", array(334)); $challenge = base64_decode(substr($challenge, 4)); $message = base64_encode( $username . ' ' . $this->_getResponse($password, $challenge) ); $agent->executeCommand(sprintf("%s\r\n", $message), array(235)); return true; } catch (Swift_TransportException $e) { $agent->executeCommand("RSET\r\n", array(250)); return false; } } private function _getResponse($secret, $challenge) { if (strlen($secret) > 64) { $secret = pack('H32', md5($secret)); } if (strlen($secret) < 64) { $secret = str_pad($secret, 64, chr(0)); } $k_ipad = substr($secret, 0, 64) ^ str_repeat(chr(0x36), 64); $k_opad = substr($secret, 0, 64) ^ str_repeat(chr(0x5C), 64); $inner = pack('H32', md5($k_ipad . $challenge)); $digest = md5($k_opad . $inner); return $digest; } }   class Swift_DependencyContainer { const TYPE_VALUE = 0x0001; const TYPE_INSTANCE = 0x0010; const TYPE_SHARED = 0x0100; const TYPE_ALIAS = 0x1000; private static $_instance = null; private $_store = array(); private $_endPoint; public function __construct() { } public static function getInstance() { if (!isset(self::$_instance)) { self::$_instance = new self(); } return self::$_instance; } public function listItems() { return array_keys($this->_store); } public function has($itemName) { return array_key_exists($itemName, $this->_store) && isset($this->_store[$itemName]['lookupType']); } public function lookup($itemName) { if (!$this->has($itemName)) { throw new Swift_DependencyException( 'Cannot lookup dependency "' . $itemName . '" since it is not registered.' ); } switch ($this->_store[$itemName]['lookupType']) { case self::TYPE_ALIAS: return $this->_createAlias($itemName); case self::TYPE_VALUE: return $this->_getValue($itemName); case self::TYPE_INSTANCE: return $this->_createNewInstance($itemName); case self::TYPE_SHARED: return $this->_createSharedInstance($itemName); } } public function createDependenciesFor($itemName) { $args = array(); if (isset($this->_store[$itemName]['args'])) { $args = $this->_resolveArgs($this->_store[$itemName]['args']); } return $args; } public function register($itemName) { $this->_store[$itemName] = array(); $this->_endPoint =& $this->_store[$itemName]; return $this; } public function asValue($value) { $endPoint =& $this->_getEndPoint(); $endPoint['lookupType'] = self::TYPE_VALUE; $endPoint['value'] = $value; return $this; } public function asAliasOf($lookup) { $endPoint =& $this->_getEndPoint(); $endPoint['lookupType'] = self::TYPE_ALIAS; $endPoint['ref'] = $lookup; return $this; } public function asNewInstanceOf($className) { $endPoint =& $this->_getEndPoint(); $endPoint['lookupType'] = self::TYPE_INSTANCE; $endPoint['className'] = $className; return $this; } public function asSharedInstanceOf($className) { $endPoint =& $this->_getEndPoint(); $endPoint['lookupType'] = self::TYPE_SHARED; $endPoint['className'] = $className; return $this; } public function withDependencies(array $lookups) { $endPoint =& $this->_getEndPoint(); $endPoint['args'] = array(); foreach ($lookups as $lookup) { $this->addConstructorLookup($lookup); } return $this; } public function addConstructorValue($value) { $endPoint =& $this->_getEndPoint(); if (!isset($endPoint['args'])) { $endPoint['args'] = array(); } $endPoint['args'][] = array('type' => 'value', 'item' => $value); return $this; } public function addConstructorLookup($lookup) { $endPoint =& $this->_getEndPoint(); if (!isset($this->_endPoint['args'])) { $endPoint['args'] = array(); } $endPoint['args'][] = array('type' => 'lookup', 'item' => $lookup); return $this; } private function _getValue($itemName) { return $this->_store[$itemName]['value']; } private function _createAlias($itemName) { return $this->lookup($this->_store[$itemName]['ref']); } private function _createNewInstance($itemName) { $reflector = new ReflectionClass($this->_store[$itemName]['className']); if ($reflector->getConstructor()) { return $reflector->newInstanceArgs( $this->createDependenciesFor($itemName) ); } else { return $reflector->newInstance(); } } private function _createSharedInstance($itemName) { if (!isset($this->_store[$itemName]['instance'])) { $this->_store[$itemName]['instance'] = $this->_createNewInstance($itemName); } return $this->_store[$itemName]['instance']; } private function &_getEndPoint() { if (!isset($this->_endPoint)) { throw new BadMethodCallException( 'Component must first be registered by calling register()' ); } return $this->_endPoint; } private function _resolveArgs(array $args) { $resolved = array(); foreach ($args as $argDefinition) { switch ($argDefinition['type']) { case 'lookup': $resolved[] = $this->_lookupRecursive($argDefinition['item']); break; case 'value': $resolved[] = $argDefinition['item']; break; } } return $resolved; } private function _lookupRecursive($item) { if (is_array($item)) { $collection = array(); foreach ($item as $k => $v) { $collection[$k] = $this->_lookupRecursive($v); } return $collection; } else { return $this->lookup($item); } } }   class Swift_Encoding { public static function get7BitEncoding() { return self::_lookup('mime.7bitcontentencoder'); } public static function get8BitEncoding() { return self::_lookup('mime.8bitcontentencoder'); } public static function getQpEncoding() { return self::_lookup('mime.qpcontentencoder'); } public static function getBase64Encoding() { return self::_lookup('mime.base64contentencoder'); } private static function _lookup($key) { return Swift_DependencyContainer::getInstance()->lookup($key); } }   interface Swift_Mime_EncodingObserver { public function encoderChanged(Swift_Mime_ContentEncoder $encoder); }   interface Swift_Transport_EsmtpHandler { public function getHandledKeyword(); public function setKeywordParams(array $parameters); public function afterEhlo(Swift_Transport_SmtpAgent $agent); public function getMailParams(); public function getRcptParams(); public function onCommand(Swift_Transport_SmtpAgent $agent, $command, $codes = array(), &$failedRecipients = null, &$stop = false); public function getPriorityOver($esmtpKeyword); public function exposeMixinMethods(); public function resetState(); }   interface Swift_Events_Event { public function getSource(); public function cancelBubble($cancel = true); public function bubbleCancelled(); }   interface Swift_Events_EventDispatcher { public function createSendEvent(Swift_Transport $source, Swift_Mime_Message $message); public function createCommandEvent(Swift_Transport $source, $command, $successCodes = array()); public function createResponseEvent(Swift_Transport $source, $response, $valid); public function createTransportChangeEvent(Swift_Transport $source); public function createTransportExceptionEvent(Swift_Transport $source, Swift_TransportException $ex); public function bindEventListener(Swift_Events_EventListener $listener); public function dispatchEvent(Swift_Events_EventObject $evt, $target); }   interface Swift_Events_EventListener { }   interface Swift_Filterable { public function addFilter(Swift_StreamFilter $filter, $key); public function removeFilter($key); }   interface Swift_Mime_Header { const TYPE_TEXT = 2; const TYPE_PARAMETERIZED = 6; const TYPE_MAILBOX = 8; const TYPE_DATE = 16; const TYPE_ID = 32; const TYPE_PATH = 64; public function getFieldType(); public function setFieldBodyModel($model); public function setCharset($charset); public function getFieldBodyModel(); public function getFieldName(); public function getFieldBody(); public function toString(); }   interface Swift_InputByteStream { public function write($bytes); public function commit(); public function bind(Swift_InputByteStream $is); public function unbind(Swift_InputByteStream $is); public function flushBuffers(); }   interface Swift_KeyCache { const MODE_WRITE = 1; const MODE_APPEND = 2; public function setString($nsKey, $itemKey, $string, $mode); public function importFromByteStream($nsKey, $itemKey, Swift_OutputByteStream $os, $mode); public function getInputByteStream($nsKey, $itemKey, Swift_InputByteStream $is = null); public function getString($nsKey, $itemKey); public function exportToByteStream($nsKey, $itemKey, Swift_InputByteStream $is); public function hasKey($nsKey, $itemKey); public function clearKey($nsKey, $itemKey); public function clearAll($nsKey); }   interface Swift_Plugins_Logger { public function add($entry); public function clear(); public function dump(); }   class Swift_Transport_Esmtp_Auth_LoginAuthenticator implements Swift_Transport_Esmtp_Authenticator { public function getAuthKeyword() { return 'LOGIN'; } public function authenticate(Swift_Transport_SmtpAgent $agent, $username, $password) { try { $agent->executeCommand("AUTH LOGIN\r\n", array(334)); $agent->executeCommand(sprintf("%s\r\n", base64_encode($username)), array(334)); $agent->executeCommand(sprintf("%s\r\n", base64_encode($password)), array(235)); return true; } catch (Swift_TransportException $e) { $agent->executeCommand("RSET\r\n", array(250)); return false; } } }   class Swift_Mailer { private $_transport; public function __construct(Swift_Transport $transport) { $this->_transport = $transport; } public static function newInstance(Swift_Transport $transport) { return new self($transport); } public function send(Swift_Mime_Message $message, &$failedRecipients = null) { $failedRecipients = (array) $failedRecipients; if (!$this->_transport->isStarted()) { $this->_transport->start(); } return $this->_transport->send($message, $failedRecipients); } public function batchSend(Swift_Mime_Message $message, &$failedRecipients = null, Swift_Mailer_RecipientIterator $it = null) { $failedRecipients = (array) $failedRecipients; $sent = 0; $to = $message->getTo(); $cc = $message->getCc(); $bcc = $message->getBcc(); if (!empty($cc)) { $message->setCc(array()); } if (!empty($bcc)) { $message->setBcc(array()); } if (isset($it)) { while ($it->hasNext()) { $message->setTo($it->nextRecipient()); $sent += $this->send($message, $failedRecipients); } } else { foreach ($to as $address => $name) { $message->setTo(array($address => $name)); $sent += $this->send($message, $failedRecipients); } } $message->setTo($to); if (!empty($cc)) { $message->setCc($cc); } if (!empty($bcc)) { $message->setBcc($bcc); } return $sent; } public function registerPlugin(Swift_Events_EventListener $plugin) { $this->_transport->registerPlugin($plugin); } public function getTransport() { return $this->_transport; } }   interface Swift_Transport_MailInvoker { public function mail($to, $subject, $body, $headers = null, $extraParams = null); }   interface Swift_OutputByteStream { public function read($length); public function setReadPointer($byteOffset); }   class Swift_Transport_Esmtp_Auth_PlainAuthenticator implements Swift_Transport_Esmtp_Authenticator { public function getAuthKeyword() { return 'PLAIN'; } public function authenticate(Swift_Transport_SmtpAgent $agent, $username, $password) { try { $message = base64_encode($username . chr(0) . $username . chr(0) . $password); $agent->executeCommand(sprintf("AUTH PLAIN %s\r\n", $message), array(235)); return true; } catch (Swift_TransportException $e) { $agent->executeCommand("RSET\r\n", array(250)); return false; } } }   interface Swift_Plugins_Pop_Pop3Connection { public function connect(); public function disconnect(); }   class Swift_Preferences { private static $_instance = null; private function __construct() { } public static function getInstance() { if (!isset(self::$_instance)) { self::$_instance = new self(); } return self::$_instance; } public function setCharset($charset) { Swift_DependencyContainer::getInstance() ->register('properties.charset')->asValue($charset); return $this; } public function setTempDir($dir) { Swift_DependencyContainer::getInstance() ->register('tempdir')->asValue($dir); return $this; } public function setCacheType($type) { Swift_DependencyContainer::getInstance() ->register('cache')->asAliasOf(sprintf('cache.%s', $type)); return $this; } }   interface Swift_Mailer_RecipientIterator { public function hasNext(); public function nextRecipient(); }   interface Swift_ReplacementFilterFactory { public function createFilter($search, $replace); }   interface Swift_Plugins_Decorator_Replacements { public function getReplacementsFor($address); }   interface Swift_Plugins_Reporter { const RESULT_PASS = 0x01; const RESULT_FAIL = 0x10; public function notify(Swift_Mime_Message $message, $address, $result); }   interface Swift_Plugins_Sleeper { public function sleep($seconds); }   interface Swift_Transport_SmtpAgent { public function getBuffer(); public function executeCommand($command, $codes = array(), &$failures = null); }   interface Swift_StreamFilter { public function shouldBuffer($buffer); public function filter($buffer); }   abstract class Swift { const VERSION = '4.0.6'; public static function autoload($class) { if (0 !== strpos($class, 'Swift')) { return false; } $path = dirname(__FILE__).'/'.str_replace('_', '/', $class).'.php'; if (!file_exists($path)) { return false; } } public static function registerAutoload() { spl_autoload_register(array('Swift', 'autoload')); } }   class Swift_SwiftException extends Exception { public function __construct($message) { parent::__construct($message); } }   interface Swift_Plugins_Timer { public function getTimestamp(); }   interface Swift_Transport { public function isStarted(); public function start(); public function stop(); public function send(Swift_Mime_Message $message, &$failedRecipients = null); public function registerPlugin(Swift_Events_EventListener $plugin); }   abstract class Swift_ByteStream_AbstractFilterableInputStream implements Swift_InputByteStream, Swift_Filterable { private $_sequence = 0; private $_filters = array(); private $_writeBuffer = ''; private $_mirrors = array(); abstract protected function _commit($bytes); abstract protected function _flush(); public function addFilter(Swift_StreamFilter $filter, $key) { $this->_filters[$key] = $filter; } public function removeFilter($key) { unset($this->_filters[$key]); } public function write($bytes) { $this->_writeBuffer .= $bytes; foreach ($this->_filters as $filter) { if ($filter->shouldBuffer($this->_writeBuffer)) { return; } } $this->_doWrite($this->_writeBuffer); return ++$this->_sequence; } public function commit() { $this->_doWrite($this->_writeBuffer); } public function bind(Swift_InputByteStream $is) { $this->_mirrors[] = $is; } public function unbind(Swift_InputByteStream $is) { foreach ($this->_mirrors as $k => $stream) { if ($is === $stream) { if ($this->_writeBuffer !== '') { $stream->write($this->_filter($this->_writeBuffer)); } unset($this->_mirrors[$k]); } } } public function flushBuffers() { if ($this->_writeBuffer !== '') { $this->_doWrite($this->_writeBuffer); } $this->_flush(); foreach ($this->_mirrors as $stream) { $stream->flushBuffers(); } } private function _filter($bytes) { foreach ($this->_filters as $filter) { $bytes = $filter->filter($bytes); } return $bytes; } private function _doWrite($bytes) { $this->_commit($this->_filter($bytes)); foreach ($this->_mirrors as $stream) { $stream->write($bytes); } $this->_writeBuffer = ''; } }   abstract class Swift_Mime_Headers_AbstractHeader implements Swift_Mime_Header { private $_specials = array(); private $_grammar = array(); private $_name; private $_encoder; private $_lineLength = 78; private $_lang; private $_charset = 'utf-8'; private $_cachedValue = null; public function setCharset($charset) { $this->clearCachedValueIf($charset != $this->_charset); $this->_charset = $charset; if (isset($this->_encoder)) { $this->_encoder->charsetChanged($charset); } } public function getCharset() { return $this->_charset; } public function setLanguage($lang) { $this->clearCachedValueIf($this->_lang != $lang); $this->_lang = $lang; } public function getLanguage() { return $this->_lang; } public function setEncoder(Swift_Mime_HeaderEncoder $encoder) { $this->_encoder = $encoder; $this->setCachedValue(null); } public function getEncoder() { return $this->_encoder; } public function getFieldName() { return $this->_name; } public function setMaxLineLength($lineLength) { $this->clearCachedValueIf($this->_lineLength != $lineLength); $this->_lineLength = $lineLength; } public function getMaxLineLength() { return $this->_lineLength; } public function toString() { return $this->_tokensToString($this->toTokens()); } public function __toString() { return $this->toString(); } protected function setFieldName($name) { $this->_name = $name; } protected function initializeGrammar() { $this->_specials = array( '(', ')', '<', '>', '[', ']', ':', ';', '@', ',', '.', '"' ); $this->_grammar['NO-WS-CTL'] = '[\x01-\x08\x0B\x0C\x0E-\x19\x7F]'; $this->_grammar['WSP'] = '[ \t]'; $this->_grammar['CRLF'] = '(?:\r\n)'; $this->_grammar['FWS'] = '(?:(?:' . $this->_grammar['WSP'] . '*' . $this->_grammar['CRLF'] . ')?' . $this->_grammar['WSP'] . ')'; $this->_grammar['text'] = '[\x00-\x08\x0B\x0C\x0E-\x7F]'; $this->_grammar['quoted-pair'] = '(?:\\\\' . $this->_grammar['text'] . ')'; $this->_grammar['ctext'] = '(?:' . $this->_grammar['NO-WS-CTL'] . '|[\x21-\x27\x2A-\x5B\x5D-\x7E])'; $this->_grammar['ccontent'] = '(?:' . $this->_grammar['ctext'] . '|' . $this->_grammar['quoted-pair'] . '|(?1))'; $this->_grammar['comment'] = '(\((?:' . $this->_grammar['FWS'] . '|' . $this->_grammar['ccontent']. ')*' . $this->_grammar['FWS'] . '?\))'; $this->_grammar['CFWS'] = '(?:(?:' . $this->_grammar['FWS'] . '?' . $this->_grammar['comment'] . ')*(?:(?:' . $this->_grammar['FWS'] . '?' . $this->_grammar['comment'] . ')|' . $this->_grammar['FWS'] . '))'; $this->_grammar['qtext'] = '(?:' . $this->_grammar['NO-WS-CTL'] . '|[\x21\x23-\x5B\x5D-\x7E])'; $this->_grammar['qcontent'] = '(?:' . $this->_grammar['qtext'] . '|' . $this->_grammar['quoted-pair'] . ')'; $this->_grammar['quoted-string'] = '(?:' . $this->_grammar['CFWS'] . '?"' . '(' . $this->_grammar['FWS'] . '?' . $this->_grammar['qcontent'] . ')*' . $this->_grammar['FWS'] . '?"' . $this->_grammar['CFWS'] . '?)'; $this->_grammar['atext'] = '[a-zA-Z0-9!#\$%&\'\*\+\-\/=\?\^_`\{\}\|~]'; $this->_grammar['atom'] = '(?:' . $this->_grammar['CFWS'] . '?' . $this->_grammar['atext'] . '+' . $this->_grammar['CFWS'] . '?)'; $this->_grammar['dot-atom-text'] = '(?:' . $this->_grammar['atext'] . '+' . '(\.' . $this->_grammar['atext'] . '+)*)'; $this->_grammar['dot-atom'] = '(?:' . $this->_grammar['CFWS'] . '?' . $this->_grammar['dot-atom-text'] . '+' . $this->_grammar['CFWS'] . '?)'; $this->_grammar['word'] = '(?:' . $this->_grammar['atom'] . '|' . $this->_grammar['quoted-string'] . ')'; $this->_grammar['phrase'] = '(?:' . $this->_grammar['word'] . '+?)'; $this->_grammar['no-fold-quote'] = '(?:"(?:' . $this->_grammar['qtext'] . '|' . $this->_grammar['quoted-pair'] . ')*")'; $this->_grammar['dtext'] = '(?:' . $this->_grammar['NO-WS-CTL'] . '|[\x21-\x5A\x5E-\x7E])'; $this->_grammar['no-fold-literal'] = '(?:\[(?:' . $this->_grammar['dtext'] . '|' . $this->_grammar['quoted-pair'] . ')*\])'; $this->_grammar['id-left'] = '(?:' . $this->_grammar['dot-atom-text'] . '|' . $this->_grammar['no-fold-quote'] . ')'; $this->_grammar['id-right'] = '(?:' . $this->_grammar['dot-atom-text'] . '|' . $this->_grammar['no-fold-literal'] . ')'; $this->_grammar['local-part'] = '(?:' . $this->_grammar['dot-atom'] . '|' . $this->_grammar['quoted-string'] . ')'; $this->_grammar['dcontent'] = '(?:' . $this->_grammar['dtext'] . '|' . $this->_grammar['quoted-pair'] . ')'; $this->_grammar['domain-literal'] = '(?:' . $this->_grammar['CFWS'] . '?\[(' . $this->_grammar['FWS'] . '?' . $this->_grammar['dcontent'] . ')*?' . $this->_grammar['FWS'] . '?\]' . $this->_grammar['CFWS'] . '?)'; $this->_grammar['domain'] = '(?:' . $this->_grammar['dot-atom'] . '|' . $this->_grammar['domain-literal'] . ')'; $this->_grammar['addr-spec'] = '(?:' . $this->_grammar['local-part'] . '@' . $this->_grammar['domain'] . ')'; } protected function getGrammar($name) { if (array_key_exists($name, $this->_grammar)) { return $this->_grammar[$name]; } else { throw new Swift_RfcComplianceException( "No such grammar '" . $name . "' defined." ); } } protected function escapeSpecials($token, $include = array(), $exclude = array()) { foreach ( array_merge(array('\\'), array_diff($this->_specials, $exclude), $include) as $char) { $token = str_replace($char, '\\' . $char, $token); } return $token; } protected function createPhrase(Swift_Mime_Header $header, $string, $charset, Swift_Mime_HeaderEncoder $encoder = null, $shorten = false) { $phraseStr = $string; if (!preg_match('/^' . $this->_grammar['phrase'] . '$/D', $phraseStr)) { if (preg_match('/^' . $this->_grammar['text'] . '*$/D', $phraseStr)) { $phraseStr = $this->escapeSpecials( $phraseStr, array('"'), $this->_specials ); $phraseStr = '"' . $phraseStr . '"'; } else { if ($shorten) { $usedLength = strlen($header->getFieldName() . ': '); } else { $usedLength = 0; } $phraseStr = $this->encodeWords($header, $string, $usedLength); } } return $phraseStr; } protected function encodeWords(Swift_Mime_Header $header, $input, $usedLength = -1) { $value = ''; $tokens = $this->getEncodableWordTokens($input); foreach ($tokens as $token) { if ($this->tokenNeedsEncoding($token)) { $firstChar = substr($token, 0, 1); switch($firstChar) { case ' ': case "\t": $value .= $firstChar; $token = substr($token, 1); } if (-1 == $usedLength) { $usedLength = strlen($header->getFieldName() . ': ') + strlen($value); } $value .= $this->getTokenAsEncodedWord($token, $usedLength); $header->setMaxLineLength(76); } else { $value .= $token; } } return $value; } protected function tokenNeedsEncoding($token) { return preg_match('~[\x00-\x08\x10-\x19\x7F-\xFF\r\n]~', $token); } protected function getEncodableWordTokens($string) { $tokens = array(); $encodedToken = ''; foreach (preg_split('~(?=[\t ])~', $string) as $token) { if ($this->tokenNeedsEncoding($token)) { $encodedToken .= $token; } else { if (strlen($encodedToken) > 0) { $tokens[] = $encodedToken; $encodedToken = ''; } $tokens[] = $token; } } if (strlen($encodedToken)) { $tokens[] = $encodedToken; } return $tokens; } protected function getTokenAsEncodedWord($token, $firstLineOffset = 0) { $charsetDecl = $this->_charset; if (isset($this->_lang)) { $charsetDecl .= '*' . $this->_lang; } $encodingWrapperLength = strlen( '=?' . $charsetDecl . '?' . $this->_encoder->getName() . '??=' ); if ($firstLineOffset >= 75) { $firstLineOffset = 0; } $encodedTextLines = explode("\r\n", $this->_encoder->encodeString( $token, $firstLineOffset, 75 - $encodingWrapperLength ) ); foreach ($encodedTextLines as $lineNum => $line) { $encodedTextLines[$lineNum] = '=?' . $charsetDecl . '?' . $this->_encoder->getName() . '?' . $line . '?='; } return implode("\r\n ", $encodedTextLines); } protected function generateTokenLines($token) { return preg_split('~(\r\n)~', $token, -1, PREG_SPLIT_DELIM_CAPTURE); } protected function setCachedValue($value) { $this->_cachedValue = $value; } protected function getCachedValue() { return $this->_cachedValue; } protected function clearCachedValueIf($condition) { if ($condition) { $this->setCachedValue(null); } } protected function toTokens($string = null) { if (is_null($string)) { $string = $this->getFieldBody(); } $tokens = array(); foreach (preg_split('~(?=[ \t])~', $string) as $token) { $tokens = array_merge($tokens, $this->generateTokenLines($token)); } return $tokens; } private function _tokensToString(array $tokens) { $lineCount = 0; $headerLines = array(); $headerLines[] = $this->_name . ': '; $currentLine =& $headerLines[$lineCount++]; foreach ($tokens as $i => $token) { if (("\r\n" == $token) || ($i > 0 && strlen($currentLine . $token) > $this->_lineLength) && 0 < strlen($currentLine)) { $headerLines[] = ''; $currentLine =& $headerLines[$lineCount++]; } if ("\r\n" != $token) { $currentLine .= $token; } } return implode("\r\n", $headerLines) . "\r\n"; } }   class Swift_ByteStream_ArrayByteStream implements Swift_InputByteStream, Swift_OutputByteStream { private $_array = array(); private $_arraySize = 0; private $_offset = 0; private $_mirrors = array(); public function __construct($stack = null) { if (is_array($stack)) { $this->_array = $stack; $this->_arraySize = count($stack); } elseif (is_string($stack)) { $this->write($stack); } else { $this->_array = array(); } } public function read($length) { if ($this->_offset == $this->_arraySize) { return false; } $end = $length + $this->_offset; $end = $this->_arraySize<$end ?$this->_arraySize :$end; $ret = ''; for (; $this->_offset < $end; ++$this->_offset) { $ret .= $this->_array[$this->_offset]; } return $ret; } public function write($bytes) { $to_add = str_split($bytes); foreach ($to_add as $value) { $this->_array[] = $value; } $this->_arraySize = count($this->_array); foreach ($this->_mirrors as $stream) { $stream->write($bytes); } } public function commit() { } public function bind(Swift_InputByteStream $is) { $this->_mirrors[] = $is; } public function unbind(Swift_InputByteStream $is) { foreach ($this->_mirrors as $k => $stream) { if ($is === $stream) { unset($this->_mirrors[$k]); } } } public function setReadPointer($byteOffset) { if ($byteOffset > $this->_arraySize) { $byteOffset = $this->_arraySize; } elseif ($byteOffset < 0) { $byteOffset = 0; } $this->_offset = $byteOffset; } public function flushBuffers() { $this->_offset = 0; $this->_array = array(); $this->_arraySize = 0; foreach ($this->_mirrors as $stream) { $stream->flushBuffers(); } } }   class Swift_CharacterStream_ArrayCharacterStream implements Swift_CharacterStream { private static $_charMap; private static $_byteMap; private $_charReader; private $_charReaderFactory; private $_charset; private $_array = array(); private $_array_size = array(); private $_offset = 0; public function __construct(Swift_CharacterReaderFactory $factory, $charset) { self::_initializeMaps(); $this->setCharacterReaderFactory($factory); $this->setCharacterSet($charset); } public function setCharacterSet($charset) { $this->_charset = $charset; $this->_charReader = null; } public function setCharacterReaderFactory( Swift_CharacterReaderFactory $factory) { $this->_charReaderFactory = $factory; } public function importByteStream(Swift_OutputByteStream $os) { if (!isset($this->_charReader)) { $this->_charReader = $this->_charReaderFactory ->getReaderFor($this->_charset); } $startLength = $this->_charReader->getInitialByteSize(); while (false !== $bytes = $os->read($startLength)) { $c = array(); for ($i = 0, $len = strlen($bytes); $i < $len; ++$i) { $c[] = self::$_byteMap[$bytes[$i]]; } $size = count($c); $need = $this->_charReader ->validateByteSequence($c, $size); if ($need > 0 && false !== $bytes = $os->read($need)) { for ($i = 0, $len = strlen($bytes); $i < $len; ++$i) { $c[] = self::$_byteMap[$bytes[$i]]; } } $this->_array[] = $c; ++$this->_array_size; } } public function importString($string) { $this->flushContents(); $this->write($string); } public function read($length) { if ($this->_offset == $this->_array_size) { return false; } $arrays = array(); $end = $length + $this->_offset; for ($i = $this->_offset; $i < $end; ++$i) { if (!isset($this->_array[$i])) { break; } $arrays[] = $this->_array[$i]; } $this->_offset += $i - $this->_offset; $chars = false; foreach ($arrays as $array) { $chars .= implode('', array_map('chr', $array)); } return $chars; } public function readBytes($length) { if ($this->_offset == $this->_array_size) { return false; } $arrays = array(); $end = $length + $this->_offset; for ($i = $this->_offset; $i < $end; ++$i) { if (!isset($this->_array[$i])) { break; } $arrays[] = $this->_array[$i]; } $this->_offset += ($i - $this->_offset); return call_user_func_array('array_merge', $arrays); } public function write($chars) { if (!isset($this->_charReader)) { $this->_charReader = $this->_charReaderFactory->getReaderFor( $this->_charset); } $startLength = $this->_charReader->getInitialByteSize(); $fp = fopen('php://memory', 'w+b'); fwrite($fp, $chars); unset($chars); fseek($fp, 0, SEEK_SET); $buffer = array(0); $buf_pos = 1; $buf_len = 1; $has_datas = true; do { $bytes = array(); if ($buf_len - $buf_pos < $startLength) { $buf = array_splice($buffer, $buf_pos); $new = $this->_reloadBuffer($fp, 100); if ($new) { $buffer = array_merge($buf, $new); $buf_len = count($buffer); $buf_pos = 0; } else { $has_datas = false; } } if ($buf_len - $buf_pos > 0) { $size = 0; for ($i = 0; $i < $startLength && isset($buffer[$buf_pos]); ++$i) { ++$size; $bytes[] = $buffer[$buf_pos++]; } $need = $this->_charReader->validateByteSequence( $bytes, $size); if ($need > 0) { if ($buf_len - $buf_pos < $need) { $new = $this->_reloadBuffer($fp, $need); if ($new) { $buffer = array_merge($buffer, $new); $buf_len = count($buffer); } } for ($i = 0; $i < $need && isset($buffer[$buf_pos]); ++$i) { $bytes[] = $buffer[$buf_pos++]; } } $this->_array[] = $bytes; ++$this->_array_size; } } while ($has_datas); fclose($fp); } public function setPointer($charOffset) { if ($charOffset > $this->_array_size) { $charOffset = $this->_array_size; } elseif ($charOffset < 0) { $charOffset = 0; } $this->_offset = $charOffset; } public function flushContents() { $this->_offset = 0; $this->_array = array(); $this->_array_size = 0; } private function _reloadBuffer($fp, $len) { if (!feof($fp) && ($bytes = fread($fp, $len)) !== false) { $buf = array(); for ($i = 0, $len = strlen($bytes); $i < $len; ++$i) { $buf[] = self::$_byteMap[$bytes[$i]]; } return $buf; } return false; } private static function _initializeMaps() { if (!isset(self::$_charMap)) { self::$_charMap = array(); for ($byte = 0; $byte < 256; ++$byte) { self::$_charMap[$byte] = chr($byte); } self::$_byteMap = array_flip(self::$_charMap); } } }   class Swift_KeyCache_ArrayKeyCache implements Swift_KeyCache { private $_contents = array(); private $_stream; public function __construct(Swift_KeyCache_KeyCacheInputStream $stream) { $this->_stream = $stream; } public function setString($nsKey, $itemKey, $string, $mode) { $this->_prepareCache($nsKey); switch ($mode) { case self::MODE_WRITE: $this->_contents[$nsKey][$itemKey] = $string; break; case self::MODE_APPEND: if (!$this->hasKey($nsKey, $itemKey)) { $this->_contents[$nsKey][$itemKey] = ''; } $this->_contents[$nsKey][$itemKey] .= $string; break; default: throw new Swift_SwiftException( 'Invalid mode [' . $mode . '] used to set nsKey='. $nsKey . ', itemKey=' . $itemKey ); } } public function importFromByteStream($nsKey, $itemKey, Swift_OutputByteStream $os, $mode) { $this->_prepareCache($nsKey); switch ($mode) { case self::MODE_WRITE: $this->clearKey($nsKey, $itemKey); case self::MODE_APPEND: if (!$this->hasKey($nsKey, $itemKey)) { $this->_contents[$nsKey][$itemKey] = ''; } while (false !== $bytes = $os->read(8192)) { $this->_contents[$nsKey][$itemKey] .= $bytes; } break; default: throw new Swift_SwiftException( 'Invalid mode [' . $mode . '] used to set nsKey='. $nsKey . ', itemKey=' . $itemKey ); } } public function getInputByteStream($nsKey, $itemKey, Swift_InputByteStream $writeThrough = null) { $is = clone $this->_stream; $is->setKeyCache($this); $is->setNsKey($nsKey); $is->setItemKey($itemKey); if (isset($writeThrough)) { $is->setWriteThroughStream($writeThrough); } return $is; } public function getString($nsKey, $itemKey) { $this->_prepareCache($nsKey); if ($this->hasKey($nsKey, $itemKey)) { return $this->_contents[$nsKey][$itemKey]; } } public function exportToByteStream($nsKey, $itemKey, Swift_InputByteStream $is) { $this->_prepareCache($nsKey); $is->write($this->getString($nsKey, $itemKey)); } public function hasKey($nsKey, $itemKey) { $this->_prepareCache($nsKey); return array_key_exists($itemKey, $this->_contents[$nsKey]); } public function clearKey($nsKey, $itemKey) { unset($this->_contents[$nsKey][$itemKey]); } public function clearAll($nsKey) { unset($this->_contents[$nsKey]); } private function _prepareCache($nsKey) { if (!array_key_exists($nsKey, $this->_contents)) { $this->_contents[$nsKey] = array(); } } }   class Swift_Plugins_Loggers_ArrayLogger implements Swift_Plugins_Logger { private $_log = array(); private $_size = 0; public function __construct($size = 50) { $this->_size = $size; } public function add($entry) { $this->_log[] = $entry; while (count($this->_log) > $this->_size) { array_shift($this->_log); } } public function clear() { $this->_log = array(); } public function dump() { return implode(PHP_EOL, $this->_log); } }   class Swift_Mailer_ArrayRecipientIterator implements Swift_Mailer_RecipientIterator { private $_recipients = array(); public function __construct(array $recipients) { $this->_recipients = $recipients; } public function hasNext() { return !empty($this->_recipients); } public function nextRecipient() { return array_splice($this->_recipients, 0, 1); } }   class Swift_StreamFilters_ByteArrayReplacementFilter implements Swift_StreamFilter { private $_search; private $_replace; private $_index; private $_tree = array(); private $_treeMaxLen = 0; private $_repSize; public function __construct($search, $replace) { $this->_search = $search; $this->_index = array(); $this->_tree = array(); $this->_replace = array(); $this->_repSize = array(); $tree = null; $i = null; $last_size = $size = 0; foreach ($search as $i => $search_element) { if ($tree !== null) { $tree[-1] = min (count($replace) - 1, $i - 1); $tree[-2] = $last_size; } $tree = &$this->_tree; if (is_array ($search_element)) { foreach ($search_element as $k => $char) { $this->_index[$char] = true; if (!isset($tree[$char])) { $tree[$char] = array(); } $tree = &$tree[$char]; } $last_size = $k+1; $size = max($size, $last_size); } else { $last_size = 1; if (!isset($tree[$search_element])) { $tree[$search_element] = array(); } $tree = &$tree[$search_element]; $size = max($last_size, $size); $this->_index[$search_element] = true; } } if ($i !== null) { $tree[-1] = min (count ($replace) - 1, $i); $tree[-2] = $last_size; $this->_treeMaxLen = $size; } foreach ($replace as $rep) { if (!is_array($rep)) { $rep = array ($rep); } $this->_replace[] = $rep; } for ($i = count($this->_replace) - 1; $i >= 0; --$i) { $this->_replace[$i] = $rep = $this->filter($this->_replace[$i], $i); $this->_repSize[$i] = count($rep); } } public function shouldBuffer($buffer) { $endOfBuffer = end($buffer); return isset ($this->_index[$endOfBuffer]); } public function filter($buffer, $_minReplaces = -1) { if ($this->_treeMaxLen == 0) { return $buffer; } $newBuffer = array(); $buf_size = count($buffer); for ($i = 0; $i < $buf_size; ++$i) { $search_pos = $this->_tree; $last_found = PHP_INT_MAX; for ($j = 0; $j <= $this->_treeMaxLen; ++$j) { if (isset ($buffer [$p = $i + $j]) && isset($search_pos[$buffer[$p]])) { $search_pos = $search_pos[$buffer[$p]]; if (isset($search_pos[- 1]) && $search_pos[-1] < $last_found && $search_pos[-1] > $_minReplaces) { $last_found = $search_pos[-1]; $last_size = $search_pos[-2]; } } elseif ($last_found !== PHP_INT_MAX) { $rep_size = $this->_repSize[$last_found]; for ($j = 0; $j < $rep_size; ++$j) { $newBuffer[] = $this->_replace[$last_found][$j]; } $i += $last_size - 1; if ($i >= $buf_size) { $newBuffer[] = $buffer[$i]; } continue 2; } else { break; } } $newBuffer[] = $buffer[$i]; } return $newBuffer; } }   interface Swift_Events_CommandListener extends Swift_Events_EventListener { public function commandSent(Swift_Events_CommandEvent $evt); }   class Swift_DependencyException extends Swift_SwiftException { public function __construct($message) { parent::__construct($message); } }   class Swift_KeyCache_DiskKeyCache implements Swift_KeyCache { const POSITION_START = 0; const POSITION_END = 1; private $_stream; private $_path; private $_keys = array(); private $_quotes = false; public function __construct(Swift_KeyCache_KeyCacheInputStream $stream, $path) { $this->_stream = $stream; $this->_path = $path; $this->_quotes = get_magic_quotes_runtime(); } public function setString($nsKey, $itemKey, $string, $mode) { $this->_prepareCache($nsKey); switch ($mode) { case self::MODE_WRITE: $fp = $this->_getHandle($nsKey, $itemKey, self::POSITION_START); break; case self::MODE_APPEND: $fp = $this->_getHandle($nsKey, $itemKey, self::POSITION_END); break; default: throw new Swift_SwiftException( 'Invalid mode [' . $mode . '] used to set nsKey='. $nsKey . ', itemKey=' . $itemKey ); break; } fwrite($fp, $string); } public function importFromByteStream($nsKey, $itemKey, Swift_OutputByteStream $os, $mode) { $this->_prepareCache($nsKey); switch ($mode) { case self::MODE_WRITE: $fp = $this->_getHandle($nsKey, $itemKey, self::POSITION_START); break; case self::MODE_APPEND: $fp = $this->_getHandle($nsKey, $itemKey, self::POSITION_END); break; default: throw new Swift_SwiftException( 'Invalid mode [' . $mode . '] used to set nsKey='. $nsKey . ', itemKey=' . $itemKey ); break; } while (false !== $bytes = $os->read(8192)) { fwrite($fp, $bytes); } } public function getInputByteStream($nsKey, $itemKey, Swift_InputByteStream $writeThrough = null) { $is = clone $this->_stream; $is->setKeyCache($this); $is->setNsKey($nsKey); $is->setItemKey($itemKey); if (isset($writeThrough)) { $is->setWriteThroughStream($writeThrough); } return $is; } public function getString($nsKey, $itemKey) { $this->_prepareCache($nsKey); if ($this->hasKey($nsKey, $itemKey)) { $fp = $this->_getHandle($nsKey, $itemKey, self::POSITION_START); if ($this->_quotes) { set_magic_quotes_runtime(0); } $str = ''; while (!feof($fp) && false !== $bytes = fread($fp, 8192)) { $str .= $bytes; } if ($this->_quotes) { set_magic_quotes_runtime(1); } return $str; } } public function exportToByteStream($nsKey, $itemKey, Swift_InputByteStream $is) { if ($this->hasKey($nsKey, $itemKey)) { $fp = $this->_getHandle($nsKey, $itemKey, self::POSITION_START); if ($this->_quotes) { set_magic_quotes_runtime(0); } while (!feof($fp) && false !== $bytes = fread($fp, 8192)) { $is->write($bytes); } if ($this->_quotes) { set_magic_quotes_runtime(1); } } } public function hasKey($nsKey, $itemKey) { return is_file($this->_path . '/' . $nsKey . '/' . $itemKey); } public function clearKey($nsKey, $itemKey) { if ($this->hasKey($nsKey, $itemKey)) { $fp = $this->_getHandle($nsKey, $itemKey, self::POSITION_END); fclose($fp); unlink($this->_path . '/' . $nsKey . '/' . $itemKey); } unset($this->_keys[$nsKey][$itemKey]); } public function clearAll($nsKey) { if (array_key_exists($nsKey, $this->_keys)) { foreach ($this->_keys[$nsKey] as $itemKey=>$null) { $this->clearKey($nsKey, $itemKey); } rmdir($this->_path . '/' . $nsKey); unset($this->_keys[$nsKey]); } } private function _prepareCache($nsKey) { $cacheDir = $this->_path . '/' . $nsKey; if (!is_dir($cacheDir)) { if (!mkdir($cacheDir)) { throw new Swift_IoException('Failed to create cache directory ' . $cacheDir); } $this->_keys[$nsKey] = array(); } } private function _getHandle($nsKey, $itemKey, $position) { if (!isset($this->_keys[$nsKey]) || !array_key_exists($itemKey, $this->_keys[$nsKey])) { $fp = fopen($this->_path . '/' . $nsKey . '/' . $itemKey, 'w+b'); $this->_keys[$nsKey][$itemKey] = $fp; } if (self::POSITION_START == $position) { fseek($this->_keys[$nsKey][$itemKey], 0, SEEK_SET); } else { fseek($this->_keys[$nsKey][$itemKey], 0, SEEK_END); } return $this->_keys[$nsKey][$itemKey]; } public function __destruct() { foreach ($this->_keys as $nsKey=>$null) { $this->clearAll($nsKey); } } }   class Swift_Plugins_Loggers_EchoLogger implements Swift_Plugins_Logger { private $_isHtml; public function __construct($isHtml = true) { $this->_isHtml = $isHtml; } public function add($entry) { if ($this->_isHtml) { printf('%s%s%s', htmlspecialchars($entry, ENT_QUOTES), '<br />', PHP_EOL); } else { printf('%s%s', $entry, PHP_EOL); } } public function clear() { } public function dump() { } }   interface Swift_Encoder extends Swift_Mime_CharsetObserver { public function encodeString($string, $firstLineOffset = 0, $maxLineLength = 0); }   class Swift_Transport_EsmtpTransport extends Swift_Transport_AbstractSmtpTransport implements Swift_Transport_SmtpAgent { private $_handlers = array(); private $_capabilities = array(); private $_params = array( 'protocol' => 'tcp', 'host' => 'localhost', 'port' => 25, 'timeout' => 30, 'blocking' => 1, 'type' => Swift_Transport_IoBuffer::TYPE_SOCKET ); public function __construct(Swift_Transport_IoBuffer $buf, array $extensionHandlers, Swift_Events_EventDispatcher $dispatcher) { parent::__construct($buf, $dispatcher); $this->setExtensionHandlers($extensionHandlers); } public function setHost($host) { $this->_params['host'] = $host; return $this; } public function getHost() { return $this->_params['host']; } public function setPort($port) { $this->_params['port'] = (int) $port; return $this; } public function getPort() { return $this->_params['port']; } public function setTimeout($timeout) { $this->_params['timeout'] = (int) $timeout; return $this; } public function getTimeout() { return $this->_params['timeout']; } public function setEncryption($enc) { $this->_params['protocol'] = $enc; return $this; } public function getEncryption() { return $this->_params['protocol']; } public function setExtensionHandlers(array $handlers) { $assoc = array(); foreach ($handlers as $handler) { $assoc[$handler->getHandledKeyword()] = $handler; } uasort($assoc, array($this, '_sortHandlers')); $this->_handlers = $assoc; $this->_setHandlerParams(); return $this; } public function getExtensionHandlers() { return array_values($this->_handlers); } public function executeCommand($command, $codes = array(), &$failures = null) { $failures = (array) $failures; $stopSignal = false; $response = null; foreach ($this->_getActiveHandlers() as $handler) { $response = $handler->onCommand( $this, $command, $codes, $failures, $stopSignal ); if ($stopSignal) { return $response; } } return parent::executeCommand($command, $codes, $failures); } public function __call($method, $args) { foreach ($this->_handlers as $handler) { if (in_array(strtolower($method), array_map('strtolower', (array) $handler->exposeMixinMethods()) )) { $return = call_user_func_array(array($handler, $method), $args); if (is_null($return) && substr($method, 0, 3) == 'set') { return $this; } else { return $return; } } } trigger_error('Call to undefined method ' . $method, E_USER_ERROR); } protected function _getBufferParams() { return $this->_params; } protected function _doHeloCommand() { try { $response = $this->executeCommand( sprintf("EHLO %s\r\n", $this->_domain), array(250) ); } catch (Swift_TransportException $e) { return parent::_doHeloCommand(); } $this->_capabilities = $this->_getCapabilities($response); $this->_setHandlerParams(); foreach ($this->_getActiveHandlers() as $handler) { $handler->afterEhlo($this); } } protected function _doMailFromCommand($address) { $handlers = $this->_getActiveHandlers(); $params = array(); foreach ($handlers as $handler) { $params = array_merge($params, (array) $handler->getMailParams()); } $paramStr = !empty($params) ? ' ' . implode(' ', $params) : ''; $this->executeCommand( sprintf("MAIL FROM: <%s>%s\r\n", $address, $paramStr), array(250) ); } protected function _doRcptToCommand($address) { $handlers = $this->_getActiveHandlers(); $params = array(); foreach ($handlers as $handler) { $params = array_merge($params, (array) $handler->getRcptParams()); } $paramStr = !empty($params) ? ' ' . implode(' ', $params) : ''; $this->executeCommand( sprintf("RCPT TO: <%s>%s\r\n", $address, $paramStr), array(250, 251, 252) ); } private function _getCapabilities($ehloResponse) { $capabilities = array(); $ehloResponse = trim($ehloResponse); $lines = explode("\r\n", $ehloResponse); array_shift($lines); foreach ($lines as $line) { if (preg_match('/^[0-9]{3}[ -]([A-Z0-9-]+)((?:[ =].*)?)$/Di', $line, $matches)) { $keyword = strtoupper($matches[1]); $paramStr = strtoupper(ltrim($matches[2], ' =')); $params = !empty($paramStr) ? explode(' ', $paramStr) : array(); $capabilities[$keyword] = $params; } } return $capabilities; } private function _setHandlerParams() { foreach ($this->_handlers as $keyword => $handler) { if (array_key_exists($keyword, $this->_capabilities)) { $handler->setKeywordParams($this->_capabilities[$keyword]); } } } private function _getActiveHandlers() { $handlers = array(); foreach ($this->_handlers as $keyword => $handler) { if (array_key_exists($keyword, $this->_capabilities)) { $handlers[] = $handler; } } return $handlers; } private function _sortHandlers($a, $b) { return $a->getPriorityOver($b->getHandledKeyword()); } }   class Swift_Events_EventObject implements Swift_Events_Event { private $_source; private $_bubbleCancelled = false; public function __construct($source) { $this->_source = $source; } public function getSource() { return $this->_source; } public function cancelBubble($cancel = true) { $this->_bubbleCancelled = $cancel; } public function bubbleCancelled() { return $this->_bubbleCancelled; } }   interface Swift_FileStream extends Swift_OutputByteStream { public function getPath(); }   class Swift_CharacterReader_GenericFixedWidthReader implements Swift_CharacterReader { private $_width; public function __construct($width) { $this->_width = $width; } public function getCharPositions($string, $startOffset, &$currentMap, &$ignoredChars) { $strlen = strlen($string); $ignored = $strlen%$this->_width; $ignoredChars = substr($string, - $ignored); $currentMap = $this->_width; return ($strlen - $ignored)/$this->_width; } public function getMapType() { return self::MAP_TYPE_FIXED_LEN; } public function validateByteSequence($bytes, $size) { $needed = $this->_width - $size; return ($needed > -1) ? $needed : -1 ; } public function getInitialByteSize() { return $this->_width; } }   interface Swift_Mime_HeaderFactory extends Swift_Mime_CharsetObserver { public function createMailboxHeader($name, $addresses = null); public function createDateHeader($name, $timestamp = null); public function createTextHeader($name, $value = null); public function createParameterizedHeader($name, $value = null, $params = array()); public function createIdHeader($name, $ids = null); public function createPathHeader($name, $path = null); }   interface Swift_Mime_HeaderSet extends Swift_Mime_CharsetObserver { public function addMailboxHeader($name, $addresses = null); public function addDateHeader($name, $timestamp = null); public function addTextHeader($name, $value = null); public function addParameterizedHeader($name, $value = null, $params = array()); public function addIdHeader($name, $ids = null); public function addPathHeader($name, $path = null); public function has($name, $index = 0); public function set(Swift_Mime_Header $header, $index = 0); public function get($name, $index = 0); public function getAll($name = null); public function remove($name, $index = 0); public function removeAll($name); public function newInstance(); public function defineOrdering(array $sequence); public function setAlwaysDisplayed(array $names); public function toString(); }   class Swift_Plugins_Reporters_HitReporter implements Swift_Plugins_Reporter { private $_failures = array(); private $_failures_cache = array(); public function notify(Swift_Mime_Message $message, $address, $result) { if (self::RESULT_FAIL == $result && !isset($this->_failures_cache[$address])) { $this->_failures[] = $address; $this->_failures_cache[$address] = true; } } public function getFailedRecipients() { return $this->_failures; } public function clear() { $this->_failures = $this->_failures_cache = array(); } }   class Swift_Plugins_Reporters_HtmlReporter implements Swift_Plugins_Reporter { public function notify(Swift_Mime_Message $message, $address, $result) { if (self::RESULT_PASS == $result) { echo "<div style=\"color: #fff; background: #006600; padding: 2px; margin: 2px;\">" . PHP_EOL; echo "PASS " . $address . PHP_EOL; echo "</div>" . PHP_EOL; flush(); } else { echo "<div style=\"color: #fff; background: #880000; padding: 2px; margin: 2px;\">" . PHP_EOL; echo "FAIL " . $address . PHP_EOL; echo "</div>" . PHP_EOL; flush(); } } }   interface Swift_Transport_IoBuffer extends Swift_InputByteStream, Swift_OutputByteStream { const TYPE_SOCKET = 0x0001; const TYPE_PROCESS = 0x0010; public function initialize(array $params); public function setParam($param, $value); public function terminate(); public function setWriteTranslations(array $replacements); public function readLine($sequence); }   class Swift_IoException extends Swift_SwiftException { public function __construct($message) { parent::__construct($message); } }   interface Swift_KeyCache_KeyCacheInputStream extends Swift_InputByteStream { public function setKeyCache(Swift_KeyCache $keyCache); public function setNsKey($nsKey); public function setItemKey($itemKey); public function setWriteThroughStream(Swift_InputByteStream $is); public function __clone(); }   class Swift_Transport_LoadBalancedTransport implements Swift_Transport { private $_deadTransports = array(); protected $_transports = array(); public function __construct() { } public function setTransports(array $transports) { $this->_transports = $transports; $this->_deadTransports = array(); } public function getTransports(array $transports) { return array_merge($this->_transports, $this->_deadTransports); } public function isStarted() { return count($this->_transports) > 0; } public function start() { $this->_transports = array_merge($this->_transports, $this->_deadTransports); } public function stop() { foreach ($this->_transports as $transport) { $transport->stop(); } } public function send(Swift_Mime_Message $message, &$failedRecipients = null) { $maxTransports = count($this->_transports); $sent = 0; for ($i = 0; $i < $maxTransports && $transport = $this->_getNextTransport(); ++$i) { try { if (!$transport->isStarted()) { $transport->start(); } if ($sent = $transport->send($message, $failedRecipients)) { break; } } catch (Swift_TransportException $e) { $this->_killCurrentTransport(); } } if (count($this->_transports) == 0) { throw new Swift_TransportException( 'All Transports in LoadBalancedTransport failed, or no Transports available' ); } return $sent; } public function registerPlugin(Swift_Events_EventListener $plugin) { foreach ($this->_transports as $transport) { $transport->registerPlugin($plugin); } } protected function _getNextTransport() { if ($next = array_shift($this->_transports)) { $this->_transports[] = $next; } return $next; } protected function _killCurrentTransport() { if ($transport = array_pop($this->_transports)) { try { $transport->stop(); } catch (Exception $e) { } $this->_deadTransports[] = $transport; } } }   class Swift_Transport_MailTransport implements Swift_Transport { private $_extraParams = '-f%s'; private $_eventDispatcher; private $_invoker; public function __construct(Swift_Transport_MailInvoker $invoker, Swift_Events_EventDispatcher $eventDispatcher) { $this->_invoker = $invoker; $this->_eventDispatcher = $eventDispatcher; } public function isStarted() { return false; } public function start() { } public function stop() { } public function setExtraParams($params) { $this->_extraParams = $params; return $this; } public function getExtraParams() { return $this->_extraParams; } public function send(Swift_Mime_Message $message, &$failedRecipients = null) { $failedRecipients = (array) $failedRecipients; if ($evt = $this->_eventDispatcher->createSendEvent($this, $message)) { $this->_eventDispatcher->dispatchEvent($evt, 'beforeSendPerformed'); if ($evt->bubbleCancelled()) { return 0; } } $count = ( count((array) $message->getTo()) + count((array) $message->getCc()) + count((array) $message->getBcc()) ); $toHeader = $message->getHeaders()->get('To'); $subjectHeader = $message->getHeaders()->get('Subject'); $to = $toHeader->getFieldBody(); $subject = $subjectHeader->getFieldBody(); $reversePath = $this->_getReversePath($message); $message->getHeaders()->remove('To'); $message->getHeaders()->remove('Subject'); $messageStr = $message->toString(); $message->getHeaders()->set($toHeader); $message->getHeaders()->set($subjectHeader); if (false !== $endHeaders = strpos($messageStr, "\r\n\r\n")) { $headers = substr($messageStr, 0, $endHeaders) . "\r\n"; $body = substr($messageStr, $endHeaders + 4); } else { $headers = $messageStr . "\r\n"; $body = ''; } unset($messageStr); if ("\r\n" != PHP_EOL) { $headers = str_replace("\r\n", PHP_EOL, $headers); $body = str_replace("\r\n", PHP_EOL, $body); } else { $headers = str_replace("\r\n.", "\r\n..", $headers); $body = str_replace("\r\n.", "\r\n..", $body); } if ($this->_invoker->mail($to, $subject, $body, $headers, sprintf($this->_extraParams, $reversePath))) { if ($evt) { $evt->setResult(Swift_Events_SendEvent::RESULT_SUCCESS); $evt->setFailedRecipients($failedRecipients); $this->_eventDispatcher->dispatchEvent($evt, 'sendPerformed'); } } else { $failedRecipients = array_merge( $failedRecipients, array_keys((array) $message->getTo()), array_keys((array) $message->getCc()), array_keys((array) $message->getBcc()) ); if ($evt) { $evt->setResult(Swift_Events_SendEvent::RESULT_FAILED); $evt->setFailedRecipients($failedRecipients); $this->_eventDispatcher->dispatchEvent($evt, 'sendPerformed'); } $message->generateId(); $count = 0; } return $count; } public function registerPlugin(Swift_Events_EventListener $plugin) { $this->_eventDispatcher->bindEventListener($plugin); } private function _getReversePath(Swift_Mime_Message $message) { $return = $message->getReturnPath(); $sender = $message->getSender(); $from = $message->getFrom(); $path = null; if (!empty($return)) { $path = $return; } elseif (!empty($sender)) { $keys = array_keys($sender); $path = array_shift($keys); } elseif (!empty($from)) { $keys = array_keys($from); $path = array_shift($keys); } return $path; } }   interface Swift_Mime_MimeEntity extends Swift_Mime_CharsetObserver, Swift_Mime_EncodingObserver { const LEVEL_TOP = 16; const LEVEL_MIXED = 256; const LEVEL_ALTERNATIVE = 4096; const LEVEL_RELATED = 65536; public function getNestingLevel(); public function getContentType(); public function getId(); public function getChildren(); public function setChildren(array $children); public function getHeaders(); public function getBody(); public function setBody($body, $contentType = null); public function toString(); public function toByteStream(Swift_InputByteStream $is); }   Class Swift_CharacterStream_NgCharacterStream implements Swift_CharacterStream { private $_charReader; private $_charReaderFactory; private $_charset; private $_datas = ""; private $_datasSize = 0; private $_map; private $_mapType = 0; private $_charCount = 0; private $_currentPos = 0; public function __construct(Swift_CharacterReaderFactory $factory, $charset) { $this->setCharacterReaderFactory($factory); $this->setCharacterSet($charset); } public function setCharacterSet($charset) { $this->_charset = $charset; $this->_charReader = null; $this->_mapType = 0; } public function setCharacterReaderFactory( Swift_CharacterReaderFactory $factory) { $this->_charReaderFactory = $factory; } public function flushContents() { $this->_datas = null; $this->_map = null; $this->_charCount = 0; $this->_currentPos = 0; $this->_datasSize = 0; } public function importByteStream(Swift_OutputByteStream $os) { $this->flushContents(); $blocks=512; $os->setReadPointer(0); while(false!==($read = $os->read($blocks))) $this->write($read); } public function importString($string) { $this->flushContents(); $this->write($string); } public function read($length) { if ($this->_currentPos>=$this->_charCount) { return false; } $ret=false; $length = ($this->_currentPos+$length > $this->_charCount) ? $this->_charCount - $this->_currentPos : $length; switch ($this->_mapType) { case Swift_CharacterReader::MAP_TYPE_FIXED_LEN: $len = $length*$this->_map; $ret = substr($this->_datas, $this->_currentPos * $this->_map, $len); $this->_currentPos += $length; break; case Swift_CharacterReader::MAP_TYPE_INVALID: $end = $this->_currentPos + $length; $end = $end > $this->_charCount ?$this->_charCount :$end; $ret = ''; for (; $this->_currentPos < $length; ++$this->_currentPos) { if (isset ($this->_map[$this->_currentPos])) { $ret .= '?'; } else { $ret .= $this->_datas[$this->_currentPos]; } } break; case Swift_CharacterReader::MAP_TYPE_POSITIONS: $end = $this->_currentPos + $length; $end = $end > $this->_charCount ?$this->_charCount :$end; $ret = ''; $start = 0; if ($this->_currentPos>0) { $start = $this->_map['p'][$this->_currentPos-1]; } $to = $start; for (; $this->_currentPos < $end; ++$this->_currentPos) { if (isset($this->_map['i'][$this->_currentPos])) { $ret .= substr($this->_datas, $start, $to - $start).'?'; $start = $this->_map['p'][$this->_currentPos]; } else { $to = $this->_map['p'][$this->_currentPos]; } } $ret .= substr($this->_datas, $start, $to - $start); break; } return $ret; } public function readBytes($length) { $read=$this->read($length); if ($read!==false) { $ret = array_map('ord', str_split($read, 1)); return $ret; } return false; } public function setPointer($charOffset) { if ($this->_charCount<$charOffset){ $charOffset=$this->_charCount; } $this->_currentPos = $charOffset; } public function write($chars) { if (!isset($this->_charReader)) { $this->_charReader = $this->_charReaderFactory->getReaderFor( $this->_charset); $this->_map = array(); $this->_mapType = $this->_charReader->getMapType(); } $ignored=''; $this->_datas .= $chars; $this->_charCount += $this->_charReader->getCharPositions(substr($this->_datas, $this->_datasSize), $this->_datasSize, $this->_map, $ignored); if ($ignored!==false) { $this->_datasSize=strlen($this->_datas)-strlen($ignored); } else { $this->_datasSize=strlen($this->_datas); } } }   class Swift_KeyCache_NullKeyCache implements Swift_KeyCache { public function setString($nsKey, $itemKey, $string, $mode) { } public function importFromByteStream($nsKey, $itemKey, Swift_OutputByteStream $os, $mode) { } public function getInputByteStream($nsKey, $itemKey, Swift_InputByteStream $writeThrough = null) { } public function getString($nsKey, $itemKey) { } public function exportToByteStream($nsKey, $itemKey, Swift_InputByteStream $is) { } public function hasKey($nsKey, $itemKey) { return false; } public function clearKey($nsKey, $itemKey) { } public function clearAll($nsKey) { } }   interface Swift_Mime_ParameterizedHeader extends Swift_Mime_Header { public function setParameter($parameter, $value); public function getParameter($parameter); }   interface Swift_Events_ResponseListener extends Swift_Events_EventListener { public function responseReceived(Swift_Events_ResponseEvent $evt); }   class Swift_RfcComplianceException extends Swift_SwiftException { public function __construct($message) { parent::__construct($message); } }   interface Swift_Events_SendListener extends Swift_Events_EventListener { public function beforeSendPerformed(Swift_Events_SendEvent $evt); public function sendPerformed(Swift_Events_SendEvent $evt); }   class Swift_Transport_SendmailTransport extends Swift_Transport_AbstractSmtpTransport { private $_params = array( 'timeout' => 30, 'blocking' => 1, 'command' => '/usr/sbin/sendmail -bs', 'type' => Swift_Transport_IoBuffer::TYPE_PROCESS ); public function __construct(Swift_Transport_IoBuffer $buf, Swift_Events_EventDispatcher $dispatcher) { parent::__construct($buf, $dispatcher); } public function start() { if (false !== strpos($this->getCommand(), ' -bs')) { parent::start(); } } public function setCommand($command) { $this->_params['command'] = $command; return $this; } public function getCommand() { return $this->_params['command']; } public function send(Swift_Mime_Message $message, &$failedRecipients = null) { $failedRecipients = (array) $failedRecipients; $command = $this->getCommand(); $buffer = $this->getBuffer(); if (false !== strpos($command, ' -t')) { if ($evt = $this->_eventDispatcher->createSendEvent($this, $message)) { $this->_eventDispatcher->dispatchEvent($evt, 'beforeSendPerformed'); if ($evt->bubbleCancelled()) { return 0; } } if (false === strpos($command, ' -f')) { $command .= ' -f' . $this->_getReversePath($message); } $buffer->initialize(array_merge($this->_params, array('command' => $command))); if (false === strpos($command, ' -i') && false === strpos($command, ' -oi')) { $buffer->setWriteTranslations(array("\r\n" => "\n", "\n." => "\n..")); } else { $buffer->setWriteTranslations(array("\r\n"=>"\n")); } $count = count((array) $message->getTo()) + count((array) $message->getCc()) + count((array) $message->getBcc()) ; $message->toByteStream($buffer); $buffer->flushBuffers(); $buffer->setWriteTranslations(array()); $buffer->terminate(); if ($evt) { $evt->setResult(Swift_Events_SendEvent::RESULT_SUCCESS); $evt->setFailedRecipients($failedRecipients); $this->_eventDispatcher->dispatchEvent($evt, 'sendPerformed'); } $message->generateId(); } elseif (false !== strpos($command, ' -bs')) { $count = parent::send($message, $failedRecipients); } else { $this->_throwException(new Swift_TransportException( 'Unsupported sendmail command flags [' . $command . ']. ' . 'Must be one of "-bs" or "-t" but can include additional flags.' )); } return $count; } protected function _getBufferParams() { return $this->_params; } }   class Swift_CharacterReaderFactory_SimpleCharacterReaderFactory implements Swift_CharacterReaderFactory { private $_map = array(); private $_loaded = array(); public function __construct() { $prefix = 'Swift_CharacterReader_'; $singleByte = array( 'class' => $prefix . 'GenericFixedWidthReader', 'constructor' => array(1) ); $doubleByte = array( 'class' => $prefix . 'GenericFixedWidthReader', 'constructor' => array(2) ); $fourBytes = array( 'class' => $prefix . 'GenericFixedWidthReader', 'constructor' => array(4) ); $this->_map['utf-?8'] = array( 'class' => $prefix . 'Utf8Reader', 'constructor' => array() ); $this->_map['(us-)?ascii'] = $singleByte; $this->_map['(iso|iec)-?8859-?[0-9]+'] = $singleByte; $this->_map['windows-?125[0-9]'] = $singleByte; $this->_map['cp-?[0-9]+'] = $singleByte; $this->_map['ansi'] = $singleByte; $this->_map['macintosh'] = $singleByte; $this->_map['koi-?7'] = $singleByte; $this->_map['koi-?8-?.+'] = $singleByte; $this->_map['mik'] = $singleByte; $this->_map['(cork|t1)'] = $singleByte; $this->_map['v?iscii'] = $singleByte; $this->_map['(ucs-?2|utf-?16)'] = $doubleByte; $this->_map['(ucs-?4|utf-?32)'] = $fourBytes; $this->_map['.*'] = $singleByte; } public function getReaderFor($charset) { $charset = trim(strtolower($charset)); foreach ($this->_map as $pattern => $spec) { $re = '/^' . $pattern . '$/D'; if (preg_match($re, $charset)) { if (!array_key_exists($pattern, $this->_loaded)) { $reflector = new ReflectionClass($spec['class']); if ($reflector->getConstructor()) { $reader = $reflector->newInstanceArgs($spec['constructor']); } else { $reader = $reflector->newInstance(); } $this->_loaded[$pattern] = $reader; } return $this->_loaded[$pattern]; } } } }   class Swift_Events_SimpleEventDispatcher implements Swift_Events_EventDispatcher { private $_eventMap = array(); private $_listeners = array(); private $_bubbleQueue = array(); public function __construct() { $this->_eventMap = array( 'Swift_Events_CommandEvent' => 'Swift_Events_CommandListener', 'Swift_Events_ResponseEvent' => 'Swift_Events_ResponseListener', 'Swift_Events_SendEvent' => 'Swift_Events_SendListener', 'Swift_Events_TransportChangeEvent' => 'Swift_Events_TransportChangeListener', 'Swift_Events_TransportExceptionEvent' => 'Swift_Events_TransportExceptionListener' ); } public function createSendEvent(Swift_Transport $source, Swift_Mime_Message $message) { return new Swift_Events_SendEvent($source, $message); } public function createCommandEvent(Swift_Transport $source, $command, $successCodes = array()) { return new Swift_Events_CommandEvent($source, $command, $successCodes); } public function createResponseEvent(Swift_Transport $source, $response, $valid) { return new Swift_Events_ResponseEvent($source, $response, $valid); } public function createTransportChangeEvent(Swift_Transport $source) { return new Swift_Events_TransportChangeEvent($source); } public function createTransportExceptionEvent(Swift_Transport $source, Swift_TransportException $ex) { return new Swift_Events_TransportExceptionEvent($source, $ex); } public function bindEventListener(Swift_Events_EventListener $listener) { foreach ($this->_listeners as $l) { if ($l === $listener) { return; } } $this->_listeners[] = $listener; } public function dispatchEvent(Swift_Events_EventObject $evt, $target) { $this->_prepareBubbleQueue($evt); $this->_bubble($evt, $target); } private function _prepareBubbleQueue(Swift_Events_EventObject $evt) { $this->_bubbleQueue = array(); $evtClass = get_class($evt); foreach ($this->_listeners as $listener) { if (array_key_exists($evtClass, $this->_eventMap) && ($listener instanceof $this->_eventMap[$evtClass])) { $this->_bubbleQueue[] = $listener; } } } private function _bubble(Swift_Events_EventObject $evt, $target) { if (!$evt->bubbleCancelled() && $listener = array_shift($this->_bubbleQueue)) { $listener->$target($evt); $this->_bubble($evt, $target); } } }   class Swift_Transport_SimpleMailInvoker implements Swift_Transport_MailInvoker { public function mail($to, $subject, $body, $headers = null, $extraParams = null) { if (!ini_get('safe_mode')) { return mail($to, $subject, $body, $headers, $extraParams); } else { return mail($to, $subject, $body, $headers); } } }   class Swift_StreamFilters_StringReplacementFilter implements Swift_StreamFilter { private $_search; private $_replace; public function __construct($search, $replace) { $this->_search = $search; $this->_replace = $replace; } public function shouldBuffer($buffer) { $endOfBuffer = substr($buffer, -1); foreach ((array) $this->_search as $needle) { if (false !== strpos($needle, $endOfBuffer)) { return true; } } return false; } public function filter($buffer) { return str_replace($this->_search, $this->_replace, $buffer); } }   class Swift_StreamFilters_StringReplacementFilterFactory implements Swift_ReplacementFilterFactory { private $_filters = array(); public function createFilter($search, $replace) { if (!isset($this->_filters[$search][$replace])) { if (!isset($this->_filters[$search])) { $this->_filters[$search] = array(); } if (!isset($this->_filters[$search][$replace])) { $this->_filters[$search][$replace] = array(); } $this->_filters[$search][$replace] = new Swift_StreamFilters_StringReplacementFilter($search, $replace); } return $this->_filters[$search][$replace]; } }   interface Swift_Events_TransportChangeListener extends Swift_Events_EventListener { public function beforeTransportStarted(Swift_Events_TransportChangeEvent $evt); public function transportStarted(Swift_Events_TransportChangeEvent $evt); public function beforeTransportStopped(Swift_Events_TransportChangeEvent $evt); public function transportStopped(Swift_Events_TransportChangeEvent $evt); }   interface Swift_Events_TransportExceptionListener extends Swift_Events_EventListener { public function exceptionThrown(Swift_Events_TransportExceptionEvent $evt); }   class Swift_CharacterReader_UsAsciiReader implements Swift_CharacterReader { public function getCharPositions($string, $startOffset, &$currentMap, &$ignoredChars) { $strlen=strlen($string); $ignoredChars=''; for( $i = 0; $i < $strlen; ++$i) { if ($string[$i]>"\x07F") { $currentMap[$i+$startOffset]=$string[$i]; } } return $strlen; } public function getMapType() { return self::MAP_TYPE_INVALID; } public function validateByteSequence($bytes, $size) { $byte = reset($bytes); if (1 == count($bytes) && $byte >= 0x00 && $byte <= 0x7F) { return 0; } else { return -1; } } public function getInitialByteSize() { return 1; } }   class Swift_CharacterReader_Utf8Reader implements Swift_CharacterReader { private static $length_map=array( 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0 ); private static $s_length_map=array( "\x00"=>1, "\x01"=>1, "\x02"=>1, "\x03"=>1, "\x04"=>1, "\x05"=>1, "\x06"=>1, "\x07"=>1, "\x08"=>1, "\x09"=>1, "\x0a"=>1, "\x0b"=>1, "\x0c"=>1, "\x0d"=>1, "\x0e"=>1, "\x0f"=>1, "\x10"=>1, "\x11"=>1, "\x12"=>1, "\x13"=>1, "\x14"=>1, "\x15"=>1, "\x16"=>1, "\x17"=>1, "\x18"=>1, "\x19"=>1, "\x1a"=>1, "\x1b"=>1, "\x1c"=>1, "\x1d"=>1, "\x1e"=>1, "\x1f"=>1, "\x20"=>1, "\x21"=>1, "\x22"=>1, "\x23"=>1, "\x24"=>1, "\x25"=>1, "\x26"=>1, "\x27"=>1, "\x28"=>1, "\x29"=>1, "\x2a"=>1, "\x2b"=>1, "\x2c"=>1, "\x2d"=>1, "\x2e"=>1, "\x2f"=>1, "\x30"=>1, "\x31"=>1, "\x32"=>1, "\x33"=>1, "\x34"=>1, "\x35"=>1, "\x36"=>1, "\x37"=>1, "\x38"=>1, "\x39"=>1, "\x3a"=>1, "\x3b"=>1, "\x3c"=>1, "\x3d"=>1, "\x3e"=>1, "\x3f"=>1, "\x40"=>1, "\x41"=>1, "\x42"=>1, "\x43"=>1, "\x44"=>1, "\x45"=>1, "\x46"=>1, "\x47"=>1, "\x48"=>1, "\x49"=>1, "\x4a"=>1, "\x4b"=>1, "\x4c"=>1, "\x4d"=>1, "\x4e"=>1, "\x4f"=>1, "\x50"=>1, "\x51"=>1, "\x52"=>1, "\x53"=>1, "\x54"=>1, "\x55"=>1, "\x56"=>1, "\x57"=>1, "\x58"=>1, "\x59"=>1, "\x5a"=>1, "\x5b"=>1, "\x5c"=>1, "\x5d"=>1, "\x5e"=>1, "\x5f"=>1, "\x60"=>1, "\x61"=>1, "\x62"=>1, "\x63"=>1, "\x64"=>1, "\x65"=>1, "\x66"=>1, "\x67"=>1, "\x68"=>1, "\x69"=>1, "\x6a"=>1, "\x6b"=>1, "\x6c"=>1, "\x6d"=>1, "\x6e"=>1, "\x6f"=>1, "\x70"=>1, "\x71"=>1, "\x72"=>1, "\x73"=>1, "\x74"=>1, "\x75"=>1, "\x76"=>1, "\x77"=>1, "\x78"=>1, "\x79"=>1, "\x7a"=>1, "\x7b"=>1, "\x7c"=>1, "\x7d"=>1, "\x7e"=>1, "\x7f"=>1, "\x80"=>0, "\x81"=>0, "\x82"=>0, "\x83"=>0, "\x84"=>0, "\x85"=>0, "\x86"=>0, "\x87"=>0, "\x88"=>0, "\x89"=>0, "\x8a"=>0, "\x8b"=>0, "\x8c"=>0, "\x8d"=>0, "\x8e"=>0, "\x8f"=>0, "\x90"=>0, "\x91"=>0, "\x92"=>0, "\x93"=>0, "\x94"=>0, "\x95"=>0, "\x96"=>0, "\x97"=>0, "\x98"=>0, "\x99"=>0, "\x9a"=>0, "\x9b"=>0, "\x9c"=>0, "\x9d"=>0, "\x9e"=>0, "\x9f"=>0, "\xa0"=>0, "\xa1"=>0, "\xa2"=>0, "\xa3"=>0, "\xa4"=>0, "\xa5"=>0, "\xa6"=>0, "\xa7"=>0, "\xa8"=>0, "\xa9"=>0, "\xaa"=>0, "\xab"=>0, "\xac"=>0, "\xad"=>0, "\xae"=>0, "\xaf"=>0, "\xb0"=>0, "\xb1"=>0, "\xb2"=>0, "\xb3"=>0, "\xb4"=>0, "\xb5"=>0, "\xb6"=>0, "\xb7"=>0, "\xb8"=>0, "\xb9"=>0, "\xba"=>0, "\xbb"=>0, "\xbc"=>0, "\xbd"=>0, "\xbe"=>0, "\xbf"=>0, "\xc0"=>2, "\xc1"=>2, "\xc2"=>2, "\xc3"=>2, "\xc4"=>2, "\xc5"=>2, "\xc6"=>2, "\xc7"=>2, "\xc8"=>2, "\xc9"=>2, "\xca"=>2, "\xcb"=>2, "\xcc"=>2, "\xcd"=>2, "\xce"=>2, "\xcf"=>2, "\xd0"=>2, "\xd1"=>2, "\xd2"=>2, "\xd3"=>2, "\xd4"=>2, "\xd5"=>2, "\xd6"=>2, "\xd7"=>2, "\xd8"=>2, "\xd9"=>2, "\xda"=>2, "\xdb"=>2, "\xdc"=>2, "\xdd"=>2, "\xde"=>2, "\xdf"=>2, "\xe0"=>3, "\xe1"=>3, "\xe2"=>3, "\xe3"=>3, "\xe4"=>3, "\xe5"=>3, "\xe6"=>3, "\xe7"=>3, "\xe8"=>3, "\xe9"=>3, "\xea"=>3, "\xeb"=>3, "\xec"=>3, "\xed"=>3, "\xee"=>3, "\xef"=>3, "\xf0"=>4, "\xf1"=>4, "\xf2"=>4, "\xf3"=>4, "\xf4"=>4, "\xf5"=>4, "\xf6"=>4, "\xf7"=>4, "\xf8"=>5, "\xf9"=>5, "\xfa"=>5, "\xfb"=>5, "\xfc"=>6, "\xfd"=>6, "\xfe"=>0, "\xff"=>0, ); public function getCharPositions($string, $startOffset, &$currentMap, &$ignoredChars) { if (!isset($currentMap['i']) || !isset($currentMap['p'])) { $currentMap['p'] = $currentMap['i'] = array(); } $strlen=strlen($string); $charPos=count($currentMap['p']); $foundChars=0; $invalid=false; for ($i=0; $i<$strlen; ++$i) { $char=$string[$i]; $size=self::$s_length_map[$char]; if ($size==0) { $invalid=true; continue; } else { if ($invalid==true) { $currentMap['p'][$charPos+$foundChars]=$startOffset+$i; $currentMap['i'][$charPos+$foundChars]=true; ++$foundChars; $invalid=false; } if (($i+$size) > $strlen){ $ignoredChars=substr($string, $i); break; } for ($j=1; $j<$size; ++$j) { $char=$string[$i+$j]; if ($char>"\x7F" && $char<"\xC0") { } else { $invalid=true; continue 2; } } $lastChar=$currentMap['p'][$charPos+$foundChars]=$startOffset+$i+$size; $i+=$j-1; ++$foundChars; } } return $foundChars; } public function getMapType() { return self::MAP_TYPE_POSITIONS; } public function validateByteSequence($bytes, $size) { if ($size<1){ return -1; } $needed = self::$length_map[$bytes[0]] - $size; return ($needed > -1) ? $needed : -1 ; } public function getInitialByteSize() { return 1; } }   class Swift_Plugins_AntiFloodPlugin implements Swift_Events_SendListener, Swift_Plugins_Sleeper { private $_threshold; private $_sleep; private $_counter = 0; private $_sleeper; public function __construct($threshold = 99, $sleep = 0, Swift_Plugins_Sleeper $sleeper = null) { $this->setThreshold($threshold); $this->setSleepTime($sleep); $this->_sleeper = $sleeper; } public function setThreshold($threshold) { $this->_threshold = $threshold; } public function getThreshold() { return $this->_threshold; } public function setSleepTime($sleep) { $this->_sleep = $sleep; } public function getSleepTime() { return $this->_sleep; } public function beforeSendPerformed(Swift_Events_SendEvent $evt) { } public function sendPerformed(Swift_Events_SendEvent $evt) { ++$this->_counter; if ($this->_counter >= $this->_threshold) { $transport = $evt->getTransport(); $transport->stop(); if ($this->_sleep) { $this->sleep($this->_sleep); } $transport->start(); $this->_counter = 0; } } public function sleep($seconds) { if (isset($this->_sleeper)) { $this->_sleeper->sleep($seconds); } else { sleep($seconds); } } }   class Swift_Plugins_BandwidthMonitorPlugin implements Swift_Events_SendListener, Swift_Events_CommandListener, Swift_Events_ResponseListener, Swift_InputByteStream { private $_out = 0; private $_in = 0; private $_mirrors = array(); public function beforeSendPerformed(Swift_Events_SendEvent $evt) { } public function sendPerformed(Swift_Events_SendEvent $evt) { $message = $evt->getMessage(); $message->toByteStream($this); } public function commandSent(Swift_Events_CommandEvent $evt) { $command = $evt->getCommand(); $this->_out += strlen($command); } public function responseReceived(Swift_Events_ResponseEvent $evt) { $response = $evt->getResponse(); $this->_in += strlen($response); } public function write($bytes) { $this->_out += strlen($bytes); foreach ($this->_mirrors as $stream) { $stream->write($bytes); } } public function commit() { } public function bind(Swift_InputByteStream $is) { $this->_mirrors[] = $is; } public function unbind(Swift_InputByteStream $is) { foreach ($this->_mirrors as $k => $stream) { if ($is === $stream) { unset($this->_mirrors[$k]); } } } public function flushBuffers() { foreach ($this->_mirrors as $stream) { $stream->flushBuffers(); } } public function getBytesOut() { return $this->_out; } public function getBytesIn() { return $this->_in; } public function reset() { $this->_out = 0; $this->_in = 0; } }   class Swift_Encoder_Base64Encoder implements Swift_Encoder { public function encodeString($string, $firstLineOffset = 0, $maxLineLength = 0) { if (0 >= $maxLineLength || 76 < $maxLineLength) { $maxLineLength = 76; } $encodedString = base64_encode($string); $firstLine = ''; if (0 != $firstLineOffset) { $firstLine = substr( $encodedString, 0, $maxLineLength - $firstLineOffset ) . "\r\n"; $encodedString = substr( $encodedString, $maxLineLength - $firstLineOffset ); } return $firstLine . trim(chunk_split($encodedString, $maxLineLength, "\r\n")); } public function charsetChanged($charset) { } }   class Swift_Events_CommandEvent extends Swift_Events_EventObject { private $_command; private $_successCodes = array(); public function __construct(Swift_Transport $source, $command, $successCodes = array()) { parent::__construct($source); $this->_command = $command; $this->_successCodes = $successCodes; } public function getCommand() { return $this->_command; } public function getSuccessCodes() { return $this->_successCodes; } }   interface Swift_Mime_ContentEncoder extends Swift_Encoder { public function encodeByteStream( Swift_OutputByteStream $os, Swift_InputByteStream $is, $firstLineOffset = 0, $maxLineLength = 0); public function getName(); }   class Swift_Mime_Headers_DateHeader extends Swift_Mime_Headers_AbstractHeader { private $_timestamp; public function __construct($name) { $this->setFieldName($name); } public function getFieldType() { return self::TYPE_DATE; } public function setFieldBodyModel($model) { $this->setTimestamp($model); } public function getFieldBodyModel() { return $this->getTimestamp(); } public function getTimestamp() { return $this->_timestamp; } public function setTimestamp($timestamp) { if (!is_null($timestamp)) { $timestamp = (int) $timestamp; } $this->clearCachedValueIf($this->_timestamp != $timestamp); $this->_timestamp = $timestamp; } public function getFieldBody() { if (!$this->getCachedValue()) { if (isset($this->_timestamp)) { $this->setCachedValue(date('r', $this->_timestamp)); } } return $this->getCachedValue(); } }   class Swift_Plugins_DecoratorPlugin implements Swift_Events_SendListener, Swift_Plugins_Decorator_Replacements { private $_replacements; private $_orginalBody; private $_originalSubject; private $_originalChildBodies = array(); private $_lastMessage; public function __construct($replacements) { if (!($replacements instanceof Swift_Plugins_Decorator_Replacements)) { $this->_replacements = (array) $replacements; } else { $this->_replacements = $replacements; } } public function beforeSendPerformed(Swift_Events_SendEvent $evt) { $message = $evt->getMessage(); $this->_restoreMessage($message); $to = array_keys($message->getTo()); $address = array_shift($to); if ($replacements = $this->getReplacementsFor($address)) { $body = $message->getBody(); $search = array_keys($replacements); $replace = array_values($replacements); $bodyReplaced = str_replace( $search, $replace, $body ); if ($body != $bodyReplaced) { $this->_originalBody = $body; $message->setBody($bodyReplaced); } $subject = $message->getSubject(); $subjectReplaced = str_replace( $search, $replace, $subject ); if ($subject != $subjectReplaced) { $this->_originalSubject = $subject; $message->setSubject($subjectReplaced); } $children = (array) $message->getChildren(); foreach ($children as $child) { list($type, ) = sscanf($child->getContentType(), '%[^/]/%s'); if ('text' == $type) { $body = $child->getBody(); $bodyReplaced = str_replace( $search, $replace, $body ); if ($body != $bodyReplaced) { $child->setBody($bodyReplaced); $this->_originalChildBodies[$child->getId()] = $body; } } } $this->_lastMessage = $message; } } public function getReplacementsFor($address) { if ($this->_replacements instanceof Swift_Plugins_Decorator_Replacements) { return $this->_replacements->getReplacementsFor($address); } else { return isset($this->_replacements[$address]) ? $this->_replacements[$address] : null ; } } public function sendPerformed(Swift_Events_SendEvent $evt) { $this->_restoreMessage($evt->getMessage()); } private function _restoreMessage(Swift_Mime_Message $message) { if ($this->_lastMessage === $message) { if (isset($this->_originalBody)) { $message->setBody($this->_originalBody); $this->_originalBody = null; } if (isset($this->_originalSubject)) { $message->setSubject($this->_originalSubject); $this->_originalSubject = null; } if (!empty($this->_originalChildBodies)) { $children = (array) $message->getChildren(); foreach ($children as $child) { $id = $child->getId(); if (array_key_exists($id, $this->_originalChildBodies)) { $child->setBody($this->_originalChildBodies[$id]); } } $this->_originalChildBodies = array(); } $this->_lastMessage = null; } } }   class Swift_Transport_FailoverTransport extends Swift_Transport_LoadBalancedTransport { private $_currentTransport; public function __construct() { parent::__construct(); } public function send(Swift_Mime_Message $message, &$failedRecipients = null) { $maxTransports = count($this->_transports); $sent = 0; for ($i = 0; $i < $maxTransports && $transport = $this->_getNextTransport(); ++$i) { try { if (!$transport->isStarted()) { $transport->start(); } return $transport->send($message, $failedRecipients); } catch (Swift_TransportException $e) { $this->_killCurrentTransport(); } } if (count($this->_transports) == 0) { throw new Swift_TransportException( 'All Transports in FailoverTransport failed, or no Transports available' ); } return $sent; } protected function _getNextTransport() { if (!isset($this->_currentTransport)) { $this->_currentTransport = parent::_getNextTransport(); } return $this->_currentTransport; } protected function _killCurrentTransport() { $this->_currentTransport = null; parent::_killCurrentTransport(); } }   class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream implements Swift_FileStream { private $_offset = 0; private $_path; private $_mode; private $_reader; private $_writer; private $_quotes = false; public function __construct($path, $writable = false) { $this->_path = $path; $this->_mode = $writable ? 'w+b' : 'rb'; $this->_quotes = get_magic_quotes_runtime(); } public function getPath() { return $this->_path; } public function read($length) { $fp = $this->_getReadHandle(); if (!feof($fp)) { if ($this->_quotes) { set_magic_quotes_runtime(0); } $bytes = fread($fp, $length); if ($this->_quotes) { set_magic_quotes_runtime(1); } $this->_offset = ftell($fp); return $bytes; } else { return false; } } public function setReadPointer($byteOffset) { if (isset($this->_reader)) { fseek($this->_reader, $byteOffset, SEEK_SET); } $this->_offset = $byteOffset; } protected function _commit($bytes) { fwrite($this->_getWriteHandle(), $bytes); $this->_resetReadHandle(); } protected function _flush() { } private function _getReadHandle() { if (!isset($this->_reader)) { if (!$this->_reader = fopen($this->_path, 'rb')) { throw new Swift_IoException( 'Unable to open file for reading [' . $this->_path . ']' ); } fseek($this->_reader, $this->_offset, SEEK_SET); } return $this->_reader; } private function _getWriteHandle() { if (!isset($this->_writer)) { if (!$this->_writer = fopen($this->_path, $this->_mode)) { throw new Swift_IoException( 'Unable to open file for writing [' . $this->_path . ']' ); } } return $this->_writer; } private function _resetWriteHandle() { if (isset($this->_writer)) { fclose($this->_writer); $this->_writer = null; } } private function _resetReadHandle() { if (isset($this->_reader)) { fclose($this->_reader); $this->_reader = null; } } }   interface Swift_Mime_HeaderEncoder extends Swift_Encoder { public function getName(); }   class Swift_Mime_Headers_IdentificationHeader extends Swift_Mime_Headers_AbstractHeader { private $_ids = array(); public function __construct($name) { $this->setFieldName($name); $this->initializeGrammar(); } public function getFieldType() { return self::TYPE_ID; } public function setFieldBodyModel($model) { $this->setId($model); } public function getFieldBodyModel() { return $this->getIds(); } public function setId($id) { return $this->setIds(array($id)); } public function getId() { if (count($this->_ids) > 0) { return $this->_ids[0]; } } public function setIds(array $ids) { $actualIds = array(); foreach ($ids as $k => $id) { if (preg_match( '/^' . $this->getGrammar('id-left') . '@' . $this->getGrammar('id-right') . '$/D', $id )) { $actualIds[] = $id; } else { throw new Swift_RfcComplianceException( 'Invalid ID given <' . $id . '>' ); } } $this->clearCachedValueIf($this->_ids != $actualIds); $this->_ids = $actualIds; } public function getIds() { return $this->_ids; } public function getFieldBody() { if (!$this->getCachedValue()) { $angleAddrs = array(); foreach ($this->_ids as $id) { $angleAddrs[] = '<' . $id . '>'; } $this->setCachedValue(implode(' ', $angleAddrs)); } return $this->getCachedValue(); } }   class Swift_LoadBalancedTransport extends Swift_Transport_LoadBalancedTransport { public function __construct($transports = array()) { call_user_func_array( array($this, 'Swift_Transport_LoadBalancedTransport::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('transport.loadbalanced') ); $this->setTransports($transports); } public static function newInstance($transports = array()) { return new self($transports); } }   class Swift_Plugins_LoggerPlugin implements Swift_Events_CommandListener, Swift_Events_ResponseListener, Swift_Events_TransportChangeListener, Swift_Events_TransportExceptionListener, Swift_Plugins_Logger { private $_logger; public function __construct(Swift_Plugins_Logger $logger) { $this->_logger = $logger; } public function add($entry) { $this->_logger->add($entry); } public function clear() { $this->_logger->clear(); } public function dump() { return $this->_logger->dump(); } public function commandSent(Swift_Events_CommandEvent $evt) { $command = $evt->getCommand(); $this->_logger->add(sprintf(">> %s", $command)); } public function responseReceived(Swift_Events_ResponseEvent $evt) { $response = $evt->getResponse(); $this->_logger->add(sprintf("<< %s", $response)); } public function beforeTransportStarted(Swift_Events_TransportChangeEvent $evt) { $transportName = get_class($evt->getSource()); $this->_logger->add(sprintf("++ Starting %s", $transportName)); } public function transportStarted(Swift_Events_TransportChangeEvent $evt) { $transportName = get_class($evt->getSource()); $this->_logger->add(sprintf("++ %s started", $transportName)); } public function beforeTransportStopped(Swift_Events_TransportChangeEvent $evt) { $transportName = get_class($evt->getSource()); $this->_logger->add(sprintf("++ Stopping %s", $transportName)); } public function transportStopped(Swift_Events_TransportChangeEvent $evt) { $transportName = get_class($evt->getSource()); $this->_logger->add(sprintf("++ %s stopped", $transportName)); } public function exceptionThrown(Swift_Events_TransportExceptionEvent $evt) { $e = $evt->getException(); $message = $e->getMessage(); $this->_logger->add(sprintf("!! %s", $message)); $message .= PHP_EOL; $message .= 'Log data:' . PHP_EOL; $message .= $this->_logger->dump(); $evt->cancelBubble(); throw new Swift_TransportException($message); } }   class Swift_Mime_Headers_MailboxHeader extends Swift_Mime_Headers_AbstractHeader { private $_mailboxes = array(); public function __construct($name, Swift_Mime_HeaderEncoder $encoder) { $this->setFieldName($name); $this->setEncoder($encoder); $this->initializeGrammar(); } public function getFieldType() { return self::TYPE_MAILBOX; } public function setFieldBodyModel($model) { $this->setNameAddresses($model); } public function getFieldBodyModel() { return $this->getNameAddresses(); } public function setNameAddresses($mailboxes) { $this->_mailboxes = $this->normalizeMailboxes((array) $mailboxes); $this->setCachedValue(null); } public function getNameAddressStrings() { return $this->_createNameAddressStrings($this->getNameAddresses()); } public function getNameAddresses() { return $this->_mailboxes; } public function setAddresses($addresses) { return $this->setNameAddresses(array_values((array) $addresses)); } public function getAddresses() { return array_keys($this->_mailboxes); } public function removeAddresses($addresses) { $this->setCachedValue(null); foreach ((array) $addresses as $address) { unset($this->_mailboxes[$address]); } } public function getFieldBody() { if (is_null($this->getCachedValue())) { $this->setCachedValue($this->createMailboxListString($this->_mailboxes)); } return $this->getCachedValue(); } protected function normalizeMailboxes(array $mailboxes) { $actualMailboxes = array(); foreach ($mailboxes as $key => $value) { if (is_string($key)) { $address = $key; $name = $value; } else { $address = $value; $name = null; } $this->_assertValidAddress($address); $actualMailboxes[$address] = $name; } return $actualMailboxes; } protected function createDisplayNameString($displayName, $shorten = false) { return $this->createPhrase($this, $displayName, $this->getCharset(), $this->getEncoder(), $shorten ); } protected function createMailboxListString(array $mailboxes) { return implode(', ', $this->_createNameAddressStrings($mailboxes)); } private function _createNameAddressStrings(array $mailboxes) { $strings = array(); foreach ($mailboxes as $email => $name) { $mailboxStr = $email; if (!is_null($name)) { $nameStr = $this->createDisplayNameString($name, empty($strings)); $mailboxStr = $nameStr . ' <' . $mailboxStr . '>'; } $strings[] = $mailboxStr; } return $strings; } private function _assertValidAddress($address) { if (!preg_match('/^' . $this->getGrammar('addr-spec') . '$/D', $address)) { throw new Swift_RfcComplianceException( 'Address in mailbox given [' . $address . '] does not comply with RFC 2822, 3.6.2.' ); } } }   class Swift_MailTransport extends Swift_Transport_MailTransport { public function __construct($extraParams = '-f%s') { call_user_func_array( array($this, 'Swift_Transport_MailTransport::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('transport.mail') ); $this->setExtraParams($extraParams); } public static function newInstance($extraParams = '-f%s') { return new self($extraParams); } }   interface Swift_Mime_Message extends Swift_Mime_MimeEntity { public function generateId(); public function setSubject($subject); public function getSubject(); public function setDate($date); public function getDate(); public function setReturnPath($address); public function getReturnPath(); public function setSender($address, $name = null); public function getSender(); public function setFrom($addresses, $name = null); public function getFrom(); public function setReplyTo($addresses, $name = null); public function getReplyTo(); public function setTo($addresses, $name = null); public function getTo(); public function setCc($addresses, $name = null); public function getCc(); public function setBcc($addresses, $name = null); public function getBcc(); }   class Swift_Mime_Headers_PathHeader extends Swift_Mime_Headers_AbstractHeader { private $_address; public function __construct($name) { $this->setFieldName($name); $this->initializeGrammar(); } public function getFieldType() { return self::TYPE_PATH; } public function setFieldBodyModel($model) { $this->setAddress($model); } public function getFieldBodyModel() { return $this->getAddress(); } public function setAddress($address) { if (is_null($address)) { $this->_address = null; } elseif ('' == $address || preg_match('/^' . $this->getGrammar('addr-spec') . '$/D', $address)) { $this->_address = $address; } else { throw new Swift_RfcComplianceException( 'Address set in PathHeader does not comply with addr-spec of RFC 2822.' ); } $this->setCachedValue(null); } public function getAddress() { return $this->_address; } public function getFieldBody() { if (!$this->getCachedValue()) { if (isset($this->_address)) { $this->setCachedValue('<' . $this->_address . '>'); } } return $this->getCachedValue(); } }   class Swift_Plugins_Pop_Pop3Exception extends Swift_IoException { public function __construct($message) { parent::__construct($message); } }   class Swift_Plugins_PopBeforeSmtpPlugin implements Swift_Events_TransportChangeListener, Swift_Plugins_Pop_Pop3Connection { private $_connection; private $_host; private $_port; private $_crypto; private $_username; private $_password; private $_socket; private $_timeout = 10; private $_transport; public function __construct($host, $port = 110, $crypto = null) { $this->_host = $host; $this->_port = $port; $this->_crypto = $crypto; } public static function newInstance($host, $port = 110, $crypto = null) { return new self($host, $port, $crypto); } public function setConnection(Swift_Plugins_Pop_Pop3Connection $connection) { $this->_connection = $connection; return $this; } public function bindSmtp(Swift_Transport $smtp) { $this->_transport = $smtp; } public function setTimeout($timeout) { $this->_timeout = (int) $timeout; return $this; } public function setUsername($username) { $this->_username = $username; return $this; } public function setPassword($password) { $this->_password = $password; return $this; } public function connect() { if (isset($this->_connection)) { $this->_connection->connect(); } else { if (!isset($this->_socket)) { if (!$socket = fsockopen( $this->_getHostString(), $this->_port, $errno, $errstr, $this->_timeout)) { throw new Swift_Plugins_Pop_Pop3Exception( sprintf('Failed to connect to POP3 host [%s]: %s', $this->_host, $errstr) ); } $this->_socket = $socket; if (false === $greeting = fgets($this->_socket)) { throw new Swift_Plugins_Pop_Pop3Exception( sprintf('Failed to connect to POP3 host [%s]', trim($greeting)) ); } $this->_assertOk($greeting); if ($this->_username) { $this->_command(sprintf("USER %s\r\n", $this->_username)); $this->_command(sprintf("PASS %s\r\n", $this->_password)); } } } } public function disconnect() { if (isset($this->_connection)) { $this->_connection->disconnect(); } else { $this->_command("QUIT\r\n"); if (!fclose($this->_socket)) { throw new Swift_Plugins_Pop_Pop3Exception( sprintf('POP3 host [%s] connection could not be stopped', $this->_host) ); } $this->_socket = null; } } public function beforeTransportStarted(Swift_Events_TransportChangeEvent $evt) { if (isset($this->_transport)) { if ($this->_transport !== $evt->getTransport()) { return; } } $this->connect(); $this->disconnect(); } public function transportStarted(Swift_Events_TransportChangeEvent $evt) { } public function beforeTransportStopped(Swift_Events_TransportChangeEvent $evt) { } public function transportStopped(Swift_Events_TransportChangeEvent $evt) { } private function _command($command) { if (!fwrite($this->_socket, $command)) { throw new Swift_Plugins_Pop_Pop3Exception( sprintf('Failed to write command [%s] to POP3 host', trim($command)) ); } if (false === $response = fgets($this->_socket)) { throw new Swift_Plugins_Pop_Pop3Exception( sprintf('Failed to read from POP3 host after command [%s]', trim($command)) ); } $this->_assertOk($response); return $response; } private function _assertOk($response) { if (substr($response, 0, 3) != '+OK') { throw new Swift_Plugins_Pop_Pop3Exception( sprintf('POP3 command failed [%s]', trim($response)) ); } } private function _getHostString() { $host = $this->_host; switch (strtolower($this->_crypto)) { case 'ssl': $host = 'ssl://' . $host; break; case 'tls': $host = 'tls://' . $host; break; } return $host; } }   class Swift_Encoder_QpEncoder implements Swift_Encoder { protected $_charStream; protected $_filter; protected static $_qpMap = array( 0 => '=00', 1 => '=01', 2 => '=02', 3 => '=03', 4 => '=04', 5 => '=05', 6 => '=06', 7 => '=07', 8 => '=08', 9 => '=09', 10 => '=0A', 11 => '=0B', 12 => '=0C', 13 => '=0D', 14 => '=0E', 15 => '=0F', 16 => '=10', 17 => '=11', 18 => '=12', 19 => '=13', 20 => '=14', 21 => '=15', 22 => '=16', 23 => '=17', 24 => '=18', 25 => '=19', 26 => '=1A', 27 => '=1B', 28 => '=1C', 29 => '=1D', 30 => '=1E', 31 => '=1F', 32 => '=20', 33 => '=21', 34 => '=22', 35 => '=23', 36 => '=24', 37 => '=25', 38 => '=26', 39 => '=27', 40 => '=28', 41 => '=29', 42 => '=2A', 43 => '=2B', 44 => '=2C', 45 => '=2D', 46 => '=2E', 47 => '=2F', 48 => '=30', 49 => '=31', 50 => '=32', 51 => '=33', 52 => '=34', 53 => '=35', 54 => '=36', 55 => '=37', 56 => '=38', 57 => '=39', 58 => '=3A', 59 => '=3B', 60 => '=3C', 61 => '=3D', 62 => '=3E', 63 => '=3F', 64 => '=40', 65 => '=41', 66 => '=42', 67 => '=43', 68 => '=44', 69 => '=45', 70 => '=46', 71 => '=47', 72 => '=48', 73 => '=49', 74 => '=4A', 75 => '=4B', 76 => '=4C', 77 => '=4D', 78 => '=4E', 79 => '=4F', 80 => '=50', 81 => '=51', 82 => '=52', 83 => '=53', 84 => '=54', 85 => '=55', 86 => '=56', 87 => '=57', 88 => '=58', 89 => '=59', 90 => '=5A', 91 => '=5B', 92 => '=5C', 93 => '=5D', 94 => '=5E', 95 => '=5F', 96 => '=60', 97 => '=61', 98 => '=62', 99 => '=63', 100 => '=64', 101 => '=65', 102 => '=66', 103 => '=67', 104 => '=68', 105 => '=69', 106 => '=6A', 107 => '=6B', 108 => '=6C', 109 => '=6D', 110 => '=6E', 111 => '=6F', 112 => '=70', 113 => '=71', 114 => '=72', 115 => '=73', 116 => '=74', 117 => '=75', 118 => '=76', 119 => '=77', 120 => '=78', 121 => '=79', 122 => '=7A', 123 => '=7B', 124 => '=7C', 125 => '=7D', 126 => '=7E', 127 => '=7F', 128 => '=80', 129 => '=81', 130 => '=82', 131 => '=83', 132 => '=84', 133 => '=85', 134 => '=86', 135 => '=87', 136 => '=88', 137 => '=89', 138 => '=8A', 139 => '=8B', 140 => '=8C', 141 => '=8D', 142 => '=8E', 143 => '=8F', 144 => '=90', 145 => '=91', 146 => '=92', 147 => '=93', 148 => '=94', 149 => '=95', 150 => '=96', 151 => '=97', 152 => '=98', 153 => '=99', 154 => '=9A', 155 => '=9B', 156 => '=9C', 157 => '=9D', 158 => '=9E', 159 => '=9F', 160 => '=A0', 161 => '=A1', 162 => '=A2', 163 => '=A3', 164 => '=A4', 165 => '=A5', 166 => '=A6', 167 => '=A7', 168 => '=A8', 169 => '=A9', 170 => '=AA', 171 => '=AB', 172 => '=AC', 173 => '=AD', 174 => '=AE', 175 => '=AF', 176 => '=B0', 177 => '=B1', 178 => '=B2', 179 => '=B3', 180 => '=B4', 181 => '=B5', 182 => '=B6', 183 => '=B7', 184 => '=B8', 185 => '=B9', 186 => '=BA', 187 => '=BB', 188 => '=BC', 189 => '=BD', 190 => '=BE', 191 => '=BF', 192 => '=C0', 193 => '=C1', 194 => '=C2', 195 => '=C3', 196 => '=C4', 197 => '=C5', 198 => '=C6', 199 => '=C7', 200 => '=C8', 201 => '=C9', 202 => '=CA', 203 => '=CB', 204 => '=CC', 205 => '=CD', 206 => '=CE', 207 => '=CF', 208 => '=D0', 209 => '=D1', 210 => '=D2', 211 => '=D3', 212 => '=D4', 213 => '=D5', 214 => '=D6', 215 => '=D7', 216 => '=D8', 217 => '=D9', 218 => '=DA', 219 => '=DB', 220 => '=DC', 221 => '=DD', 222 => '=DE', 223 => '=DF', 224 => '=E0', 225 => '=E1', 226 => '=E2', 227 => '=E3', 228 => '=E4', 229 => '=E5', 230 => '=E6', 231 => '=E7', 232 => '=E8', 233 => '=E9', 234 => '=EA', 235 => '=EB', 236 => '=EC', 237 => '=ED', 238 => '=EE', 239 => '=EF', 240 => '=F0', 241 => '=F1', 242 => '=F2', 243 => '=F3', 244 => '=F4', 245 => '=F5', 246 => '=F6', 247 => '=F7', 248 => '=F8', 249 => '=F9', 250 => '=FA', 251 => '=FB', 252 => '=FC', 253 => '=FD', 254 => '=FE', 255 => '=FF' ); protected static $_safeMap = array(); public function __construct(Swift_CharacterStream $charStream, Swift_StreamFilter $filter = null) { $this->_charStream = $charStream; if (empty(self::$_safeMap)) { foreach (array_merge( array(0x09, 0x20), range(0x21, 0x3C), range(0x3E, 0x7E)) as $byte) { self::$_safeMap[$byte] = chr($byte); } } $this->_filter = $filter; } public function encodeString($string, $firstLineOffset = 0, $maxLineLength = 0) { if ($maxLineLength > 76 || $maxLineLength <= 0) { $maxLineLength = 76; } $thisLineLength = $maxLineLength - $firstLineOffset; $lines = array(); $lNo = 0; $lines[$lNo] = ''; $currentLine =& $lines[$lNo++]; $size=$lineLen=0; $this->_charStream->flushContents(); $this->_charStream->importString($string); while (false !== $bytes = $this->_nextSequence()) { if (isset($this->_filter)) { while ($this->_filter->shouldBuffer($bytes)) { if (false === $moreBytes = $this->_nextSequence(1)) { break; } foreach ($moreBytes as $b) { $bytes[] = $b; } } $bytes = $this->_filter->filter($bytes); } $enc = $this->_encodeByteSequence($bytes, $size); if ($currentLine && $lineLen+$size >= $thisLineLength) { $lines[$lNo] = ''; $currentLine =& $lines[$lNo++]; $thisLineLength = $maxLineLength; $lineLen=0; } $lineLen+=$size; $currentLine .= $enc; } return $this->_standardize(implode("=\r\n", $lines)); } public function charsetChanged($charset) { $this->_charStream->setCharacterSet($charset); } protected function _encodeByteSequence(array $bytes, &$size) { $ret = ''; $size=0; foreach ($bytes as $b) { if (isset(self::$_safeMap[$b])) { $ret .= self::$_safeMap[$b]; ++$size; } else { $ret .= self::$_qpMap[$b]; $size+=3; } } return $ret; } protected function _nextSequence($size = 4) { return $this->_charStream->readBytes($size); } protected function _standardize($string) { $string = str_replace(array("\t=0D=0A", " =0D=0A", "=0D=0A"), array("=09\r\n", "=20\r\n", "\r\n"), $string ); switch ($end = ord(substr($string, -1))) { case 0x09: case 0x20: $string = substr_replace($string, self::$_qpMap[$end], -1); } return $string; } }   class Swift_Plugins_ReporterPlugin implements Swift_Events_SendListener { private $_reporter; public function __construct(Swift_Plugins_Reporter $reporter) { $this->_reporter = $reporter; } public function beforeSendPerformed(Swift_Events_SendEvent $evt) { } public function sendPerformed(Swift_Events_SendEvent $evt) { $message = $evt->getMessage(); $failures = array_flip($evt->getFailedRecipients()); foreach ((array) $message->getTo() as $address => $null) { $this->_reporter->notify( $message, $address, (array_key_exists($address, $failures) ? Swift_Plugins_Reporter::RESULT_FAIL : Swift_Plugins_Reporter::RESULT_PASS) ); } foreach ((array) $message->getCc() as $address => $null) { $this->_reporter->notify( $message, $address, (array_key_exists($address, $failures) ? Swift_Plugins_Reporter::RESULT_FAIL : Swift_Plugins_Reporter::RESULT_PASS) ); } foreach ((array) $message->getBcc() as $address => $null) { $this->_reporter->notify( $message, $address, (array_key_exists($address, $failures) ? Swift_Plugins_Reporter::RESULT_FAIL : Swift_Plugins_Reporter::RESULT_PASS) ); } } }   class Swift_Events_ResponseEvent extends Swift_Events_EventObject { private $_valid; private $_response; public function __construct(Swift_Transport $source, $response, $valid = false) { parent::__construct($source); $this->_response = $response; $this->_valid = $valid; } public function getResponse() { return $this->_response; } public function isValid() { return $this->_valid; } }   class Swift_Encoder_Rfc2231Encoder implements Swift_Encoder { private $_charStream; public function __construct(Swift_CharacterStream $charStream) { $this->_charStream = $charStream; } public function encodeString($string, $firstLineOffset = 0, $maxLineLength = 0) { $lines = array(); $lineCount = 0; $lines[] = ''; $currentLine =& $lines[$lineCount++]; if (0 >= $maxLineLength) { $maxLineLength = 75; } $this->_charStream->flushContents(); $this->_charStream->importString($string); $thisLineLength = $maxLineLength - $firstLineOffset; while (false !== $char = $this->_charStream->read(4)) { $encodedChar = rawurlencode($char); if (0 != strlen($currentLine) && strlen($currentLine . $encodedChar) > $thisLineLength) { $lines[] = ''; $currentLine =& $lines[$lineCount++]; $thisLineLength = $maxLineLength; } $currentLine .= $encodedChar; } return implode("\r\n", $lines); } public function charsetChanged($charset) { $this->_charStream->setCharacterSet($charset); } }   class Swift_Events_SendEvent extends Swift_Events_EventObject { const RESULT_PENDING = 0x0001; const RESULT_SUCCESS = 0x0010; const RESULT_TENTATIVE = 0x0100; const RESULT_FAILED = 0x1000; private $_message; private $_transport; private $failedRecipients = array(); private $result; public function __construct(Swift_Transport $source, Swift_Mime_Message $message) { parent::__construct($source); $this->_message = $message; $this->_result = self::RESULT_PENDING; } public function getTransport() { return $this->getSource(); } public function getMessage() { return $this->_message; } public function setFailedRecipients($recipients) { $this->_failedRecipients = $recipients; } public function getFailedRecipients() { return $this->_failedRecipients; } public function setResult($result) { $this->_result = $result; } public function getResult() { return $this->_result; } }   class Swift_SendmailTransport extends Swift_Transport_SendmailTransport { public function __construct($command = '/usr/sbin/sendmail -bs') { call_user_func_array( array($this, 'Swift_Transport_SendmailTransport::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('transport.sendmail') ); $this->setCommand($command); } public static function newInstance($command = '/usr/sbin/sendmail -bs') { return new self($command); } }   class Swift_Mime_SimpleHeaderFactory implements Swift_Mime_HeaderFactory { private $_encoder; private $_paramEncoder; private $_charset; public function __construct(Swift_Mime_HeaderEncoder $encoder, Swift_Encoder $paramEncoder, $charset = null) { $this->_encoder = $encoder; $this->_paramEncoder = $paramEncoder; $this->_charset = $charset; } public function createMailboxHeader($name, $addresses = null) { $header = new Swift_Mime_Headers_MailboxHeader($name, $this->_encoder); if (isset($addresses)) { $header->setFieldBodyModel($addresses); } $this->_setHeaderCharset($header); return $header; } public function createDateHeader($name, $timestamp = null) { $header = new Swift_Mime_Headers_DateHeader($name); if (isset($timestamp)) { $header->setFieldBodyModel($timestamp); } $this->_setHeaderCharset($header); return $header; } public function createTextHeader($name, $value = null) { $header = new Swift_Mime_Headers_UnstructuredHeader($name, $this->_encoder); if (isset($value)) { $header->setFieldBodyModel($value); } $this->_setHeaderCharset($header); return $header; } public function createParameterizedHeader($name, $value = null, $params = array()) { $header = new Swift_Mime_Headers_ParameterizedHeader($name, $this->_encoder, (strtolower($name) == 'content-disposition') ? $this->_paramEncoder : null ); if (isset($value)) { $header->setFieldBodyModel($value); } foreach ($params as $k => $v) { $header->setParameter($k, $v); } $this->_setHeaderCharset($header); return $header; } public function createIdHeader($name, $ids = null) { $header = new Swift_Mime_Headers_IdentificationHeader($name); if (isset($ids)) { $header->setFieldBodyModel($ids); } $this->_setHeaderCharset($header); return $header; } public function createPathHeader($name, $path = null) { $header = new Swift_Mime_Headers_PathHeader($name); if (isset($path)) { $header->setFieldBodyModel($path); } $this->_setHeaderCharset($header); return $header; } public function charsetChanged($charset) { $this->_charset = $charset; $this->_encoder->charsetChanged($charset); $this->_paramEncoder->charsetChanged($charset); } private function _setHeaderCharset(Swift_Mime_Header $header) { if (isset($this->_charset)) { $header->setCharset($this->_charset); } } }   class Swift_Mime_SimpleHeaderSet implements Swift_Mime_HeaderSet { private $_factory; private $_headers = array(); private $_order = array(); private $_required = array(); private $_charset; public function __construct(Swift_Mime_HeaderFactory $factory, $charset = null) { $this->_factory = $factory; if (isset($charset)) { $this->setCharset($charset); } } public function setCharset($charset) { $this->_charset = $charset; $this->_factory->charsetChanged($charset); $this->_notifyHeadersOfCharset($charset); } public function addMailboxHeader($name, $addresses = null) { $this->_storeHeader($name, $this->_factory->createMailboxHeader($name, $addresses)); } public function addDateHeader($name, $timestamp = null) { $this->_storeHeader($name, $this->_factory->createDateHeader($name, $timestamp)); } public function addTextHeader($name, $value = null) { $this->_storeHeader($name, $this->_factory->createTextHeader($name, $value)); } public function addParameterizedHeader($name, $value = null, $params = array()) { $this->_storeHeader($name, $this->_factory->createParameterizedHeader($name, $value, $params)); } public function addIdHeader($name, $ids = null) { $this->_storeHeader($name, $this->_factory->createIdHeader($name, $ids)); } public function addPathHeader($name, $path = null) { $this->_storeHeader($name, $this->_factory->createPathHeader($name, $path)); } public function has($name, $index = 0) { $lowerName = strtolower($name); return array_key_exists($lowerName, $this->_headers) && array_key_exists($index, $this->_headers[$lowerName]); } public function set(Swift_Mime_Header $header, $index = 0) { $this->_storeHeader($header->getFieldName(), $header, $index); } public function get($name, $index = 0) { if ($this->has($name, $index)) { $lowerName = strtolower($name); return $this->_headers[$lowerName][$index]; } } public function getAll($name = null) { if (!isset($name)) { $headers = array(); foreach ($this->_headers as $collection) { $headers = array_merge($headers, $collection); } return $headers; } $lowerName = strtolower($name); if (!array_key_exists($lowerName, $this->_headers)) { return array(); } return $this->_headers[$lowerName]; } public function remove($name, $index = 0) { $lowerName = strtolower($name); unset($this->_headers[$lowerName][$index]); } public function removeAll($name) { $lowerName = strtolower($name); unset($this->_headers[$lowerName]); } public function newInstance() { return new self($this->_factory); } public function defineOrdering(array $sequence) { $this->_order = array_flip(array_map('strtolower', $sequence)); } public function setAlwaysDisplayed(array $names) { $this->_required = array_flip(array_map('strtolower', $names)); } public function charsetChanged($charset) { $this->setCharset($charset); } public function toString() { $string = ''; $headers = $this->_headers; if ($this->_canSort()) { uksort($headers, array($this, '_sortHeaders')); } foreach ($headers as $collection) { foreach ($collection as $header) { if ($this->_isDisplayed($header) || $header->getFieldBody() != '') { $string .= $header->toString(); } } } return $string; } public function __toString() { return $this->toString(); } private function _storeHeader($name, Swift_Mime_Header $header, $offset = null) { if (!isset($this->_headers[strtolower($name)])) { $this->_headers[strtolower($name)] = array(); } if (!isset($offset)) { $this->_headers[strtolower($name)][] = $header; } else { $this->_headers[strtolower($name)][$offset] = $header; } } private function _canSort() { return count($this->_order) > 0; } private function _sortHeaders($a, $b) { $lowerA = strtolower($a); $lowerB = strtolower($b); $aPos = array_key_exists($lowerA, $this->_order) ? $this->_order[$lowerA] : -1; $bPos = array_key_exists($lowerB, $this->_order) ? $this->_order[$lowerB] : -1; if ($aPos == -1) { return 1; } elseif ($bPos == -1) { return -1; } return ($aPos < $bPos) ? -1 : 1; } private function _isDisplayed(Swift_Mime_Header $header) { return array_key_exists(strtolower($header->getFieldName()), $this->_required); } private function _notifyHeadersOfCharset($charset) { foreach ($this->_headers as $headerGroup) { foreach ($headerGroup as $header) { $header->setCharset($charset); } } } }   class Swift_KeyCache_SimpleKeyCacheInputStream implements Swift_KeyCache_KeyCacheInputStream { private $_keyCache; private $_nsKey; private $_itemKey; private $_writeThrough = null; public function setKeyCache(Swift_KeyCache $keyCache) { $this->_keyCache = $keyCache; } public function setWriteThroughStream(Swift_InputByteStream $is) { $this->_writeThrough = $is; } public function write($bytes, Swift_InputByteStream $is = null) { $this->_keyCache->setString( $this->_nsKey, $this->_itemKey, $bytes, Swift_KeyCache::MODE_APPEND ); if (isset($is)) { $is->write($bytes); } if (isset($this->_writeThrough)) { $this->_writeThrough->write($bytes); } } public function commit() { } public function bind(Swift_InputByteStream $is) { } public function unbind(Swift_InputByteStream $is) { } public function flushBuffers() { $this->_keyCache->clearKey($this->_nsKey, $this->_itemKey); } public function setNsKey($nsKey) { $this->_nsKey = $nsKey; } public function setItemKey($itemKey) { $this->_itemKey = $itemKey; } public function __clone() { $this->_writeThrough = null; } }   class Swift_Mime_SimpleMimeEntity implements Swift_Mime_MimeEntity { private $_headers; private $_body; private $_encoder; private $_boundary; private $_compositeRanges = array( 'multipart/mixed' => array(self::LEVEL_TOP, self::LEVEL_MIXED), 'multipart/alternative' => array(self::LEVEL_MIXED, self::LEVEL_ALTERNATIVE), 'multipart/related' => array(self::LEVEL_ALTERNATIVE, self::LEVEL_RELATED) ); private $_compoundLevelFilters = array(); private $_nestingLevel = self::LEVEL_ALTERNATIVE; private $_cache; private $_immediateChildren = array(); private $_children = array(); private $_maxLineLength = 78; private $_alternativePartOrder = array( 'text/plain' => 1, 'text/html' => 2, 'multipart/related' => 3 ); private $_id; private $_cacheKey; protected $_userContentType; public function __construct(Swift_Mime_HeaderSet $headers, Swift_Mime_ContentEncoder $encoder, Swift_KeyCache $cache) { $this->_cacheKey = uniqid(); $this->_cache = $cache; $this->_headers = $headers; $this->setEncoder($encoder); $this->_headers->defineOrdering( array('Content-Type', 'Content-Transfer-Encoding') ); $this->_compoundLevelFilters = array( (self::LEVEL_ALTERNATIVE + self::LEVEL_RELATED) => array( self::LEVEL_ALTERNATIVE => array( 'text/plain' => self::LEVEL_ALTERNATIVE, 'text/html' => self::LEVEL_RELATED ) ) ); $this->_id = $this->getRandomId(); } public function generateId() { $this->setId($this->getRandomId()); return $this->_id; } public function getHeaders() { return $this->_headers; } public function getNestingLevel() { return $this->_nestingLevel; } public function getContentType() { return $this->_getHeaderFieldModel('Content-Type'); } public function setContentType($type) { $this->_setContentTypeInHeaders($type); $this->_userContentType = $type; return $this; } public function getId() { return $this->_headers->has($this->_getIdField()) ? current((array) $this->_getHeaderFieldModel($this->_getIdField())) : $this->_id; } public function setId($id) { if (!$this->_setHeaderFieldModel($this->_getIdField(), $id)) { $this->_headers->addIdHeader($this->_getIdField(), $id); } $this->_id = $id; return $this; } public function getDescription() { return $this->_getHeaderFieldModel('Content-Description'); } public function setDescription($description) { if (!$this->_setHeaderFieldModel('Content-Description', $description)) { $this->_headers->addTextHeader('Content-Description', $description); } return $this; } public function getMaxLineLength() { return $this->_maxLineLength; } public function setMaxLineLength($length) { $this->_maxLineLength = $length; return $this; } public function getChildren() { return $this->_children; } public function setChildren(array $children, $compoundLevel = null) { $compoundLevel = isset($compoundLevel) ? $compoundLevel : $this->_getCompoundLevel($children) ; $immediateChildren = array(); $grandchildren = array(); $newContentType = $this->_userContentType; foreach ($children as $child) { $level = $this->_getNeededChildLevel($child, $compoundLevel); if (empty($immediateChildren)) { $immediateChildren = array($child); } else { $nextLevel = $this->_getNeededChildLevel($immediateChildren[0], $compoundLevel); if ($nextLevel == $level) { $immediateChildren[] = $child; } elseif ($level < $nextLevel) { $grandchildren = array_merge($grandchildren, $immediateChildren); $immediateChildren = array($child); } else { $grandchildren[] = $child; } } } if (!empty($immediateChildren)) { $lowestLevel = $this->_getNeededChildLevel($immediateChildren[0], $compoundLevel); foreach ($this->_compositeRanges as $mediaType => $range) { if ($lowestLevel > $range[0] && $lowestLevel <= $range[1]) { $newContentType = $mediaType; break; } } if (!empty($grandchildren)) { $subentity = $this->_createChild(); $subentity->_setNestingLevel($lowestLevel); $subentity->setChildren($grandchildren, $compoundLevel); array_unshift($immediateChildren, $subentity); } } $this->_immediateChildren = $immediateChildren; $this->_children = $children; $this->_setContentTypeInHeaders($newContentType); $this->_fixHeaders(); $this->_sortChildren(); return $this; } public function getBody() { return ($this->_body instanceof Swift_OutputByteStream) ? $this->_readStream($this->_body) : $this->_body; } public function setBody($body, $contentType = null) { if ($body !== $this->_body) { $this->_clearCache(); } $this->_body = $body; if (isset($contentType)) { $this->setContentType($contentType); } return $this; } public function getEncoder() { return $this->_encoder; } public function setEncoder(Swift_Mime_ContentEncoder $encoder) { if ($encoder !== $this->_encoder) { $this->_clearCache(); } $this->_encoder = $encoder; $this->_setEncoding($encoder->getName()); $this->_notifyEncoderChanged($encoder); return $this; } public function getBoundary() { if (!isset($this->_boundary)) { $this->_boundary = '_=_swift_v4_' . time() . uniqid() . '_=_'; } return $this->_boundary; } public function setBoundary($boundary) { $this->_assertValidBoundary($boundary); $this->_boundary = $boundary; return $this; } public function charsetChanged($charset) { $this->_notifyCharsetChanged($charset); } public function encoderChanged(Swift_Mime_ContentEncoder $encoder) { $this->_notifyEncoderChanged($encoder); } public function toString() { $string = $this->_headers->toString(); if (isset($this->_body) && empty($this->_immediateChildren)) { if ($this->_cache->hasKey($this->_cacheKey, 'body')) { $body = $this->_cache->getString($this->_cacheKey, 'body'); } else { $body = "\r\n" . $this->_encoder->encodeString($this->getBody(), 0, $this->getMaxLineLength() ); $this->_cache->setString($this->_cacheKey, 'body', $body, Swift_KeyCache::MODE_WRITE ); } $string .= $body; } if (!empty($this->_immediateChildren)) { foreach ($this->_immediateChildren as $child) { $string .= "\r\n\r\n--" . $this->getBoundary() . "\r\n"; $string .= $child->toString(); } $string .= "\r\n\r\n--" . $this->getBoundary() . "--\r\n"; } return $string; } public function __toString() { return $this->toString(); } public function toByteStream(Swift_InputByteStream $is) { $is->write($this->_headers->toString()); $is->commit(); if (empty($this->_immediateChildren)) { if (isset($this->_body)) { if ($this->_cache->hasKey($this->_cacheKey, 'body')) { $this->_cache->exportToByteStream($this->_cacheKey, 'body', $is); } else { $cacheIs = $this->_cache->getInputByteStream($this->_cacheKey, 'body'); if ($cacheIs) { $is->bind($cacheIs); } $is->write("\r\n"); if ($this->_body instanceof Swift_OutputByteStream) { $this->_body->setReadPointer(0); $this->_encoder->encodeByteStream($this->_body, $is, 0, $this->getMaxLineLength() ); } else { $is->write($this->_encoder->encodeString( $this->getBody(), 0, $this->getMaxLineLength() )); } if ($cacheIs) { $is->unbind($cacheIs); } } } } if (!empty($this->_immediateChildren)) { foreach ($this->_immediateChildren as $child) { $is->write("\r\n\r\n--" . $this->getBoundary() . "\r\n"); $child->toByteStream($is); } $is->write("\r\n\r\n--" . $this->getBoundary() . "--\r\n"); } } protected function _getIdField() { return 'Content-ID'; } protected function _getHeaderFieldModel($field) { if ($this->_headers->has($field)) { return $this->_headers->get($field)->getFieldBodyModel(); } } protected function _setHeaderFieldModel($field, $model) { if ($this->_headers->has($field)) { $this->_headers->get($field)->setFieldBodyModel($model); return true; } else { return false; } } protected function _getHeaderParameter($field, $parameter) { if ($this->_headers->has($field)) { return $this->_headers->get($field)->getParameter($parameter); } } protected function _setHeaderParameter($field, $parameter, $value) { if ($this->_headers->has($field)) { $this->_headers->get($field)->setParameter($parameter, $value); return true; } else { return false; } } protected function _fixHeaders() { if (count($this->_immediateChildren)) { $this->_setHeaderParameter('Content-Type', 'boundary', $this->getBoundary() ); $this->_headers->remove('Content-Transfer-Encoding'); } else { $this->_setHeaderParameter('Content-Type', 'boundary', null); $this->_setEncoding($this->_encoder->getName()); } } protected function _getCache() { return $this->_cache; } protected function _clearCache() { $this->_cache->clearKey($this->_cacheKey, 'body'); } protected function getRandomId() { $idLeft = time() . '.' . uniqid(); $idRight = !empty($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : 'swift.generated'; return $idLeft . '@' . $idRight; } private function _readStream(Swift_OutputByteStream $os) { $string = ''; while (false !== $bytes = $os->read(8192)) { $string .= $bytes; } return $string; } private function _setEncoding($encoding) { if (!$this->_setHeaderFieldModel('Content-Transfer-Encoding', $encoding)) { $this->_headers->addTextHeader('Content-Transfer-Encoding', $encoding); } } private function _assertValidBoundary($boundary) { if (!preg_match( '/^[a-z0-9\'\(\)\+_\-,\.\/:=\?\ ]{0,69}[a-z0-9\'\(\)\+_\-,\.\/:=\?]$/Di', $boundary)) { throw new Swift_RfcComplianceException('Mime boundary set is not RFC 2046 compliant.'); } } private function _setContentTypeInHeaders($type) { if (!$this->_setHeaderFieldModel('Content-Type', $type)) { $this->_headers->addParameterizedHeader('Content-Type', $type); } } private function _setNestingLevel($level) { $this->_nestingLevel = $level; } private function _getCompoundLevel($children) { $level = 0; foreach ($children as $child) { $level |= $child->getNestingLevel(); } return $level; } private function _getNeededChildLevel($child, $compoundLevel) { $filter = array(); foreach ($this->_compoundLevelFilters as $bitmask => $rules) { if (($compoundLevel & $bitmask) === $bitmask) { $filter = $rules + $filter; } } $realLevel = $child->getNestingLevel(); $lowercaseType = strtolower($child->getContentType()); if (isset($filter[$realLevel]) && isset($filter[$realLevel][$lowercaseType])) { return $filter[$realLevel][$lowercaseType]; } else { return $realLevel; } } private function _createChild() { return new self($this->_headers->newInstance(), $this->_encoder, $this->_cache); } private function _notifyEncoderChanged(Swift_Mime_ContentEncoder $encoder) { foreach ($this->_immediateChildren as $child) { $child->encoderChanged($encoder); } } private function _notifyCharsetChanged($charset) { $this->_encoder->charsetChanged($charset); $this->_headers->charsetChanged($charset); foreach ($this->_immediateChildren as $child) { $child->charsetChanged($charset); } } private function _sortChildren() { $shouldSort = false; foreach ($this->_immediateChildren as $child) { if ($child->getNestingLevel() == self::LEVEL_ALTERNATIVE) { $shouldSort = true; break; } } if ($shouldSort) { usort($this->_immediateChildren, array($this, '_childSortAlgorithm')); } } private function _childSortAlgorithm($a, $b) { $typePrefs = array(); $types = array( strtolower($a->getContentType()), strtolower($b->getContentType()) ); foreach ($types as $type) { $typePrefs[] = (array_key_exists($type, $this->_alternativePartOrder)) ? $this->_alternativePartOrder[$type] : (max($this->_alternativePartOrder) + 1); } return ($typePrefs[0] >= $typePrefs[1]) ? 1 : -1; } public function __destruct() { $this->_cache->clearAll($this->_cacheKey); } }   class Swift_SmtpTransport extends Swift_Transport_EsmtpTransport { public function __construct($host = 'localhost', $port = 25, $security = null) { call_user_func_array( array($this, 'Swift_Transport_EsmtpTransport::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('transport.smtp') ); $this->setHost($host); $this->setPort($port); $this->setEncryption($security); } public static function newInstance($host = 'localhost', $port = 25, $security = null) { return new self($host, $port, $security); } }   class Swift_Transport_StreamBuffer extends Swift_ByteStream_AbstractFilterableInputStream implements Swift_Transport_IoBuffer { private $_stream; private $_in; private $_out; private $_params = array(); private $_replacementFactory; private $_translations = array(); public function __construct( Swift_ReplacementFilterFactory $replacementFactory) { $this->_replacementFactory = $replacementFactory; } public function initialize(array $params) { $this->_params = $params; switch ($params['type']) { case self::TYPE_PROCESS: $this->_establishProcessConnection(); break; case self::TYPE_SOCKET: default: $this->_establishSocketConnection(); break; } } public function setParam($param, $value) { if (isset($this->_stream)) { switch ($param) { case 'protocol': if (!array_key_exists('protocol', $this->_params) || $value != $this->_params['protocol']) { if ('tls' == $value) { stream_socket_enable_crypto( $this->_stream, true, STREAM_CRYPTO_METHOD_TLS_CLIENT ); } } break; } } $this->_params[$param] = $value; } public function terminate() { if (isset($this->_stream)) { switch ($this->_params['type']) { case self::TYPE_PROCESS: fclose($this->_in); fclose($this->_out); proc_close($this->_stream); break; case self::TYPE_SOCKET: default: fclose($this->_stream); break; } } $this->_stream = null; $this->_out = null; $this->_in = null; } public function setWriteTranslations(array $replacements) { foreach ($this->_translations as $search => $replace) { if (!isset($replacements[$search])) { $this->removeFilter($search); unset($this->_translations[$search]); } } foreach ($replacements as $search => $replace) { if (!isset($this->_translations[$search])) { $this->addFilter( $this->_replacementFactory->createFilter($search, $replace), $search ); $this->_translations[$search] = true; } } } public function readLine($sequence) { if (isset($this->_out) && !feof($this->_out)) { $line = fgets($this->_out); return $line; } } public function read($length) { if (isset($this->_out) && !feof($this->_out)) { $ret = fread($this->_out, $length); return $ret; } } public function setReadPointer($byteOffset) { } protected function _flush() { if (isset($this->_in)) { fflush($this->_in); } } protected function _commit($bytes) { if (isset($this->_in) && fwrite($this->_in, $bytes)) { return ++$this->_sequence; } } private function _establishSocketConnection() { $host = $this->_params['host']; if (!empty($this->_params['protocol'])) { $host = $this->_params['protocol'] . '://' . $host; } $timeout = 15; if (!empty($this->_params['timeout'])) { $timeout = $this->_params['timeout']; } if (!$this->_stream = fsockopen($host, $this->_params['port'], $errno, $errstr, $timeout)) { throw new Swift_TransportException( 'Connection could not be established with host ' . $this->_params['host'] . ' [' . $errstr . ' #' . $errno . ']' ); } if (!empty($this->_params['blocking'])) { stream_set_blocking($this->_stream, 1); } else { stream_set_blocking($this->_stream, 0); } $this->_in =& $this->_stream; $this->_out =& $this->_stream; } private function _establishProcessConnection() { $command = $this->_params['command']; $descriptorSpec = array( 0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'w') ); $this->_stream = proc_open($command, $descriptorSpec, $pipes); stream_set_blocking($pipes[2], 0); if ($err = stream_get_contents($pipes[2])) { throw new Swift_TransportException( 'Process could not be started [' . $err . ']' ); } $this->_in =& $pipes[0]; $this->_out =& $pipes[1]; } }   class Swift_Events_TransportChangeEvent extends Swift_Events_EventObject { public function getTransport() { return $this->getSource(); } }   class Swift_TransportException extends Swift_IoException { public function __construct($message) { parent::__construct($message); } }   class Swift_Events_TransportExceptionEvent extends Swift_Events_EventObject { private $_exception; public function __construct(Swift_Transport $transport, Swift_TransportException $ex) { parent::__construct($transport); $this->_exception = $ex; } public function getException() { return $this->_exception; } }   class Swift_Mime_Headers_UnstructuredHeader extends Swift_Mime_Headers_AbstractHeader { private $_value; public function __construct($name, Swift_Mime_HeaderEncoder $encoder) { $this->setFieldName($name); $this->setEncoder($encoder); } public function getFieldType() { return self::TYPE_TEXT; } public function setFieldBodyModel($model) { $this->setValue($model); } public function getFieldBodyModel() { return $this->getValue(); } public function getValue() { return $this->_value; } public function setValue($value) { $this->clearCachedValueIf($this->_value != $value); $this->_value = $value; } public function getFieldBody() { if (!$this->getCachedValue()) { $this->setCachedValue( str_replace('\\', '\\\\', $this->encodeWords( $this, $this->_value, -1, $this->getCharset(), $this->getEncoder() )) ); } return $this->getCachedValue(); } }   class Swift_Mime_Attachment extends Swift_Mime_SimpleMimeEntity { private $_mimeTypes = array(); public function __construct(Swift_Mime_HeaderSet $headers, Swift_Mime_ContentEncoder $encoder, Swift_KeyCache $cache, $mimeTypes = array()) { parent::__construct($headers, $encoder, $cache); $this->setDisposition('attachment'); $this->setContentType('application/octet-stream'); $this->_mimeTypes = $mimeTypes; } public function getNestingLevel() { return self::LEVEL_MIXED; } public function getDisposition() { return $this->_getHeaderFieldModel('Content-Disposition'); } public function setDisposition($disposition) { if (!$this->_setHeaderFieldModel('Content-Disposition', $disposition)) { $this->getHeaders()->addParameterizedHeader( 'Content-Disposition', $disposition ); } return $this; } public function getFilename() { return $this->_getHeaderParameter('Content-Disposition', 'filename'); } public function setFilename($filename) { $this->_setHeaderParameter('Content-Disposition', 'filename', $filename); $this->_setHeaderParameter('Content-Type', 'name', $filename); return $this; } public function getSize() { return $this->_getHeaderParameter('Content-Disposition', 'size'); } public function setSize($size) { $this->_setHeaderParameter('Content-Disposition', 'size', $size); return $this; } public function setFile(Swift_FileStream $file, $contentType = null) { $this->setFilename(basename($file->getPath())); $this->setBody($file, $contentType); if (!isset($contentType)) { $extension = strtolower(substr( $file->getPath(), strrpos($file->getPath(), '.') + 1 )); if (array_key_exists($extension, $this->_mimeTypes)) { $this->setContentType($this->_mimeTypes[$extension]); } } return $this; } }   class Swift_Mime_ContentEncoder_Base64ContentEncoder extends Swift_Encoder_Base64Encoder implements Swift_Mime_ContentEncoder { public function encodeByteStream( Swift_OutputByteStream $os, Swift_InputByteStream $is, $firstLineOffset = 0, $maxLineLength = 0) { if (0 >= $maxLineLength || 76 < $maxLineLength) { $maxLineLength = 76; } $remainder = 0; while (false !== $bytes = $os->read(8190)) { $encoded = base64_encode($bytes); $encodedTransformed = ''; $thisMaxLineLength = $maxLineLength - $remainder - $firstLineOffset; while ($thisMaxLineLength < strlen($encoded)) { $encodedTransformed .= substr($encoded, 0, $thisMaxLineLength) . "\r\n"; $firstLineOffset = 0; $encoded = substr($encoded, $thisMaxLineLength); $thisMaxLineLength = $maxLineLength; $remainder = 0; } if (0 < $remainingLength = strlen($encoded)) { $remainder += $remainingLength; $encodedTransformed .= $encoded; $encoded = null; } $is->write($encodedTransformed); } } public function getName() { return 'base64'; } }   class Swift_Mime_HeaderEncoder_Base64HeaderEncoder extends Swift_Encoder_Base64Encoder implements Swift_Mime_HeaderEncoder { public function getName() { return 'B'; } }   class Swift_FailoverTransport extends Swift_Transport_FailoverTransport { public function __construct($transports = array()) { call_user_func_array( array($this, 'Swift_Transport_FailoverTransport::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('transport.failover') ); $this->setTransports($transports); } public static function newInstance($transports = array()) { return new self($transports); } }   class Swift_Mime_MimePart extends Swift_Mime_SimpleMimeEntity { protected $_userFormat; protected $_userCharset; protected $_userDelSp; private $_nestingLevel = self::LEVEL_ALTERNATIVE; public function __construct(Swift_Mime_HeaderSet $headers, Swift_Mime_ContentEncoder $encoder, Swift_KeyCache $cache, $charset = null) { parent::__construct($headers, $encoder, $cache); $this->setContentType('text/plain'); if (!is_null($charset)) { $this->setCharset($charset); } } public function setBody($body, $contentType = null, $charset = null) { parent::setBody($body, $contentType); if (isset($charset)) { $this->setCharset($charset); } return $this; } public function getCharset() { return $this->_getHeaderParameter('Content-Type', 'charset'); } public function setCharset($charset) { $this->_setHeaderParameter('Content-Type', 'charset', $charset); if ($charset !== $this->_userCharset) { $this->_clearCache(); } $this->_userCharset = $charset; parent::charsetChanged($charset); return $this; } public function getFormat() { return $this->_getHeaderParameter('Content-Type', 'format'); } public function setFormat($format) { $this->_setHeaderParameter('Content-Type', 'format', $format); $this->_userFormat = $format; return $this; } public function getDelSp() { return ($this->_getHeaderParameter('Content-Type', 'delsp') == 'yes') ? true : false; } public function setDelSp($delsp = true) { $this->_setHeaderParameter('Content-Type', 'delsp', $delsp ? 'yes' : null); $this->_userDelSp = $delsp; return $this; } public function getNestingLevel() { return $this->_nestingLevel; } public function charsetChanged($charset) { $this->setCharset($charset); } protected function _fixHeaders() { parent::_fixHeaders(); if (count($this->getChildren())) { $this->_setHeaderParameter('Content-Type', 'charset', null); $this->_setHeaderParameter('Content-Type', 'format', null); $this->_setHeaderParameter('Content-Type', 'delsp', null); } else { $this->setCharset($this->_userCharset); $this->setFormat($this->_userFormat); $this->setDelSp($this->_userDelSp); } } protected function _setNestingLevel($level) { $this->_nestingLevel = $level; } }   class Swift_Mime_Headers_ParameterizedHeader extends Swift_Mime_Headers_UnstructuredHeader implements Swift_Mime_ParameterizedHeader { private $_paramEncoder; private $_params = array(); private $_tokenRe; public function __construct($name, Swift_Mime_HeaderEncoder $encoder, Swift_Encoder $paramEncoder = null) { $this->setFieldName($name); $this->setEncoder($encoder); $this->_paramEncoder = $paramEncoder; $this->initializeGrammar(); $this->_tokenRe = '(?:[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7E]+)'; } public function getFieldType() { return self::TYPE_PARAMETERIZED; } public function setCharset($charset) { parent::setCharset($charset); if (isset($this->_paramEncoder)) { $this->_paramEncoder->charsetChanged($charset); } } public function setParameter($parameter, $value) { $this->setParameters(array_merge($this->getParameters(), array($parameter => $value))); } public function getParameter($parameter) { $params = $this->getParameters(); return array_key_exists($parameter, $params) ? $params[$parameter] : null; } public function setParameters(array $parameters) { $this->clearCachedValueIf($this->_params != $parameters); $this->_params = $parameters; } public function getParameters() { return $this->_params; } public function getFieldBody() { $body = parent::getFieldBody(); foreach ($this->_params as $name => $value) { if (!is_null($value)) { $body .= '; ' . $this->_createParameter($name, $value); } } return $body; } protected function toTokens($string = null) { $tokens = parent::toTokens(parent::getFieldBody()); foreach ($this->_params as $name => $value) { if (!is_null($value)) { $tokens[count($tokens)-1] .= ';'; $tokens = array_merge($tokens, $this->generateTokenLines( ' ' . $this->_createParameter($name, $value) )); } } return $tokens; } private function _createParameter($name, $value) { $origValue = $value; $encoded = false; $maxValueLength = $this->getMaxLineLength() - strlen($name . '=*N"";') - 1; $firstLineOffset = 0; if (!preg_match('/^' . $this->_tokenRe . '$/D', $value)) { if (!preg_match('/^' . $this->getGrammar('text') . '*$/D', $value)) { $encoded = true; $maxValueLength = $this->getMaxLineLength() - strlen($name . '*N*="";') - 1; $firstLineOffset = strlen( $this->getCharset() . "'" . $this->getLanguage() . "'" ); } } if ($encoded || strlen($value) > $maxValueLength) { if (isset($this->_paramEncoder)) { $value = $this->_paramEncoder->encodeString( $origValue, $firstLineOffset, $maxValueLength ); } else { $value = $this->getTokenAsEncodedWord($origValue); $encoded = false; } } $valueLines = isset($this->_paramEncoder) ? explode("\r\n", $value) : array($value); if (count($valueLines) > 1) { $paramLines = array(); foreach ($valueLines as $i => $line) { $paramLines[] = $name . '*' . $i . $this->_getEndOfParameterValue($line, $encoded, $i == 0); } return implode(";\r\n ", $paramLines); } else { return $name . $this->_getEndOfParameterValue( $valueLines[0], $encoded, true ); } } private function _getEndOfParameterValue($value, $encoded = false, $firstLine = false) { if (!preg_match('/^' . $this->_tokenRe . '$/D', $value)) { $value = '"' . $value . '"'; } $prepend = '='; if ($encoded) { $prepend = '*='; if ($firstLine) { $prepend = '*=' . $this->getCharset() . "'" . $this->getLanguage() . "'"; } } return $prepend . $value; } }   class Swift_Mime_ContentEncoder_PlainContentEncoder implements Swift_Mime_ContentEncoder { private $_name; private $_canonical; public function __construct($name, $canonical = false) { $this->_name = $name; $this->_canonical = $canonical; } public function encodeString($string, $firstLineOffset = 0, $maxLineLength = 0) { if ($this->_canonical) { $string = $this->_canonicalize($string); } return $this->_safeWordWrap($string, $maxLineLength, "\r\n"); } public function encodeByteStream( Swift_OutputByteStream $os, Swift_InputByteStream $is, $firstLineOffset = 0, $maxLineLength = 0) { $leftOver = ''; while (false !== $bytes = $os->read(8192)) { $toencode = $leftOver . $bytes; if ($this->_canonical) { $toencode = $this->_canonicalize($toencode); } $wrapped = $this->_safeWordWrap($toencode, $maxLineLength, "\r\n"); $lastLinePos = strrpos($wrapped, "\r\n"); $leftOver = substr($wrapped, $lastLinePos); $wrapped = substr($wrapped, 0, $lastLinePos); $is->write($wrapped); } if (strlen($leftOver)) { $is->write($leftOver); } } public function getName() { return $this->_name; } public function charsetChanged($charset) { } private function _safeWordwrap($string, $length = 75, $le = "\r\n") { if (0 >= $length) { return $string; } $originalLines = explode($le, $string); $lines = array(); $lineCount = 0; foreach ($originalLines as $originalLine) { $lines[] = ''; $currentLine =& $lines[$lineCount++]; $chunks = preg_split('/(?<=\s)/', $originalLine); foreach ($chunks as $chunk) { if (0 != strlen($currentLine) && strlen($currentLine . $chunk) > $length) { $lines[] = ''; $currentLine =& $lines[$lineCount++]; } $currentLine .= $chunk; } } return implode("\r\n", $lines); } private function _canonicalize($string) { return str_replace( array("\r\n", "\r", "\n"), array("\n", "\n", "\r\n"), $string ); } }   class Swift_Mime_ContentEncoder_QpContentEncoder extends Swift_Encoder_QpEncoder implements Swift_Mime_ContentEncoder { public function __construct(Swift_CharacterStream $charStream, Swift_StreamFilter $filter = null) { parent::__construct($charStream, $filter); } public function encodeByteStream( Swift_OutputByteStream $os, Swift_InputByteStream $is, $firstLineOffset = 0, $maxLineLength = 0) { if ($maxLineLength > 76 || $maxLineLength <= 0) { $maxLineLength = 76; } $thisLineLength = $maxLineLength - $firstLineOffset; $this->_charStream->flushContents(); $this->_charStream->importByteStream($os); $currentLine = ''; $prepend = ''; $size=$lineLen=0; while (false !== $bytes = $this->_nextSequence()) { if (isset($this->_filter)) { while ($this->_filter->shouldBuffer($bytes)) { if (false === $moreBytes = $this->_nextSequence(1)) { break; } foreach ($moreBytes as $b) { $bytes[] = $b; } } $bytes = $this->_filter->filter($bytes); } $enc = $this->_encodeByteSequence($bytes, $size); if ($currentLine && $lineLen+$size >= $thisLineLength) { $is->write($prepend . $this->_standardize($currentLine)); $currentLine = ''; $prepend = "=\r\n"; $thisLineLength = $maxLineLength; $lineLen=0; } $lineLen+=$size; $currentLine .= $enc; } if (strlen($currentLine)) { $is->write($prepend . $this->_standardize($currentLine)); } } public function getName() { return 'quoted-printable'; } }   class Swift_Mime_HeaderEncoder_QpHeaderEncoder extends Swift_Encoder_QpEncoder implements Swift_Mime_HeaderEncoder { private static $_headerSafeMap = array(); public function __construct(Swift_CharacterStream $charStream) { parent::__construct($charStream); if (empty(self::$_headerSafeMap)) { foreach (array_merge( range(0x61, 0x7A), range(0x41, 0x5A), range(0x30, 0x39), array(0x20, 0x21, 0x2A, 0x2B, 0x2D, 0x2F) ) as $byte) { self::$_headerSafeMap[$byte] = chr($byte); } } } public function getName() { return 'Q'; } public function encodeString($string, $firstLineOffset = 0, $maxLineLength = 0) { return str_replace(array(' ', '=20', "=\r\n"), array('_', '_', "\r\n"), parent::encodeString($string, $firstLineOffset, $maxLineLength) ); } protected function _encodeByteSequence(array $bytes, &$size) { $ret = ''; $size=0; foreach ($bytes as $b) { if (isset(self::$_headerSafeMap[$b])) { $ret .= self::$_headerSafeMap[$b]; ++$size; } else { $ret .= self::$_qpMap[$b]; $size+=3; } } return $ret; } }   class Swift_Plugins_ThrottlerPlugin extends Swift_Plugins_BandwidthMonitorPlugin implements Swift_Plugins_Sleeper, Swift_Plugins_Timer { const BYTES_PER_MINUTE = 0x01; const MESSAGES_PER_MINUTE = 0x10; private $_sleeper; private $_timer; private $_start; private $_rate; private $_mode; private $_messages = 0; public function __construct($rate, $mode = self::BYTES_PER_MINUTE, Swift_Plugins_Sleeper $sleeper = null, Swift_Plugins_Timer $timer = null) { $this->_rate = $rate; $this->_mode = $mode; $this->_sleeper = $sleeper; $this->_timer = $timer; } public function beforeSendPerformed(Swift_Events_SendEvent $evt) { $time = $this->getTimestamp(); if (!isset($this->_start)) { $this->_start = $time; } $duration = $time - $this->_start; if (self::BYTES_PER_MINUTE == $this->_mode) { $sleep = $this->_throttleBytesPerMinute($duration); } else { $sleep = $this->_throttleMessagesPerMinute($duration); } if ($sleep > 0) { $this->sleep($sleep); } } public function sendPerformed(Swift_Events_SendEvent $evt) { parent::sendPerformed($evt); ++$this->_messages; } public function sleep($seconds) { if (isset($this->_sleeper)) { $this->_sleeper->sleep($seconds); } else { sleep($seconds); } } public function getTimestamp() { if (isset($this->_timer)) { return $this->_timer->getTimestamp(); } else { return time(); } } private function _throttleBytesPerMinute($timePassed) { $expectedDuration = $this->getBytesOut() / ($this->_rate / 60); return (int) ceil($expectedDuration - $timePassed); } private function _throttleMessagesPerMinute($timePassed) { $expectedDuration = $this->_messages / ($this->_rate / 60); return (int) ceil($expectedDuration - $timePassed); } }   class Swift_Attachment extends Swift_Mime_Attachment { public function __construct($data = null, $filename = null, $contentType = null) { call_user_func_array( array($this, 'Swift_Mime_Attachment::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('mime.attachment') ); $this->setBody($data); $this->setFilename($filename); if ($contentType) { $this->setContentType($contentType); } } public static function newInstance($data = null, $filename = null, $contentType = null) { return new self($data, $filename, $contentType); } public static function fromPath($path, $contentType = null) { return self::newInstance()->setFile( new Swift_ByteStream_FileByteStream($path), $contentType ); } }   class Swift_Mime_EmbeddedFile extends Swift_Mime_Attachment { public function __construct(Swift_Mime_HeaderSet $headers, Swift_Mime_ContentEncoder $encoder, Swift_KeyCache $cache, $mimeTypes = array()) { parent::__construct($headers, $encoder, $cache, $mimeTypes); $this->setDisposition('inline'); $this->setId($this->getId()); } public function getNestingLevel() { return self::LEVEL_RELATED; } }   class Swift_MimePart extends Swift_Mime_MimePart { public function __construct($body = null, $contentType = null, $charset = null) { call_user_func_array( array($this, 'Swift_Mime_MimePart::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('mime.part') ); if (!isset($charset)) { $charset = Swift_DependencyContainer::getInstance() ->lookup('properties.charset'); } $this->setBody($body); $this->setCharset($charset); if ($contentType) { $this->setContentType($contentType); } } public static function newInstance($body = null, $contentType = null, $charset = null) { return new self($body, $contentType, $charset); } }   class Swift_Mime_SimpleMessage extends Swift_Mime_MimePart implements Swift_Mime_Message { public function __construct(Swift_Mime_HeaderSet $headers, Swift_Mime_ContentEncoder $encoder, Swift_KeyCache $cache, $charset = null) { parent::__construct($headers, $encoder, $cache, $charset); $this->getHeaders()->defineOrdering(array( 'Return-Path', 'Sender', 'Message-ID', 'Date', 'Subject', 'From', 'Reply-To', 'To', 'Cc', 'Bcc', 'MIME-Version', 'Content-Type', 'Content-Transfer-Encoding' )); $this->getHeaders()->setAlwaysDisplayed( array('Date', 'Message-ID', 'From') ); $this->getHeaders()->addTextHeader('MIME-Version', '1.0'); $this->setDate(time()); $this->setId($this->getId()); $this->getHeaders()->addMailboxHeader('From'); } public function getNestingLevel() { return self::LEVEL_TOP; } public function setSubject($subject) { if (!$this->_setHeaderFieldModel('Subject', $subject)) { $this->getHeaders()->addTextHeader('Subject', $subject); } return $this; } public function getSubject() { return $this->_getHeaderFieldModel('Subject'); } public function setDate($date) { if (!$this->_setHeaderFieldModel('Date', $date)) { $this->getHeaders()->addDateHeader('Date', $date); } return $this; } public function getDate() { return $this->_getHeaderFieldModel('Date'); } public function setReturnPath($address) { if (!$this->_setHeaderFieldModel('Return-Path', $address)) { $this->getHeaders()->addPathHeader('Return-Path', $address); } return $this; } public function getReturnPath() { return $this->_getHeaderFieldModel('Return-Path'); } public function setSender($address, $name = null) { if (!is_array($address) && isset($name)) { $address = array($address => $name); } if (!$this->_setHeaderFieldModel('Sender', (array) $address)) { $this->getHeaders()->addMailboxHeader('Sender', (array) $address); } return $this; } public function getSender() { return $this->_getHeaderFieldModel('Sender'); } public function addFrom($address, $name = null) { $current = $this->getFrom(); $current[$address] = $name; return $this->setFrom($current); } public function setFrom($addresses, $name = null) { if (!is_array($addresses) && isset($name)) { $addresses = array($addresses => $name); } if (!$this->_setHeaderFieldModel('From', (array) $addresses)) { $this->getHeaders()->addMailboxHeader('From', (array) $addresses); } return $this; } public function getFrom() { return $this->_getHeaderFieldModel('From'); } public function addReplyTo($address, $name = null) { $current = $this->getReplyTo(); $current[$address] = $name; return $this->setReplyTo($current); } public function setReplyTo($addresses, $name = null) { if (!is_array($addresses) && isset($name)) { $addresses = array($addresses => $name); } if (!$this->_setHeaderFieldModel('Reply-To', (array) $addresses)) { $this->getHeaders()->addMailboxHeader('Reply-To', (array) $addresses); } return $this; } public function getReplyTo() { return $this->_getHeaderFieldModel('Reply-To'); } public function addTo($address, $name = null) { $current = $this->getTo(); $current[$address] = $name; return $this->setTo($current); } public function setTo($addresses, $name = null) { if (!is_array($addresses) && isset($name)) { $addresses = array($addresses => $name); } if (!$this->_setHeaderFieldModel('To', (array) $addresses)) { $this->getHeaders()->addMailboxHeader('To', (array) $addresses); } return $this; } public function getTo() { return $this->_getHeaderFieldModel('To'); } public function addCc($address, $name = null) { $current = $this->getCc(); $current[$address] = $name; return $this->setCc($current); } public function setCc($addresses, $name = null) { if (!is_array($addresses) && isset($name)) { $addresses = array($addresses => $name); } if (!$this->_setHeaderFieldModel('Cc', (array) $addresses)) { $this->getHeaders()->addMailboxHeader('Cc', (array) $addresses); } return $this; } public function getCc() { return $this->_getHeaderFieldModel('Cc'); } public function addBcc($address, $name = null) { $current = $this->getBcc(); $current[$address] = $name; return $this->setBcc($current); } public function setBcc($addresses, $name = null) { if (!is_array($addresses) && isset($name)) { $addresses = array($addresses => $name); } if (!$this->_setHeaderFieldModel('Bcc', (array) $addresses)) { $this->getHeaders()->addMailboxHeader('Bcc', (array) $addresses); } return $this; } public function getBcc() { return $this->_getHeaderFieldModel('Bcc'); } public function setPriority($priority) { $priorityMap = array( 1 => 'Highest', 2 => 'High', 3 => 'Normal', 4 => 'Low', 5 => 'Lowest' ); $pMapKeys = array_keys($priorityMap); if ($priority > max($pMapKeys)) { $priority = max($pMapKeys); } elseif ($priority < min($pMapKeys)) { $priority = min($pMapKeys); } if (!$this->_setHeaderFieldModel('X-Priority', sprintf('%d (%s)', $priority, $priorityMap[$priority]))) { $this->getHeaders()->addTextHeader('X-Priority', sprintf('%d (%s)', $priority, $priorityMap[$priority])); } return $this; } public function getPriority() { list($priority) = sscanf($this->_getHeaderFieldModel('X-Priority'), '%[1-5]' ); return isset($priority) ? $priority : 3; } public function setReadReceiptTo($addresses) { if (!$this->_setHeaderFieldModel('Disposition-Notification-To', $addresses)) { $this->getHeaders() ->addMailboxHeader('Disposition-Notification-To', $addresses); } return $this; } public function getReadReceiptTo() { return $this->_getHeaderFieldModel('Disposition-Notification-To'); } public function attach(Swift_Mime_MimeEntity $entity) { $this->setChildren(array_merge($this->getChildren(), array($entity))); return $this; } public function detach(Swift_Mime_MimeEntity $entity) { $newChildren = array(); foreach ($this->getChildren() as $child) { if ($entity !== $child) { $newChildren[] = $child; } } $this->setChildren($newChildren); return $this; } public function embed(Swift_Mime_MimeEntity $entity) { $this->attach($entity); return 'cid:' . $entity->getId(); } public function toString() { if (count($children = $this->getChildren()) > 0 && $this->getBody() != '') { $this->setChildren(array_merge(array($this->_becomeMimePart()), $children)); $string = parent::toString(); $this->setChildren($children); } else { $string = parent::toString(); } return $string; } public function __toString() { return $this->toString(); } public function toByteStream(Swift_InputByteStream $is) { if (count($children = $this->getChildren()) > 0 && $this->getBody() != '') { $this->setChildren(array_merge(array($this->_becomeMimePart()), $children)); parent::toByteStream($is); $this->setChildren($children); } else { parent::toByteStream($is); } } protected function _getIdField() { return 'Message-ID'; } private function _becomeMimePart() { $part = new parent($this->getHeaders()->newInstance(), $this->getEncoder(), $this->_getCache(), $this->_userCharset ); $part->setContentType($this->_userContentType); $part->setBody($this->getBody()); $part->setFormat($this->_userFormat); $part->setDelSp($this->_userDelSp); $part->_setNestingLevel($this->_getTopNestingLevel()); return $part; } private function _getTopNestingLevel() { $highestLevel = $this->getNestingLevel(); foreach ($this->getChildren() as $child) { $childLevel = $child->getNestingLevel(); if ($highestLevel < $childLevel) { $highestLevel = $childLevel; } } return $highestLevel; } }   class Swift_EmbeddedFile extends Swift_Mime_EmbeddedFile { public function __construct($data = null, $filename = null, $contentType = null) { call_user_func_array( array($this, 'Swift_Mime_EmbeddedFile::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('mime.embeddedfile') ); $this->setBody($data); $this->setFilename($filename); if ($contentType) { $this->setContentType($contentType); } } public static function newInstance($data = null, $filename = null, $contentType = null) { return new self($data, $filename, $contentType); } public static function fromPath($path) { return self::newInstance()->setFile( new Swift_ByteStream_FileByteStream($path) ); } }   class Swift_Message extends Swift_Mime_SimpleMessage { public function __construct($subject = null, $body = null, $contentType = null, $charset = null) { call_user_func_array( array($this, 'Swift_Mime_SimpleMessage::__construct'), Swift_DependencyContainer::getInstance() ->createDependenciesFor('mime.message') ); if (!isset($charset)) { $charset = Swift_DependencyContainer::getInstance() ->lookup('properties.charset'); } $this->setSubject($subject); $this->setBody($body); $this->setCharset($charset); if ($contentType) { $this->setContentType($contentType); } } public static function newInstance($subject = null, $body = null, $contentType = null, $charset = null) { return new self($subject, $body, $contentType, $charset); } public function addPart($body, $contentType = null, $charset = null) { return $this->attach(Swift_MimePart::newInstance( $body, $contentType, $charset )); } }   class Swift_Image extends Swift_EmbeddedFile { public function __construct($data = null, $filename = null, $contentType = null) { parent::__construct($data, $filename, $contentType); } public static function newInstance($data = null, $filename = null, $contentType = null) { return new self($data, $filename, $contentType); } public static function fromPath($path) { $image = self::newInstance()->setFile( new Swift_ByteStream_FileByteStream($path) ); return $image; } } ?>